<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EOSIOAnalyzer架构</title>
    <url>/2021/12/13/EOSIOAnalyzer%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a266505a5d2d04b3b63f322e11f39add85949fc4f2f905b752f8d42d039492cb">5088eb8f956e10734794234745c584a5f05121a1a8ea874934a5d6449839d6eb50c0126acabad70f38f728540898d17ab116165e981697f16afcb3e1d767e1ae78512c363037211213fcffd05e9dac90a5969e805cab3bafb421ce1a4a7622fdfa99322e620aaa0a38d8a19e3da9b5080523218829a7df1ea58905bd6b5d853ffcc0d4eb8e4d36d1f0130b74c734330ac7fbe8fc591eb20601966274470ee78e4c2d7116f3a0fa11fa14f6096564444f14ea57392f3fea205715fa4ecc5512045b1f808bb3c2dbb740ea2c16413a5bb8172b6169e82827449956d10c0a97ac0fb477a5feccd84b85942bb95b2ed23074886c3b4615cd7f2562b7b62db27ff7f5845357b8340dfbf004db40a435de5d27bd10ca5c4667f4ad91a9e3ec72a899ef1cfae9a5fd6257adaf37e392395076d7df5533147e3ffb507fa09933e34d01f5b8e3f507ef25c5281d7cbedca452aed2f93b5a79daa76faca6f39e134d07a6e2d6b5d73613f5eb49565831ff40fcd44d9dfae75b114fa93dcd0346d197cd39f9f29e4f93f28a74631ba89232511e8309ed2aaa37cf209f32ea232b980a549e21011ae579e4e96be39f46e88ee30e8203bd60c184937942c392e8f0e6355d5ee1b2420d6d7f55a021a6397b8b857b905b344c8076ad9fbc461f9bb225a4b83486560e47379ce9fc002708eb87b4b8a6c03fcb9e1c591dd06de23b9a3e7fb2c401664c145336c7430ed0afbd736bbfab00cc21e7a233687fb0516dcbd52852191e2cbeaf28b3fc6bb3f23e087470a89e02921c401d2b8cdd295007545c81a8cb55a3fc5f8b8fa0fc7906fc8bb8cc923fe55511f22b6d8345cce0399fa9b0b5e97204a314c3b043b3d615ea798af8e0c24eb1d90af8535f7aa67cf9275c4854651fcab6991017144596450069f736b909d24b7edf4898821e4f90c874f75c7d88ee17b0880ef260c1ec272239616154190626e75321a67d4f9e8db31dc580067d81df5508b5e50dc90d4b51c87bccf0c025c793fa6ddd5cfa61c34e44672de663802acaecfa7d81f2048fad82824ed031a69cdae13d6cd4e770295acca7db0774f49cc002bc62ede05a1cfc638f334020c949e4e566f618fcb70c34bf85073917086368a92e4fa8725b238072862b7421e11b6a6605f105923ee7c2fcc09bd748f9b81b38399bc159ab405a36502f6cf00ebaf6bbf1920dbb4e7ea34a59f58cbaeb8f02a71e9317e655642ba154ac0270ac9e1bae8333045cb19b8a6094e35f3cd92d519d2e9bf66946d70473f75133207674563f82cf23515184061905abc86d150feea214f98491061f32267c6f78986896c236c4de90da9678c9d5369f537ca05e4a8a615b9137c8e72efec5267fc1188dc9ddcd6abb390940f68e8f62ae8e414845ba7f24fc53be5ef431c40e885ac6ae7cffd6b6604d578ae9376e1cbea19cf7fa1e0b43c9ed3bacf34d76ce0e6b472f4886e5099bd546f260b0057d523538cee117eecc6cf6c01dc8009e120290f5b1df1c97e56000e3702f938d8e86e3f7c3de8fd646d0335b9f3edde04b94861c62c536790dc3bf6ca9b8911aeb699cce931226f90712b17144f3a4dd2e132f268e63700e671767263482d1ba2ab0fa1ad62de3619c9e1f758e8ae8b3aeb7266b96c143c89845de563ec2ddf8f40a9bd647f8135bd4832d9c821ae373090d76fd44c834b6be25b80e61314a1f5ef26779c5676623284da67420d4a5784e1e0b7fb401b74bce52ec21cfbbdb7c159215b2cecff510efebafbdc908d23d9b983bbc94303a67386719527d3fd31b125ba21f9c4ab800fdc63edfbb008c1bfd9d4e73f21b6c8f59ee8becb90ed6f2159ce0d6e3fae91f807b33262cbaf3caf323a788e22f5e70add4c3b4ed4592746c46e262747bc7e5eb435cd1b773b5e983f620eaf8d0c2bd4335eb4c0a2d79d37b14648682c006bada093446613e835ec1950bb2b33fe1dddf831652100ff4df4d80b3f8d0d023f183b41f3129432da6d15964e009f2d6c1e7539809fb2e41a5cd52ba476b90c75801b4c3a4d3c55119004bc2ae507b47e87fd040b30c2c196e87cffaeec7ff90208e0e3b8b726fd4357e2acb4f91f1aa63a9fa6864319960dad112713e0792943311fc803beba7411ed857d3c7168d322f96ef39ac5a6095b91d3ffb466fc2d20c310a59efc44254816d3a7f822524c7c15ee83d3e278bd6abbe1e6a6dbb4812ddc3d8ecafb7e71ac8a00cd8ff69be58ca8b91f032583d01d759171ff375a5708b0ebf5b39b185d8e4138e413ad4294822213f16d3b477bf4ccf4fcdc8a7700bdf046ebe719a49e4a58ab90ff6182a3f42f1916722e5ec32ea3af8e4837f5d4b17aa2f5522e41f1a645e8fe89a0d29e9307e159ddb888e0af7c4f4cecb7d2de36f21e2245446c2b0c4455ef0f7cf1028010307e56d29e7c14dee3e0ca976cace52dbea990a2f06cb5170ce7c6d4851c82ca22f658a8a089fc0e40612a404db42d66beb91e4b1d1d73dd093f5fbd880332dd6680bcb42ab2318d5ebd84a96b090882c12417c406a94f54b47deb961de1413db3a1d48493f91c7df7ecf50e244ee421aefbc3d726dd5e382b7ebcbd1398656f15698cf1503530623220121f786a3d24a3cb7f6f51f435d35eb14a9fd56c0931bbc2366b6a739b8a54d25589e56edb0e91688d6187c5274fe56b0a065d04b48e27749ae3c790713a84270b5f780c1da251c6a95ec101176ca826a1504ddf561586418bf241133b616638d51e558848584c90d4d16d4df3d95cd5e02a407ca5f3005cffc8eeb6c420ceed63b39c731876a54ac188e4172516447944ab9abc5a233b36214b82f01372da9dd9098d9f6f5e4815e4334e20e0ef042286121e60fd7cb6d92b5c59f2540cb6f75dacef8c60f6e2750c8d8d8409fe6f53d246b2375ced6a3b71394b30ee122364a03e51b0229c09dc475580183d21addaec99793d42f72dd5b02a0de3f0b32822f5ffd2d4f0283b67780103bd95db3f8431b13d25088310e01b3a93f95de94d8d04495518de0a5fca039efa7a425941906c4f4addaa9ce2c693a9fe50a63614b398dfbb45e6a665a17e0e60750ebfa547c0143b162fc838ac758a5c19fbfa206f216c0c3e29b70a1bb042326b8baaac9bf56117b245142edbd0614561b0565084cd20d55dab14122a07267c6e895736074bef36d60ca14248183d18cd0acd8cb38f763eebd443540bbe90b82e0416c2b078c38daa7aabd27b11de5e45da3393455e4ff97de9b6673b1d80503e466d428c561e9957cd609c73e37516db3e30e6ba9c72deccc9d66041dbefa40aaffea13eda163daabc879287f64ac4cb907271b1f33a649bf57187021c91630fb82657659381bae1570d307ad76cb3e8a8bbcbf2087bcf7207f179b620e1b6b8bf7e3238bdaef34ecc5d9f71aab1d9f9b27a844f519859661965dc47439e81b0b9390756e20426d78f9242e42f69fc23dc384c67723b758a062ce3736f68d1290f682a6b22fdfbbfa8264fbc5ee656f2f9bf479fd6a035662bb81a483f2e037671de55fe409785cca4f9d23e748bdf6d85e3761a62c2d999474c598e15fe8a2b8cb33a136267a915a9008b16f2bf493dc91ce2313e5ec54b647c7611b725ab5e41fef220703b388b236c4364fb8ad7e658c4ed4d5ee048f5667f463e1a596f90da8875fc7624fbf09ad6c1ef949ec77ee333c7173d09b25f7213f3605f7e226be47731f665f2141014d826734121aa82f1f5f4061169b8cf06cab8b167021da95e3e8b99a849bf60b88d452db3f93f64aa55db6cdc210b076ac9eb798a34dbd4f99da81fd154c6a57124166251e02d93093c76fa47a29cce4ea1053f6b0884bff175a352d173fd47ac32b552eab64b2d2ee298030bb82293010aece401b09d6d99eea9577f2f752cc2cbf39e3fe3b1934eb9b9a7529d16f43ccaf22b6d944640f40b567d7e9f63a88b678b30e0a91d0ce1265a97ace3dd4e1903d61762d29ea008ff4cba43be9b76e6a43128cd6bfe8e9aae2630506aaa00183502b4bf6f3a7dbaef4710e5f5b468e4c5c10eb1bc4855ee334d831e09591ab583e6bb2d57dbdedef97b848acb39e9baf24ab7f0d2b8e9c917c1a784cfc38f92717a838af9420ffcff38fa35259c2389260e91e49dc09acd151122b8c5c93f13e585e8398139acbf903f619076a8c4dc585318a63a09905cbc27084d7dd52af70561c96226168d3899d8cc3955e77610b49f2936ae269e5950ad7479de2ccea2832f85e97d50b667d5fd5865bceb8719e2f00e68236a43f3be6ba2ba6e4f3bbc8966760f390079215fa88d77a374d0ba661d1c499408dacb624f43e6647dd3597a6259454cdc5f88a6f78875000e83c98fa45dbc65692798efa94f7b13eabf7525f9073f0a6fea763397c5e2a65d630f118ac90b56630429eee3f4e7b0272420d1401945d6b8d9b58164c4fedf2ac46ecbc4161715a401659b025cedf169b2cdd02a5d38ae038e54c0f1dd3c13f3b484bdd35dde4c8d6aad1b4f3e239c4911e00ea19d10d4da24b2b2381cd17c9734b4d851e46e771903d9d11c4f7cf35408f4d5b504c8390492aa76ad660cd0c69237c91a5ce57d6ccc39c7857034d6a066f494554cea13325bd18cdcf2bfcb532797401362d664ddbb1c93cd9ce54baf7646a549f784fb0044fc588ad99d7467c6c6c7e3edb7b86190a7b8443fc640a21cad7e71a9a108252d6d7d4467c50d0642c0d40a25df2c212a31c3c2221bd3c5f85bb7e3ebec78b846178c6deb560d1784a9784d89718189c99df83289a7e3e2d565c2a8d2f516dac5239c950bbb9f756572f1591c51db67f8ed8d4a09bd8231fa7ab8bd4e8f86ab6d51bb828a0f3e517338ee31a13011d9418f9175f651989405ee506ec8ebdedf25a88f268acf539f951a8791deb09fc118c96d3922efc36eeda9378b4744e80e849ba91f4b2d063b7ca73014d3f761e1343dd58a36b970415dffea478e64a8743b965ab1d59cc5c854c0c4da496bd2774f73ffd9a513fd4a096c139e750a7af99e1de7c9a2f81c5b6efc17c6d9b94c0b8dc0c0e27091034506d4740353f7617218f641536bc204d57976db138970e583a2b3caa16f4e459aa1bb88e71f850ee63154b4d8a7641642b78031a0178baced0a242eb18f0eeab6dd51aa430df2a2fc1bc90645e454182629255b8ce37bb5a1c2131da074ddd5bb149888868d6f4128a5e0bb5634379046aaacfd61c5b74cf77dfb472d221e6202ee7c7af647e2c85834700a1c6f7ba1b820bf1262803ac1d6b4524a8f4da156d9f421901f0839873bce60f2f0838801163e11e2003c2e951e95497a2af3c29e2a3174ede1489dad01a30f84a0248740dfbd146330f08f64fac12647a2fd1afe787c270615f0652665e3e2844b3ebb619084f7b6d363388c0a9482c5c3c6f73a13cd949febfd33733e66a2d94e492e2925ef41c9a803deea7ba06565128d8fa9097bed15be723cf571b211b99f1235a1557f4341639d2711ec907368159ab06d0592ad815f9daefc50db7b59f1860ae006fd60faa4fecafc91e1ae3c10135eb25ee8c114b85cf483c7708ce6b58b8dea6c44f9df3fb9e43bd41c1a0b72991860216645f10e1e7af3a43a25352fec0fa431e8ebedadae20d45dfb1dacabdabd632593b960859cf407d16d933f5fd1ab784e1ff7a72fa9891389880aff09a3fd99e29e529c3dcf4938fdf18a88c9e24f135690a24c2d86e0c9c0babbc1e3fc40b9f386e47e245e4571ace5b0ba83bd0447965cbba9bf0a45cfec616205ee238fdadf66cc797891930f553eb6c0760ed261922fb85b464597a617c3f0acbaa6b4041063a42fa116e636e50b354d7c101fee37e828b7962be3f547504ff7c0514de0b5226ad2770920cc35ed31a3c83f08d8f702483720246a6badcd3227023b9031779e56d9ed1ba3e673ef615cf01d8de1ed4c5fc88cba25d0f08eda6e053b638b75572d30c358698d73bcd6554742e2e21f7cd1976c17f36ef738504ec56a9d6f6dbc04d63a51bd4364d86b2f2aee5e794c1c35abb18c329e0ca2de36a84ebe0802c1efab1ed032d38316d9ad29a27825cbd0f6e5a4b8d22fd526dd8912357e7c966de6d8d1e0d151cf184c8c0dc730981e84845769c9fff354e8b2ce8ac3db7c02c65c649c8497234103a7adc49fac687a01ca4bfc04b9c6cae62a1babacf9c3e25a0b53240119143c3d7063fb70c870817499ea2ed3246ed2abea41bc31497014a5bc18a1555c08563def09be87d009de0686356fd4d2ec5d8c429cc0f3284575636e400d9a1cfeee6a075f9efc83db2157f447577e127459fe66a435c06e1958455362ba118a435cfbd36da80c8e3215c2cef00b4b51807e9e0895abf4045ccc77b3c220333e85c4c72eb3da71591f3d2f3f9d99fc5e7e07ac40e31573a4e7ffe0c4358d27d3c26cd8b4fc9b30ef26675f5496e81381767723458ba063f747b788d1e9ba96617c2569cc4947cab6303ad17dd83a0bc1147a3229b2b155efaa9b077661c97bd689714d89048ad2cb006e44a25ad1bef5d53b704f99bfadedbea85b2708fbe1cb991325d29256df872240419e8e0f5a8eea8e3ea0f21c9ae5bc53996c816955b765d14da16ce48302216b6469edb4790ca2fcd0325e46ca50d7f622298d51752237ab9d09120ed5a1f07c87c3d13be738f5357f27e02192a3b5f1f488e8ee43db834653492beb9b142546c4e03d82579d97cc8c400b9eeeb018c47749e7c052da3ede683a16951d9cf58e9d9b588a7518cc3aae5bdf6a0303c2dc33b8ab78566a4b6fd75ee30bb03f55f75789027b74da092ce92d2c53c73bc6170e22b846c84edd8d38dd84ef0a0a19e06ad0abc924136a6a650bbde87cf1231b2725ee23b7007a2897714062fc9a61116d6ab25953764ffcef40555c1c159d6219dcf13c290f7b5553504def1396445d904b7a0b5a1d13729c559c14396d5589beb1c51f93066532dc243bd9ee74faaad1bcbb34f4e0e04bb15708f2631dd5fc717c76eb371601c92afc8d8e423820e97c38f10d326a3f552b0dd57680ce2c3ed5f2e5b85259ed2ac312047802016454946d4d82732a8415b26276caf3084c893b5efe349be8751821a7f89230ff3578de930a5ab5c9844c369af099c372a32c3f2c7c1998d9de93b4509dc962f01c66f085ea39eb4ef24704d26737c3c6a7003f3dd54f6fbf99c1d04a2373a49247a500d00547d36d86876b5d75642a305046508c0cdcdd246cac013feb48688bbf90f606e18252980f8eb501f65a96b69cd1be7298b121cc68b310d26c54d5771573cff10cfb167ffa6cab7f21c04bc6af7426b9663052fe51ee75201c8257b9cc59e6f013639ebe0c53dd2c1842cff86105b56c02957814f79ddb792cabceb369a4c055e2276f838b6a952a59ed3861d767c8caf40c9eaff6af3395f4c666581f767bd6f3f565f9eb90739412bb5996e381e7359865b9e13c57e82e597c8e2e19ceae41d8f2f74c8427dee027de59aa3958f03f0efd1bf5ee2f579d9a858bf944efeb7b1f4f5fd3ce935adcb2a78d26be2db974569de256e05e57b118aac195d6fa3fe86c38aeb064f7adbc6b80fa550f07e33abb2cef0c4c1ec08cac20872dd284594879928258bf402c3c9265b073fdbfa125c40404f5e57e8fd199c0151b18fcebb9f305cb74ba1ee7002d9422cf5e5541bb53d1d1baf3bd25e63eb087663594235469f8da182af48655e47380f113777872022f3c81b0bfe072e4672f78fa4eca875a0cd6aaead2c67237ceea208d94bd22344999392b5a2ceaea1d845038ac125e01091a6656257171413e3540dc1ad08a1d163ce39b8028ed6de5967449b79b23e24d54ac29083290da58b8957dea1c549fecadebbfe72855867edffd611c3afd64528d5984f7796cf3b99874cb7683e889dbd9a58a09ca64e56484ca19560b1c8859e820722adfbf6ce1cd93aa27440f0469ae6a37dcda0fd3f424770125271377f77c7e98bb405d9920fa71baf8405d4db015e4e87aae2d18038aa88f9e16246d1707aec9d2e28f465f0e1e90129826f7ab2deef818ef40fd6f8963dc08c08791c0bab642d8edcd8223585441502109fa77457f4acf764998bcd3a948f49bb6d33652eaabc87cb40833c22e366e28aa35404363516e4cfc5d21bbf09868195ca074994166a2ca2ce78a20daed208b75849c017ca9811eaf449a87e77133bcb65c5efa5bdf93d82c23773c6605936907b0a7eda788455da3eb0777a4307aabdbc3831a839c8136c4ffbefb98c3b4d6bcee26889913018f2ff1d0fad146d42db8d3c7db5c1f97901bafdad350a4f4f7e6dfc6d2179bf1dc60b7493d3eb138d94eda087ec8c47002c7b4af717b3687c162fc2997cb5f9290eaf25d20a6b498065a31dcd166a4eeb15e303434827d1ef8ec35199235400b76fcf0327c88848d9f7b7f4bc83162e00342f3a8043067116797c368b8a9518ad55d6cc3e37947e5b4f3ac402fbc18a74ffa7b6ba0a3cf4b7b08e026f8c2875e4065dafb0fa26f835e5240d8b397470df0b2bba52c92bf389935ba23fdba1bd7b1f0f3fc68f8b963b56387c756071b554c8807226f11435fdf65ee7cc9891faacf47c83bb427c7fe8f4b0a354089363207ee87315c9ee14b2191cf95c5577a2ce2b16e3a23c6770990f33c0adbd7f0d863925ef10639be8d178c58f9c1b0cf66b62ab4e483aa6804bff3ba2c196a76ae7e2b8965203c2b7ec59cda819fd5acd370c6d0a2af4e99eb357729264f3d9ea2d7a16bdf32166051c4c24f2d94d2ceb5ac5f957bf5cc7f933e7e2442c7c430e159b415c677963dc9c185feb17b121baeea77c955e494eafd5d77c8bdb10aad330b62ab9caa1d702debb1d18571662feadf1b1777118dd5d52e7717ba5f27d68de271731452199ca9bea8dfe70652379e82253443ae8b37c76a1c3d3aee4bfb09e06aa2970dfa8a5329703c4b9734a41779d673705ebc6f1ebaf3287c55477c1db22f808a9eb088a7c865a71e3bf4b81ddefed63dbab20fef06a632ae60b3b851a3327f6c1fe4777900b5e8dea7c4e0fcda67e1fdb7980ec9b981869daa4ae20dbbb387838bdc143813a632172a4a03b24c4e99bea264903ec45124ced55a7588811f3fbac264f9b56ff5cab235dfa1a7d163e51958b4383f7d1f083909068e5546dadb3013169937e889e30335f4d597b7cca6203c736994d9525d1871e381c2ccffe0d8375e5ea603de98a89b6ff05ea6c755d10cfa5ab953df3ab24950f7c8b0a4ecc2a945a8bff49f3e87d917503762fd32c05f85d0a92d5813a0756a4ea9263ff8fea96239d065641edc53150888aabd021902bc9c9e1c7a0ac0c05908381349170bc40f5ac3d009af48e62dcf7988ad0b9789bab9f45d9cdb64e88bbac9862ed6ce2789d19ad9a2db6ce53a3f19b1e11a3c63e02476ad77fec51c2898a6a20dfc050d7afbbed584b90d681866d7335f2c79f7656e30abf41929304c40a64041d0ac308c80e50c9539a2df04fca3679e73c2b989b407b797780aa8397c72c255c928fbf657a6ba230fb6fbdbca76d45c061ca71e186f5e12184b54fd3222169dc97941d04cbc786385f3017d84211a4181fb1e0511f80bc127fc4142363674eb1b5cc8d9c3eed79db5f1030eb51a51268bd7b412c6b21252d539d33291af48e786cbb1b274beb4b105312d9bfd5f333e74b1c3985d6f65c1b5ffc5c0333ee244644e7c341b1844514afe846644dbffe77123c2d53a9cac6e72d8a508d06d6d8c75c907c084eb21bb51e9c4cce09688006d865f88a1f92759f1b5a531086c53922750e8da789d537863a1e25baf7e1f30eb085f4a5dfc31679fe880cb0f15c7e2391b2267907c77cdac9b807abb6b394a22bf5978e0592085923db1751be6866d605c929fb85fa8ed180b72c08e60495fee06456f24bb7b95cb253d294344f7f369f09a09437ab6a71875d2847405a550d5ffa1aded4ea51001c75e73f33cac1306709cd7034cd809ace4815d311a8b7da873dd3cbb94ef13aa4ad4f6e63dd90387b4ca1b235b12340512db7591705586617d1631908922d256569e47324a38ae86ea5ce0b4d5d8e6ee4bf1b19b524a51b1e88c26ceb5b9bf337baefb2961e31349d4fa8ed7db331573c0edc2ea8c4e122d8639143ca1eee3fe2d51090b967633a0fdebac9ebf5dd5d8373ed277ac72edc72149c12cd8c5f74cddf3522bf87463a36a13b0359304bddaa7350fa7f734b95714e463a0a0674398adb789ea802fbb40da956d86f5ece06343e4f02ac235146fd352f0fbd4756d5c07a0aeffdd7177186f69607f99d18b38e056f85adaf4e69b7a6c1420c6a6bb6b246a1c5ba947dd4d98d297d369458600ff769e941b58e0ae80c0b322efa3bb994fd797b7906822a800f718c50088d25cd26fbef8feb10457afd7bf6f07a8bd7b6138674c2e9b16f1c48ab31ae2213215e0d00ed3fda447bf95322c1c059662b0be59d5b9b7ed04ecc9466a293180e762b7fed79877ea5065b1efb94251c91fee79f5231e84ca08697e3b1e02e0e2a17e2889f79faae993991657c467129fbb74de7b3d282028b8dee665304d033fef6bc0f00bd5fa68f0a4793e3578b44b4ca5803a311b4627e6650a2ec7adb54dfb484c141181e9bbc2f09543929b695523373e9e4e09a3d9f8e2e4d0923a488fcb584ed821e97da5eb6fee6a652c50e258c722e52dfb53ff938a1efe1a61ee22ed0629023ab13e9c8c7682fcfdc47da7901e284fdbee35b92df381b7d1a4e2ec0f55f95d39a9403d180895e170b1d371a96918b111c27a3b56016e247f68c1f43388c6fe295568d9fa813fb45ad001ccb28c3a45e8100631428299d3dfa682354bd4c02b203a264a0c8da1588e0a8f021bad50a9b77439891032db57b2244190047855f6f1a1fc1bad6e4513982241bb5ac88a7a8df3734c75ff3118d68a70bb955b592bc26e9fdfd9b578f306fc8146393281b8e509d219528eab6f00be9d09e9c7f0b908920241fb741e773c941158388d5a43c266366b882018b9714ef00b78bf586b4f92e6554de018b6d8e9e64fc7c98986146d6177ab9a8a0298b9b87c200cac07dfa688a0f453dc8f3ee374a52816fc1ff5b90b262ea677d8d7dccf4f15c12e8790a67399d40f80306e29acc7fdeca117652335c97394affde2a57a8d61f07f4f342513b6f2d1d120ddba99a0da918da84f0c29b1ce4e35ff32505655e4f64fddf9d6088cbc461144f8684449303fdc3e768d1423b3a255c980053ef820acd21e745e84d85b63f8fc2281b0267b82e711e7f76fa91ba13e3d1c94c503b406e423762a59a848af9ae627cf47f43860e141ab5728befcca3ac0eecdf0988f285bb8c40941a12b5b99e0a9d25517005740ef56aab5e48055a8d224749859d31226c0f508cc62a7b09234cb3d4da14b6f538d5165868f2f5bb9d45e674b19440437a8ee69f36b4a7339f1eece485d20cdf00d229d7e2815dd96d5074cbbae1d18abbeae709291113e118e82c66f00e44deb7d4c6ebf883323f15cae462d5ba84a28c2d9d802d7f54ffbd67c4f1b28c8e95c4542df00417a1b9cb77afa68949859b38f51cfab9735b43d1dcf47623f52da591d37db2eb23bfb7e3cd5ea2505d9084ef2d545b8c9aa226abbbd36da03b7a6810288123b4c54336b186c5b3206edf63cf2af2d0a404f9a1b61534af0fc54a32d4579ef0a4ecd2b8b5f2eb7632eba4cd5a4535e04dfdda8ac1387232869d605f36cb88795258f1874cb58693b5c1ba37139ce06891def929f121b239dd7d714043c47b6fa5057b6283cb1a4473bd17c40123a8b35dfd1a4b2af1d665537bed7f23b67b8acd57f0644c52a3f0b1bd615b004296192246d3f3b726e2e89197252ab2482936b61440af909d65c9bd6f571a57f63414ec5e1f691e65c6495f396206317dcab3565f3db407ea6344c4f804b71537f44e712e914f9803ace3863e9245ecc6a1b92117449f3405edf7493dd484e928db38cfe2becdd4e2a0035e3948808212e4fffc6956704a3b06d1500cdced3cee3bd65dbbdbb0cd2ae691a3dda3536bc3eb44032537ccec6c2232d6bc68d2878db71750a547742aef4ba6c5f352683b1776fe22ae6bb003c818a9d69f55a8f23d68bad4bebd9ffb7cf47747183c2e4f06d968bf318da769e8c7862e8c71af01424c17e75efcc7776fc4ce636265ac29a354137599d1f972e201c20de6c34db9d4ab719742b60bc6ec5c3c0263b9c158ec0ef16d0a74d48daed9c0a5836acfe0b12f04a02663bfecb2a0e6cf6ceabc9b6bec8402667a3798f724a90bd7fcbbfd212764c1b70d226280a2dcf891f13d302bfb6d58190aa12d435074722476c737a9688cab88ac35efd6b7c2aa136c073c06cef98ccb47d8734614e1f4f2a6bf72d056d7b72be0abceee5afd7cdf67a1d20bd187e346c9edbc8840031d67289d9a2851f5e5a0dae78e07f088febba1bf5da51cf51384e4d3e3511cfefa6eb9cdbd2dbfb70782e9b433d21a4ea6f0e5bca92603672970cc6bd946f1e463ee1c360aa0897e1f471a5e1d885ed3e42542b8660bda6ee0c3e0e7babdfdb5da930f6cc5d92d88540edc14dd735ab4a724c6f2fb69df35d27348edfb14267cf1798d923d7885d2fb81951f6924656953324cb50a6483f4926744b11ae7d2d6373961980befa5301ab8a3d579a863e261df6f643e68392ac8e87d3e90c5db70333ac52224933f7ebdb8090957798d7e536dc935a739b033612095d3a575926fb1736632565c334acad487a94dbf888fd2d88d5a9d2155850a03d2d6dcd39096ae916e35d143f041f49d3fadb493ab8d253c4f4367510081a21c367af2f28636478e8cff42e16abbece9d7feda4d2884d77bcb136eadbc4eb135feb79431b6ff42c41effd2f38e3845a14614ce0a41d448a7141ce961f0248e5bc281b5032debfdc3cf49743440eb76145956de80653f69dc21e6f142f4d4af04c0faed09f5b77049d65560e6d7caceacc99181e4c319943bd54a9c954054a8e9a8b1af83aadb3a3ea00057e24128d85e52d0f3fcd29a2872639042a981bfcd82be4b3c633dcffbd02c5ba50a5aeed6595d05c59b996e5347f4b1323445570b7c5804f71e85e710f50720cb0208b0fa1b51c321299f3b15af2d027b4b9c0c3150c521b24ebd1d8e7e33991ca1043c4d055689fe4bc76d5b96614000df5bb8203454107245681d24f0dffc7a86026ba0edd6421f3da5f99ea67377a79d547f647db2f4f62cba97d57d77aaba8f4c9d5e9fe997d6a65a5cf2a127a5d3b9b0538a3dbbe83ed3449aabab3a745159a5e06a8cc58e01454ce3503262928b6aa1160a85b74fa7ccd9187dd1cdf92e780bfa5b16cf7b77e088018e0a50b78f51e92af5c0e403cf1c5b614a994b8c0d714f6be66f42e492ca3b36b919055501354cc123360e4f5d0bee23209e93998cecbddae4399cfed0da7a9ba2da19168a244dd5f4ce164e35a6d7eec628e6f16ed56d8480d880181aca5e8746f19da0d8763b7debdf0fca7dee6955d5764d14b568b838b17185386dce85568305c8a5dcfe135daaebd10de0c8258eee04a6123e091fe14f2dd6907f746da3b0c125753a46c440e84d82ffda11dbccc5260ca3f59b9bbe444c90029ce3926790f61403a4f79e6b8213f7204556f57f782aeac81f6129481cb6969ee610bc7a05e49fb6e9daf6eebc3576dbd537f02f89409fa0160255a0bc8a76287204e9f0b5d5b6643db53e5b1ee964aa21fce680dc052fb8c99a7099ae928163697336ec94eac3a2d7e93f1b876f7a9a48194fb9b6beab82b007d6e0e62627092c8baed61b7d330b355309749001a9d2de068872876089636bd3d96302b3738d2dbb36b43d71571e3bd0456f8b91d8e6b306b2968a3dd617a5b485199e3a089f1d0004ddc1a441802c4f79d3f62f61d1b7d3125f4282c4d116088b31cd98f0aec0a94c135c3a7f727857d0ca6a876381ec4728949055c0e2f30af919e58208cf310542f5abca3a91af093d71df72bbb8b470d34918328c86e01f4ea7d4d69d14b40761145fb8efc7cfd3d698ab0385057be9eeba2491c1212f9adc0c1b8ced147553b9f889a823e4ee5c5e8204de7b692e0e88de6b57cba9678b782b6e6eac36b458fd82013913f792e2115cb2852a97085b294d933565aa4f6cbcc8e46a610b56840637e11551401af34a975b2002539a9dd5bea7c8b31cb2055428e28a34f02bc82d3e816b7c11bbceefc255402e641c1dc46dd805a602f93663a85c260b0e044e127943cf9bc772e96bf536e88fe2a22125eb7f77875f4c1a892b7bc3d045e4d1129ae0e454fa8d0b4fd181dc8b87b7ed6d729f6cc3d81e84a2763fed72b7908b9f97376b4ddee896abc519fd3b0b828c5b189ff620a017ed5f3efe33a2eab7b17f7c34b1048f2c7c3d1ff2a5a2bb852c3884077b08548a271ecbf3fce20a2ebc819793091507dba17cf1add8183b22abd0c29e504f3fd9ec0fcefed44383012d2f7f61e46bb2da08fa52e18a4fc40b89d844a033334ff0a9c737004a107ee1e9a5a660cea2d57ea38f3334af42cf642a4260aa0d6499d9245447519a8d0d3dd9da250dd6dd9fd9b0c3d9914b015ae134be51f220cd43324f677bf42d39aa3526e5791c26f303313c0c7e09531c8ac9988c244a7f122faa39d11375aef1d15558021907663795c6b9ef1dd913c2d525b8ad1c3013a017c0b801f976465748d4ba217882c011ee38593972df544b8e91ecd0b40b37adaa061c7d271868408b61f6bd4e7ecefa52d776f0f4464e099eec673360411b8f67f18525fb99cba8e7aacc5ae7776901c42217f7204790a2840a5d9708a2705bb0db211c9cecc758f73d9a2f4d6734beeec3fea0bc1c68c1e4f8b4fdd4093526005db97c1e53402331d4b2c4337cc33273612c6cba278c7c6a1e0dda21c8026a40d11697c6eb6134599e112251a46568fa92a9159b22e68446c59960f4fab050bf26f13b054d76dbafff9fb49d906d073568edaca77b8a8a1c7f0209e15298dabea37014582376bd8ebd9c5aa23dc4a631c42df847f0a06f2cdc020cc196993d13716accab2fad900e1373141b46581ef71a8779db59c38e7f45dd77baddca3f1304cc5ac708dcb0ecf1f4f0ee955db334f6b2304d532ce8a0e98b7eb43a2738b058eb2304361a09ba506487e947275878ffa46546e50f07d32acb47b12a08fe32cd1ddd4e8fefa0bb60b99189436101afe80da20579c84938f7000e37a932eb4b04e7a7ff8a0040e91ccd9ca0c09dd67e4f8e2aa42b497430e078ea8a5fbf762a164627463d1ddf36d284034163a7ef79fce4d97a79b31635f43cb87cb47a8164a1a112ce566627dc2571b6434b73a1dfe8cfc0a77de66112d69f89ae0739a6c33bd4017a466d0913719631942b40b9d7156faf68f4138f63d39b7e1fea110bcd0dccbfa9a17081a14d353ec13c779e7d2f8d6dfb9261d0b4671f6e6649c83eaaad688d24253bbb418ea16fb4a8764eebe7263c6a83a0e2c732c9f7bf2efd9d4583d18d45e5aa69392fb37d6e80c5638a7d17cc89ed23ba7e761e2684a9712826e8fa3c7a03fe3dd1af44f09af18ecc06d4f044d65ecb893c11dbacfc21065a225b735b2c0bb7b03ff75fb851e52385c557cc4f2183b652752e7500479200f9afb14497f42191653c87fd25ca8fc9420baf289afb203ee92d267d3e2eefeeaa3f402c8639497190cca1223aee46c80eaaefdc7f8035875df265ca2b025f3a2e6bc97daa35d3ab1043f60396f59f7f2a084ebf4d9f46d068c3218700333e8c895594014abc33e07ab3b6a27e2383f0363d7b76ee107c6ea22800be0a7adb36035e0be20c1879d97864b71b1601f37c31717acc8ae1456ee404d46a04a25410fa3833cb5b880f956c1bd0d1d1d790a93c649f5070949e777ae2ab80341de7f0039ac10965ba77f2010046b1a898683e6f8e6d058a6cc415f0b7d86ca92ee3f343c22e3f54484f7ba05957d8d75208560f92ee1a77a71217a27f5675e568953aa4a48cfb8f5cab2843f6084478da4d74bd277ded979f9c03d18f194c7267b1a446a50a753ce147c84aa68a5a87bf0b2e9d74a45ae975d96e8fd3796783c72ff3253cd8fcfa4ff554001b59d020ab26b7608815f129aededd10ac633346af8ce492421c2803ecaf0f0abaff7e75fae6b81fd59b66fda652fbd83c8a0069edb19ebd9bc69a0bcf4af750a4d9492e79ae59e78d4c3c7c97eac6bd9fd7c1d86b119df2cd5ee422fa97147821c459a5569696430330ee7465320c6f5f0577174e6da24ac24e9ebf00af4e49552a8738d783a6cefe6c14d269527aaacf66a8b032514a63f606295fdb784578dfacb4725401905c25d2cc97b6537c3edd6b344188be502484a7551240d5844288379252d7728245eba8ea82f4e8844f943aa651c90ca8064b2c43ce78b52cd4361ca256c8cb46029c9c2d1da54d2f0c325772df73740e96dc1a4ac6d744cb8d9e4ee5b7a753f0dd56e98f646e36159b8106c7720bf456c86c31721f7ff2fdf6fc85210ce7b291fd18ab4cb650dbacffd6c51d950840bc05d92e8c49bd40290c9eb18c2b4354d55b0ecaaa3dc0527c25499efc7966959f3aca64256b29603fd8a8d33a34481990881a02e67286f717349da32e30f8288e18e4d59cd3aaeaeb58d0b117805ee7d4bb25b7d19887a6be23bfcea6829888f25d02d81f3af196f652c2f38203726f795bfbad3c4ef74a6ff37ae56cdf95c64ba09a65889b84612f944250feffe1201a1206196aea34344a5122cdd57dabd6026c33a5f0c5c832f11f3b353500cf8951a5896b075dc0f303b44231db00</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css"><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>EOSIO</category>
      </categories>
      <tags>
        <tag>EOSIO</tag>
        <tag>数据流</tag>
        <tag>编译器</tag>
        <tag>漏洞检测</tag>
        <tag>静态分析</tag>
        <tag>Datalog</tag>
        <tag>CFG</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>docker高级篇学习笔记</title>
    <url>/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr>
<span id="more"></span>

<h3 id="Docker-高级篇"><a href="#Docker-高级篇" class="headerlink" title="Docker 高级篇"></a>Docker 高级篇</h3><h3 id="一、Docker复杂安装"><a href="#一、Docker复杂安装" class="headerlink" title="一、Docker复杂安装"></a>一、Docker复杂安装</h3><h4 id="1-1-安装mysql主从复制"><a href="#1-1-安装mysql主从复制" class="headerlink" title="1.1 安装mysql主从复制"></a>1.1 安装mysql主从复制</h4><h5 id="1-1-1-主从复制原理"><a href="#1-1-1-主从复制原理" class="headerlink" title="1.1.1 主从复制原理"></a>1.1.1 主从复制原理</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">默认你已经了解</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-主从搭建步骤"><a href="#1-1-2-主从搭建步骤" class="headerlink" title="1.1.2 主从搭建步骤"></a>1.1.2 主从搭建步骤</h5><blockquote>
<p>1、新建主服务器容器实例3307</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -p 3307:3306 --name mysql-master \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /mydata/mysql-master/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/mysql \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /mydata/mysql-master/data:/var/lib/mysql \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /mydata/mysql-master/conf:/etc/mysql \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-e MYSQL_ROOT_PASSWORD=root  \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-d mysql:5.7</span> </span><br></pre></td></tr></table></figure>

<p>2、进入/mydata/mysql-master/conf目录下新建my.cnf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">[mysqld]</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置server_id，同一局域网中需要唯一</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">server_id=101</span>  </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 指定不需要同步的数据库名称</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">binlog-ignore-db=mysql</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 开启二进制日志功能</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">log-bin=mall-mysql-bin</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置二进制日志使用内存大小（事务）</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">binlog_cache_size=1M</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置使用的二进制日志格式（mixed,statement,row）</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">binlog_format=mixed</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">expire_logs_days=7</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">slave_skip_errors=1062</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置utf8</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">collation_server = utf8_general_ci</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置server字符集</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">character_set_server = utf8</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[client]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">default_character_set=utf8</span> </span><br></pre></td></tr></table></figure>

<p>3、修改完配置后重启master实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker restart mysql-master</span></span><br></pre></td></tr></table></figure>

<p>4、进入mysql-master容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker <span class="built_in">exec</span> -it mysql-master /bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mysql -uroot -proot</span></span><br></pre></td></tr></table></figure>

<p>5、maser容器实例内创建数据同步用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 创建同步用户</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">CREATE USER <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 同步用户授权</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<p>6、新建从服务容器实例3308</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -p 3308:3306 --name mysql-slave \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /mydata/mysql-slave/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/mysql \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /mydata/mysql-slave/data:/var/lib/mysql \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /mydata/mysql-slave/conf:/etc/mysql \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-e MYSQL_ROOT_PASSWORD=root  \ </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-d mysql:5.7</span> </span><br></pre></td></tr></table></figure>

<p>7、进入/mydata/mysql-slave/conf目录下新建my.cnf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 添加配置文件</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[mysqld]</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置server_id，同一局域网中需要唯一</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">server_id=102</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 指定不需要同步的数据库名称</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">binlog-ignore-db=mysql</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">log-bin=mall-mysql-slave1-bin</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置二进制日志使用内存大小（事务）</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">binlog_cache_size=1M</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置使用的二进制日志格式（mixed,statement,row）</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">binlog_format=mixed</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">expire_logs_days=7</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">slave_skip_errors=1062</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## relay_log配置中继日志</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">relay_log=mall-mysql-relay-bin</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">log_slave_updates=1</span>   </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## slave设置为只读（具有super权限的用户除外）</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">read_only=1</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置utf8</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">collation_server = utf8_general_ci</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment">## 设置server字符集</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">character_set_server = utf8</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[client]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">default_character_set=utf8</span> </span><br></pre></td></tr></table></figure>

<p>8、修改完配置后重启slave实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker restart mysql-slave</span></span><br></pre></td></tr></table></figure>

<p>9、在主数据库中查看主从同步状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">show master status;</span></span><br></pre></td></tr></table></figure>

<p>10、进入mysql-slave容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker <span class="built_in">exec</span> -it mysql-slave /bin/bash</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mysql -uroot -proot</span></span><br></pre></td></tr></table></figure>

<p>11、在从数据库中配置主从复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">change master to master_host=<span class="string">&#x27;宿主机ip&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;123456&#x27;</span>, master_port=3307, master_log_file=<span class="string">&#x27;mall-mysql-bin.000001&#x27;</span>, master_log_pos=617, master_connect_retry=30;</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" width="1">

<p>12、在从数据库中查看主从同步状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">show slave status\G;</span></span><br></pre></td></tr></table></figure>

<p>13、在从数据库中开启主从同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">start slave;</span></span><br></pre></td></tr></table></figure>

<p>14、查看从数据库状态发现已经同步</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" width="2">

<p>15、主从复制测试</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;1.主机新建数据库</span> <span class="string">---&gt;  使用数据库 ---&gt; 新建表 ---&gt;插入数据 ， ok</span></span><br><span class="line"><span class="meta">&gt;2.从机使用库</span> <span class="string">---&gt; 查看记录 ok</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="1-2-安装redis集群-大厂面试题第4季-分布式存储案例真题"><a href="#1-2-安装redis集群-大厂面试题第4季-分布式存储案例真题" class="headerlink" title="1.2 安装redis集群(大厂面试题第4季-分布式存储案例真题)"></a>1.2 安装redis集群(大厂面试题第4季-分布式存储案例真题)</h4><h5 id="1-2-1-cluster-集群-模式-docker版哈希槽分区进行亿级数据存储"><a href="#1-2-1-cluster-集群-模式-docker版哈希槽分区进行亿级数据存储" class="headerlink" title="1.2.1 cluster(集群)模式-docker版哈希槽分区进行亿级数据存储"></a>1.2.1 cluster(集群)模式-docker版哈希槽分区进行亿级数据存储</h5><blockquote>
<p>一、面试题</p>
<p>问题：1~2亿条数据需要缓存，请问如何设计这个存储案例</p>
<p>回答：单机单台100%不可能，肯定是分布式存储，用redis如何落地？</p>
<p>上述问题阿里P6~P7工程案例和场景设计类必考题目，<br>一般业界有3种解决方案</p>
<ol>
<li>哈希取余分区</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">hash</span>(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">优点：</span></span><br><span class="line">简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">缺点：</span></span><br><span class="line"> 原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)/3会变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。 </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">某个redis机器宕机了，由于台数数量变化，会导致<span class="built_in">hash</span>取余全部数据重新洗牌。</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一致性哈希算法分区</li>
</ol>
<p> 1、是什么<br> 一致性Hash算法背景<br> 　一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决<br> 分布式缓存数据 变动和映射问题 ，某个机器宕机了，分母数量改变了，自然取余数不OK了。<br> 2、能干什么<br> 提出一致性Hash解决方案。目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。<br> 3、3大步骤<br> 【算法构建一致性哈希环】<br>     一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 = 2^32),这样让它逻辑上形成了一个环形空间。 </p>
<p> 它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说， 一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环 ，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间 按顺时针方向组织 ，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" width="3">

<p>【服务器IP节点映射】<br> 将集群中各个IP节点映射到环上的某一个位置。<br> 将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的 哈希函数 计算(hash(ip))，使用IP地址哈希后在环空间的位置如下：</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" width="4">

<p>【key落到服务器的落键规则】<br>   当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置， 从此位置沿环顺时针“行走” ，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。<br>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" width="5">

<p>4、优点</p>
<p>一致性哈希算法的容错性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;假设Node</span> <span class="string">C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则 受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据 ，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。 </span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" width="6">

<p>一致性哈希算法的扩展性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</span> <span class="string"></span></span><br><span class="line"><span class="meta">&gt;不会导致hash取余全部数据重新洗牌。</span> <span class="string"></span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" width="7">

<p>5、缺点</p>
<p>一致性哈希算法的数据倾斜问题</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;一致性Hash算法在服务</span> <span class="string">节点太少时 ，容易因为节点分布不均匀而造成 数据倾斜 （被缓存的对象大部分集中缓存在某一台服务器上）问题， </span></span><br><span class="line"><span class="attr">&gt;例如系统中只有两台服务器：</span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" width="8">

<p>6、小总结</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;为了在节点数目发生改变时尽可能少的迁移数据</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会</span> <span class="string">顺时针 找到临近的存储节点存放。 </span></span><br><span class="line"><span class="meta">&gt;而当有节点加入或退出时仅影响该节点在Hash环上</span> <span class="string">顺时针相邻的后续节点 。   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;优点</span> <span class="string"></span></span><br><span class="line"><span class="meta">&gt;加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;缺点</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&gt;数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</span> <span class="string"></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="3">
<li>哈希槽分区</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">为什么出现</span></span><br><span class="line"><span class="attr">一致性哈希算法的数据倾斜问题</span></span><br><span class="line"><span class="meta">哈希槽是指就是一个数组，数组[0,2^14-1]形成的hash</span> <span class="string">slot空间。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">能干什么</span></span><br><span class="line"><span class="attr">解决均匀分配的问题，在数据和节点之间有加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" width="9">

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</span> <span class="string"></span></span><br><span class="line"><span class="attr">哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">多少个hash槽 </span></span><br><span class="line"><span class="meta">一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot</span> = <span class="string">CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。 </span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="1-2-2-redis集群3主3从扩缩容配置案例"><a href="#1-2-2-redis集群3主3从扩缩容配置案例" class="headerlink" title="1.2.2 redis集群3主3从扩缩容配置案例"></a>1.2.2 redis集群3主3从扩缩容配置案例</h5><blockquote>
<p>一、关闭防火墙+启动docker后台服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">systemctl start docker</span></span><br></pre></td></tr></table></figure>

<p>二、新建6个docker容器redis实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 创建并运行docker容器实例</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 容器名字</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">--name redis-node-6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 使用宿主机的IP和端口，默认</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">--net host</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 获取宿主机root用户权限</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">--privileged=<span class="literal">true</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 容器卷，宿主机地址:docker内部地址</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-v /data/redis/share/redis-node-6:/data</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># redis镜像和版本号</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis:6.0.8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 开启redis集群</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">--cluster-enabled yes</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 开启持久化</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">--applendonly yes</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-1 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-2 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-3 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-4 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-5 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-6 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span> </span><br></pre></td></tr></table></figure>

<p>三、进入容器redis-node-1并为6台机器构建集群关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 进入容器</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker <span class="built_in">exec</span> -it redis-node-1 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>//注意，进入docker容器后才能执行一下命令，且注意自己的真实IP地址 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster create 192.168.111.147:6381 192.168.111.147:6382 192.168.111.147:6383 192.168.111.147:6384 192.168.111.147:6385 192.168.111.147:6386 --cluster-replicas 1</span> </span><br></pre></td></tr></table></figure>

<p>–cluster-replicas 1 表示为每个master创建一个slave节点 </p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" width="10">

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" class="" width="11">

<p>四、连接进入6318作为切入点，查看集群状态</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" class="" width="12">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;cluster info</span><br><span class="line"></span><br><span class="line">&gt;cluster nodes</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="1-2-3-主从容错切换迁移案例"><a href="#1-2-3-主从容错切换迁移案例" class="headerlink" title="1.2.3 主从容错切换迁移案例"></a>1.2.3 主从容错切换迁移案例</h5><blockquote>
<p>一、数据读写存储</p>
<p>启动6机构成的集群并通过exec进入</p>
<p>对6381新增两个key</p>
<p>防止路由时效加参数-c并新增连个key</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" class="" width="13">

<p>查看集群信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6381</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" class="" width="14">

<p>二、容错切换迁移</p>
<ol>
<li>主6381和从机切换，先停止主机6381</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&gt;6381主机停了，对应的真实从机上位</span></span><br><span class="line"><span class="attr">&gt;6381作为1号主机分配的从机以实际情况为准，具体是几号机器就是几号</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>再次查看集群信息</li>
</ol>
 <img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" class="" width="15">

<p> 6381宕机了，6385上位成为了新的master。 </p>
<p> 备注：本次脑图笔记6381为主下面挂从6385 。 </p>
<p> 每次案例下面挂的从机以实际情况为准，具体是几号机器就是几号 </p>
<ol start="3">
<li>先还原之前的3主3从</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 先启6381</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker start redis-node-1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 再停6385</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker stop redis-node-5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 再起6385</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker start redis-node-5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">主从机器分配情况一实际情况为准</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看集群状态</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 自己IP:6381</span><br></pre></td></tr></table></figure>

 <img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" class="" width="16">
</blockquote>
<h5 id="1-2-4-主从扩容案例"><a href="#1-2-4-主从扩容案例" class="headerlink" title="1.2.4 主从扩容案例"></a>1.2.4 主从扩容案例</h5><blockquote>
<p>一、新建6387、6388两个节点+新建后启动+查看是否8节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-7 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d --name redis-node-8 --net host --privileged=<span class="literal">true</span> -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker ps</span> </span><br></pre></td></tr></table></figure>

<p>二、进入6387容器实例内部</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker <span class="built_in">exec</span> -it redis-node-7 /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>三、将新增的6387节点(空槽号)作为master节点加入原集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">将新增的6387作为master节点加入集群</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster  add-node  自己实际IP地址: 6387  自己实际IP地址: 6381</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">6387 就是将要作为master新增节点</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span> </span><br></pre></td></tr></table></figure>

<p>四、检查集群情况第1次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 真实ip地址:6381</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 例如</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6381</span> </span><br></pre></td></tr></table></figure>

<p>五、重新分派槽号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">重新分派槽号</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">命令:redis-cli --cluster  reshard  IP地址:端口号</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster reshard 192.168.111.147:6381</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png" class="" width="17">

<p>六、检查集群情况第2次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 真实ip地址:6381</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">为什么6387是3个新的区间，以前的还是连续？</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.png" class="" width="18">

<p>七、为主节点6387分配从节点6388</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">命令：redis-cli  --cluster add-node  ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster add-node 192.168.111.147:6388 192.168.111.147:6387 --cluster-slave --cluster-master-id e4781f644d4a4e4d4b4d107157b9ba8144631451-------这个是6387的编号，按照自己实际情况</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.png" class="" width="20">

<p>八、检查集群情况第3次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6382</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/19.png" class="" width="19">
</blockquote>
<h5 id="1-2-5-主从缩容案例"><a href="#1-2-5-主从缩容案例" class="headerlink" title="1.2.5 主从缩容案例"></a>1.2.5 主从缩容案例</h5><blockquote>
<p>一、目的：6387和6388下线</p>
<p>二、检查集群情况1获得6388的节点ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6382</span> </span><br></pre></td></tr></table></figure>

<p>三、将6388删除  从集群中将4号从节点6388删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">命令：redis-cli --cluster  del-node  ip:从机端口 从机6388节点ID</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster  del-node  192.168.111.147:6388 5d149074b7e57b802287d1797a874ed7a1a284a8</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6382</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">检查一下发现，6388被删除了，只剩下7台机器了。</span></span><br></pre></td></tr></table></figure>

<p>四、将6387的槽号清空，重新分配，本例将清出来的槽号都给6381</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster reshard 192.168.111.147:6381</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/21.png" class="" width="21">

<p>五、检查集群情况第二次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6381</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.png" class="" width="22">

<p>六、将6387删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 命令：redis-cli --cluster del-node ip:端口 6387节点ID</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster del-node 192.168.111.147:6387 e4781f644d4a4e4d4b4d107157b9ba8144631451</span> </span><br></pre></td></tr></table></figure>

<p>七、检查集群情况第三次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">redis-cli --cluster check 192.168.111.147:6381</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.png" class="" width="23">
</blockquote>
<h3 id="二、DockerFile解析"><a href="#二、DockerFile解析" class="headerlink" title="二、DockerFile解析"></a>二、DockerFile解析</h3><h4 id="2-1-DockerFile是什么"><a href="#2-1-DockerFile是什么" class="headerlink" title="2.1 DockerFile是什么"></a>2.1 DockerFile是什么</h4><p>DockerFile是用来构建Docker镜像的文本文件，是有一条条构建镜像所需的指令和参数构成的脚本。</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24.png" class="" width="24">

<p>官网：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<p>构建三步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、编写DockerFile文件</span><br><span class="line">2、docker build命令构建镜像</span><br><span class="line">3、docker run 依镜像运行容器实例</span><br></pre></td></tr></table></figure>

<h4 id="2-2-DockerFile构建过程解析"><a href="#2-2-DockerFile构建过程解析" class="headerlink" title="2.2 DockerFile构建过程解析"></a>2.2 DockerFile构建过程解析</h4><p><strong>DockerFile内容基础知识</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 每条保留字指令都必须为大写字母且后面跟随至少一个参数</span><br><span class="line">2. 指令按照从上到下，顺序执行</span><br><span class="line">3. #表示注释</span><br><span class="line">4. 每条指令都会创建一个新的镜像层并对镜像进行提交。</span><br></pre></td></tr></table></figure>

<p><strong>Docker执行DockerFile的大致流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. docker从技术镜像运行一个容器</span><br><span class="line">2. 执行一条指令比鞥对容器做出修改</span><br><span class="line">3. 执行类似docker commit 的操作提交一个新的镜像层</span><br><span class="line">4. docker 在基于刚提交的镜像运行一个新容器</span><br><span class="line">5. 执行dockerfile中的下一条指令直到所有执行执行完成。</span><br></pre></td></tr></table></figure>

<h4 id="2-3-小总结"><a href="#2-3-小总结" class="headerlink" title="2.3 小总结"></a>2.3 小总结</h4><blockquote>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段， </p>
<p>Dockerfile是软件的原材料 </p>
<p>Docker镜像是软件的交付品 </p>
<p>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例 </p>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。 </p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.png" class="" width="25">

<ol>
<li><p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等; </p>
</li>
<li><p>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务; </p>
</li>
<li><p>Docker容器，容器是直接提供服务的。 </p>
</li>
</ol>
</blockquote>
<h4 id="2-4-DockerFile常用保留字指令"><a href="#2-4-DockerFile常用保留字指令" class="headerlink" title="2.4 DockerFile常用保留字指令"></a>2.4 DockerFile常用保留字指令</h4><blockquote>
<ol>
<li>参考tomcat8的dockerfile入门</li>
</ol>
<p><a href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p>
<ol start="2">
<li>From</li>
</ol>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>MANINTAINER</li>
</ol>
<p> 镜像维护者的姓名和邮箱地址</p>
<ol start="4">
<li>Run</li>
</ol>
<p> 容器构建时需要运行的命令</p>
<p> 两种格式：</p>
<p> shell格式</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;命令行命令&gt;等同于，在终端操作的shell命令</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br></pre></td></tr></table></figure>

<p> exec格式</p>
 <img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/26.png" class="" width="26">

<p> RUN是在docker build时运行</p>
<ol start="5">
<li>EXPOSE</li>
</ol>
<p> 当前容器对外暴露出的端口</p>
<ol start="6">
<li>WORKDIR</li>
</ol>
<p> 指定在创建容器后。终端默认登录的进来工作目录，一个落脚点。</p>
<ol start="7">
<li>USER</li>
</ol>
<p> 指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p>
<ol start="8">
<li>ENV</li>
</ol>
<p> 用来在构建镜像过程中设置环境变量</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ENV</span> <span class="string">MY_PATH /usr/mytest </span></span><br><span class="line"><span class="meta">这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</span> <span class="string"></span></span><br><span class="line"><span class="meta">也可以在其它指令中直接使用这些环境变量，</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">比如：WORKDIR</span> <span class="string">$MY_PATH </span></span><br></pre></td></tr></table></figure>



<ol start="9">
<li>ADD</li>
</ol>
<p> 将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p>
<ol start="10">
<li>COPY</li>
</ol>
<p>  类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层镜像内的&lt;目标路径&gt;位置</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY src dest</span><br><span class="line"></span><br><span class="line">COPY[&quot;src&quot;,&quot;dest&quot;]</span><br><span class="line"></span><br><span class="line">&lt;src源路径&gt;：源文件或源目录</span><br><span class="line"></span><br><span class="line">&lt;dest目标路径&gt;: 容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</span><br></pre></td></tr></table></figure>



<ol start="11">
<li>VOLUME</li>
</ol>
<p>  容器数据卷，用于数据保存和持久化的工作</p>
<ol start="12">
<li>CMD</li>
</ol>
<p>  指定容器启动后的要干的事情。</p>
<p>  【注意】</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Dockerfile 中可以由多个CMD指令，但是只有最后一个生效，CMD会被docker run 之后的参数替换。</span><br></pre></td></tr></table></figure>

<p>  参考官网Tomcat的dockerfile演示讲解</p>
<p>  官网最后一行命令</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;catalina.sh&quot;,&quot;run&quot;]</span><br></pre></td></tr></table></figure>

<p>  我们演示自己的覆盖操作</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:8080  容器ID /bin/bash</span><br></pre></td></tr></table></figure>

<p>  他和前面RUN命令的区别</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMD 是在 docker run 时运行。</span><br><span class="line"></span><br><span class="line">RUN 是在docker build 时运行</span><br></pre></td></tr></table></figure>



<ol start="13">
<li><p>ENTRYPOINT </p>
</li>
<li><p>也是用来指定一个容器启动时要运行的命令</p>
</li>
<li><p>类似于CMD指令，但是ENTRYPOINT不会被docker run 后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。</p>
</li>
<li><p>命令格式和案例说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令格式：ENTRYPOINT[&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br><span class="line">     </span><br><span class="line">ENTRYPOINT 可以和CMD一起用，一般是 变参 才会使用 CMD ，这里的CMD等于是在给 ENTRYPOINT 传参。当制定了 ENTRYPOINT 后，CMD的含义就发生了变化，不再是直接运行其命令而是将 CMD 的内容作为参数传递给 ENTRYPOINT 指定，他两个组合会变成&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br><span class="line">案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像</span><br></pre></td></tr></table></figure>

 <img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/27.png" class="" width="27">

<table>
<thead>
<tr>
<th>是否传参</th>
<th>按照dockerfile编写执行</th>
<th>传参运行</th>
</tr>
</thead>
<tbody><tr>
<td>Docker命令</td>
<td>docker run nginx:test</td>
<td>docker run nginx:test -c /etc/nginx/ new.conf</td>
</tr>
<tr>
<td>衍生出的实际命令</td>
<td>nginx -c /etc/nginx/nginx.conf</td>
<td>nginx -c /etc/nginx/ new.conf</td>
</tr>
</tbody></table>
</li>
</ol>
<p>  优点：在执行docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>  注意：如果Dockerfile 中如果存在多个 ENTRYPOINT 指令，进最后一个生效。</p>
<ol start="14">
<li><p>小总结</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/28.png" class="" width="28"></li>
</ol>
</blockquote>
<h4 id="2-5-案例"><a href="#2-5-案例" class="headerlink" title="2.5 案例"></a>2.5 案例</h4><h5 id="2-5-1-自定义镜像mycentosjava8"><a href="#2-5-1-自定义镜像mycentosjava8" class="headerlink" title="2.5.1 自定义镜像mycentosjava8"></a>2.5.1 自定义镜像mycentosjava8</h5><p><strong>要求</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Centos7镜像具备 vim + ifconfig + jdk8</span><br><span class="line"></span><br><span class="line">JDK下载镜像地址</span><br><span class="line">官网：https://www.oracle.com/java/technologies/downloads/#java8 </span><br><span class="line">https://mirrors.yangxingzhen.com/jdk/</span><br></pre></td></tr></table></figure>

<p><strong>编写</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">准备编写Dockerfile文件 </span><br><span class="line">【注意】大写字母D</span><br><span class="line"> </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzyy&lt;zzyybs@126.com&gt; </span><br><span class="line">  </span><br><span class="line">ENV MYPATH /usr/local </span><br><span class="line">WORKDIR $MYPATH </span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装vim编辑器</span> </span><br><span class="line">RUN yum -y install vim </span><br><span class="line"><span class="meta">#</span><span class="bash">安装ifconfig命令查看网络IP</span> </span><br><span class="line">RUN yum -y install net-tools </span><br><span class="line"><span class="meta">#</span><span class="bash">安装java8及lib库</span> </span><br><span class="line">RUN yum -y install glibc.i686 </span><br><span class="line">RUN mkdir /usr/local/java </span><br><span class="line"><span class="meta">#</span><span class="bash">ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span> </span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/ </span><br><span class="line"><span class="meta">#</span><span class="bash">配置java环境变量</span> </span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 </span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre </span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH </span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH </span><br><span class="line">  </span><br><span class="line">EXPOSE 80 </span><br><span class="line"> </span><br><span class="line">CMD echo $MYPATH </span><br><span class="line">CMD echo &quot;success--------------ok&quot; </span><br><span class="line">CMD /bin/bash </span><br></pre></td></tr></table></figure>

<p><strong>构建</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 新镜像名字: TAG</span><br><span class="line"></span><br><span class="line">例如：docker build -t centosjava8:1.5 .</span><br><span class="line"></span><br><span class="line">【注意】</span><br><span class="line">上面TAG 后面有个空格，有个点</span><br></pre></td></tr></table></figure>

<p><strong>运行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG</span><br><span class="line"></span><br><span class="line">docker run -it centosjava8:1.5 /bin/bash </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/29.png" class="" width="29">

<p><strong>再体会下UnionFS（联合文件系统）</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持</span> <span class="string">对文件系统的修改作为一次提交来一层层的叠加， 同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承 ，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</span> <span class="string"></span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-虚悬镜像"><a href="#2-5-2-虚悬镜像" class="headerlink" title="2.5.2 虚悬镜像"></a>2.5.2 虚悬镜像</h5><p><strong>是什么</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">仓库名，标签都是 &lt;none&gt; 的镜像，俗称dangling image</span><br><span class="line"></span><br><span class="line">Dockerfile 写一个</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.png" class="" width="30">

<p><strong>查看</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br><span class="line">命令结果如下图：</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/31.png" class="" width="31">

<p><strong>删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image prune </span><br><span class="line"></span><br><span class="line">虚悬镜像已经市区存在价值，可以删除</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/32.png" class="" width="32">

<h5 id="2-5-3-家庭作业自定义myubuntu"><a href="#2-5-3-家庭作业自定义myubuntu" class="headerlink" title="2.5.3 家庭作业自定义myubuntu"></a>2.5.3 家庭作业自定义myubuntu</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写</span></span><br><span class="line">准备编写DockerFile文件</span><br><span class="line">vim Dockerfile</span><br><span class="line">----------------------</span><br><span class="line">FROM ubuntu</span><br><span class="line">MAINTAINER zzyy&lt;zzyybs@126.com&gt; </span><br><span class="line">  </span><br><span class="line">ENV MYPATH /usr/local </span><br><span class="line">WORKDIR $MYPATH </span><br><span class="line">  </span><br><span class="line">RUN apt-get update </span><br><span class="line">RUN apt-get install net-tools </span><br><span class="line"><span class="meta">#</span><span class="bash">RUN apt-get install -y iproute2</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">RUN apt-get install -y inetutils-ping</span> </span><br><span class="line">  </span><br><span class="line">EXPOSE 80 </span><br><span class="line">  </span><br><span class="line">CMD echo $MYPATH </span><br><span class="line">CMD echo &quot;install inconfig cmd into ubuntu success--------------ok&quot; </span><br><span class="line">CMD /bin/bash </span><br><span class="line">------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建</span></span><br><span class="line">docker build -t 新镜像名字:TAG</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">运行</span></span><br><span class="line">docker run -it 新镜像名字:TAG</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、Docker微服务实战"><a href="#三、Docker微服务实战" class="headerlink" title="三、Docker微服务实战"></a>三、Docker微服务实战</h3><h4 id="3-1-通过IDEA新建一个普通微服务模块"><a href="#3-1-通过IDEA新建一个普通微服务模块" class="headerlink" title="3.1 通过IDEA新建一个普通微服务模块"></a>3.1 通过IDEA新建一个普通微服务模块</h4><p><strong>建Module</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker_boot</span><br></pre></td></tr></table></figure>

<p><strong>修改POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version =&quot;1.0&quot; encoding =&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> =<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:</span> <span class="attr">xsi</span> =<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi</span> <span class="attr">:schemaLocation</span> =<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span> 4.0.0 &lt;/ modelVersion&gt; </span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot &lt;/ groupId&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-parent &lt;/ artifactId&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span> 2.5.6 &lt;/ version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span> </span><br><span class="line">   &lt;/ parent&gt; </span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> com.atguigu.docker &lt;/ groupId&gt; </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> docker_boot &lt;/ artifactId&gt; </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span> 0.0.1-SNAPSHOT &lt;/ version&gt; </span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span> UTF-8 &lt;/ project.build.sourceEncoding&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span> 1.8 &lt;/ maven.compiler.source&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span> 1.8 &lt;/ maven.compiler.target&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span> 4.12 &lt;/ junit.version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span> 1.2.17 &lt;/ log4j.version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span> 1.16.18 &lt;/ lombok.version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span> 5.1.47 &lt;/ mysql.version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span> 1.1.16 &lt;/ druid.version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper.version</span>&gt;</span> 4.1.5 &lt;/ mapper.version&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span> 1.3.0 &lt;/ mybatis.spring.boot.version&gt; </span><br><span class="line">   &lt;/ properties&gt; </span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">     <span class="comment">&lt;!--SpringBoot 通用依赖模块 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot &lt;/ groupId&gt; </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-web &lt;/ artifactId&gt; </span><br><span class="line">     &lt;/ dependency&gt; </span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot &lt;/ groupId&gt; </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-actuator &lt;/ artifactId&gt; </span><br><span class="line">     &lt;/ dependency&gt; </span><br><span class="line">     <span class="comment">&lt;!--test--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot &lt;/ groupId&gt; </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-test &lt;/ artifactId&gt; </span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span> test &lt;/ scope&gt; </span><br><span class="line">     &lt;/ dependency&gt; </span><br><span class="line">   &lt;/ dependencies&gt; </span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot &lt;/ groupId&gt; </span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-maven-plugin &lt;/ artifactId&gt; </span><br><span class="line">       &lt;/ plugin&gt; </span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.apache.maven.plugins &lt;/ groupId&gt; </span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> maven-resources-plugin &lt;/ artifactId&gt; </span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span> 3.1.0 &lt;/ version&gt; </span><br><span class="line">       &lt;/ plugin&gt; </span><br><span class="line">     &lt;/ plugins&gt; </span><br><span class="line">   &lt;/ build&gt; </span><br><span class="line"> &lt;/ project&gt; </span><br></pre></td></tr></table></figure>

<p><strong>写YML</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.port=6001</span></span><br></pre></td></tr></table></figure>

<p><strong>主启动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  com.atguigu.docker;</span><br><span class="line"><span class="keyword">import</span>  org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span>  org.springframework.boot.autoconfigure. SpringBootApplication ;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">DockerBootApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span>    </span>&#123;</span><br><span class="line">  	SpringApplication. run (DockerBootApplication. <span class="class"><span class="keyword">class</span> , <span class="title">args</span>)</span>;</span><br><span class="line"> 		 &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>业务类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.docker.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation. Value ;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation. RequestMapping ;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation. RestController ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line">/</span><br><span class="line"> *<span class="meta">@auther</span>  zzyy</span><br><span class="line"> *<span class="meta">@create</span>  <span class="number">2021</span>-<span class="number">10</span>-<span class="number">25</span> <span class="number">17</span>:<span class="number">43</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="meta">@Value</span> ( <span class="string">&quot;$&#123;server.port&#125;&quot;</span> )</span><br><span class="line">  <span class="keyword">private</span> String port ;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span> ( <span class="string">&quot;/order/docker&quot;</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">helloDocker</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello docker&quot;</span> + <span class="string">&quot; \t &quot;</span> + port + <span class="string">&quot; \t &quot;</span> + UUID. *randomUUID* ().toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span> (value = <span class="string">&quot;/order/index&quot;</span> ,method = RequestMethod. *GET\* )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; 服务端口号 : &quot;</span> + <span class="string">&quot; \t &quot;</span> + port + <span class="string">&quot; \t &quot;</span> +UUID. *randomUUID* ().toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="3-2-通过dockerfile-发布微服务部署到docker容器"><a href="#3-2-通过dockerfile-发布微服务部署到docker容器" class="headerlink" title="3.2 通过dockerfile 发布微服务部署到docker容器"></a>3.2 通过dockerfile 发布微服务部署到docker容器</h4><h5 id="3-2-1-IDEA工具里面搞定微服务jar包"><a href="#3-2-1-IDEA工具里面搞定微服务jar包" class="headerlink" title="3.2.1 IDEA工具里面搞定微服务jar包"></a>3.2.1 <strong>IDEA工具里面搞定微服务jar包</strong></h5><img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/33.png" class="" width="33">

<h5 id="3-2-2-编写Dockerfile"><a href="#3-2-2-编写Dockerfile" class="headerlink" title="3.2.2 编写Dockerfile"></a>3.2.2 <strong>编写Dockerfile</strong></h5><p> <strong>Dockerfile内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基础镜像使用java</span> </span><br><span class="line">FROM java:8 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 作者</span> </span><br><span class="line">MAINTAINER zzyy </span><br><span class="line"><span class="meta">#</span><span class="bash"> VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span> </span><br><span class="line">VOLUME /tmp </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将jar包添加到容器中并更名为zzyy_docker.jar</span> </span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar /zzyy_docker.jar </span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行jar包</span> </span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27; </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;] </span><br><span class="line"><span class="meta">#</span><span class="bash">暴露6001端口作为微服务</span> </span><br><span class="line">EXPOSE 6001 </span><br></pre></td></tr></table></figure>

<p><strong>将微服务jar包和Dockerfile文件上传到同一个目录下/mydocker</strong></p>
 <img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/34.png" class="" width="34">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 . </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>构建镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 .</span><br><span class="line"></span><br><span class="line">打包成镜像文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure>

<p><strong>运行容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行命令</span></span><br><span class="line">docker run -d -p 6001:6001 zzyy_docker:1.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像运行命令</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><strong>访问测试</strong></p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.png" class="" width="35">

<h3 id="四、Docker网络"><a href="#四、Docker网络" class="headerlink" title="四、Docker网络"></a>四、Docker网络</h3><h4 id="4-1-Docker-网络是什么"><a href="#4-1-Docker-网络是什么" class="headerlink" title="4.1 Docker 网络是什么"></a>4.1 Docker 网络是什么</h4><h5 id="4-1-1-docker不启动，默认网络情况"><a href="#4-1-1-docker不启动，默认网络情况" class="headerlink" title="4.1.1 docker不启动，默认网络情况"></a>4.1.1 docker不启动，默认网络情况</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ens 33</span><br><span class="line">lo</span><br><span class="line">virbr0</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36.png" class="" width="36">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在CentOS7的安装过程中如果有 选择相关虚拟化的的服务安装系统后 ，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。 </span><br><span class="line">  </span><br><span class="line">我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载， </span><br><span class="line">yum remove libvirt-libs.x86_64 </span><br></pre></td></tr></table></figure>

<h5 id="4-1-2-docker启动后，网络情况"><a href="#4-1-2-docker启动后，网络情况" class="headerlink" title="4.1.2 docker启动后，网络情况"></a>4.1.2 docker启动后，网络情况</h5><p>查看docker网络模式命令</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/37.png" class="" width="37">

<h4 id="4-2-常用基本命令"><a href="#4-2-常用基本命令" class="headerlink" title="4.2 常用基本命令"></a>4.2 常用基本命令</h4><h5 id="4-2-1-All-命令"><a href="#4-2-1-All-命令" class="headerlink" title="4.2.1 All 命令"></a>4.2.1 <strong>All 命令</strong></h5><img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/38.png" class="" width="38">

<h5 id="4-2-2-查看网络"><a href="#4-2-2-查看网络" class="headerlink" title="4.2.2 查看网络"></a>4.2.2 <strong>查看网络</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-查看网络源数据"><a href="#4-2-3-查看网络源数据" class="headerlink" title="4.2.3 查看网络源数据"></a>4.2.3 查看网络源数据</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network inspect  XXX网络名字</span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-删除网络"><a href="#4-2-4-删除网络" class="headerlink" title="4.2.4 删除网络"></a>4.2.4 删除网络</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network rm XXX网络名字</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-案例"><a href="#4-2-5-案例" class="headerlink" title="4.2.5 案例"></a>4.2.5 案例</h5><img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/39.png" class="" width="39">

<h4 id="4-3-能干嘛"><a href="#4-3-能干嘛" class="headerlink" title="4.3 能干嘛"></a>4.3 能干嘛</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">容器间的互联和通信以及端口映射</span><br><span class="line">容器IP变动时候可以通过服务名直接网络通信而不受到影响</span><br></pre></td></tr></table></figure>

<h4 id="4-4-网络模式"><a href="#4-4-网络模式" class="headerlink" title="4.4 网络模式"></a>4.4 网络模式</h4><h5 id="4-4-1-总体介绍"><a href="#4-4-1-总体介绍" class="headerlink" title="4.4.1 总体介绍"></a>4.4.1 总体介绍</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bridge模式：使用--network bridge指定，默认使用docker()</span><br><span class="line"></span><br><span class="line">host模式：使用 --network host指定</span><br><span class="line"></span><br><span class="line">none模式：使用 --network none指定</span><br><span class="line"></span><br><span class="line">container模式：使用 --network container:Name或者容器ID指定</span><br></pre></td></tr></table></figure>

<h5 id="4-4-2-容器实例内默认网络IP生产规则"><a href="#4-4-2-容器实例内默认网络IP生产规则" class="headerlink" title="4.4.2 容器实例内默认网络IP生产规则"></a>4.4.2 容器实例内默认网络IP生产规则</h5><blockquote>
<p>1 先启动两个ubuntu容器实例 </p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/40.png" class="" width="40">

<p>2 docker inspect 容器ID or 容器名字 </p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/41.png" class="" width="41">

<p>3 关闭u2实例，新建u3，查看ip变化 </p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/42.png" class="" width="42">
</blockquote>
<h5 id="4-4-3-案例说明"><a href="#4-4-3-案例说明" class="headerlink" title="4.4.3 案例说明"></a>4.4.3 案例说明</h5><p><strong>bridge</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在 内核层 连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到 同一个物理网络 。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码， 让主机和容器之间可以通过网桥相互通信。 </span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 bridge 网络的详细信息，并通过 grep 获取名称项</span> </span><br><span class="line">docker network inspect bridge | grep name </span><br><span class="line"></span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。 </span><br><span class="line"> </span><br><span class="line">2 docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0 。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三…… ，lo代表127.0.0.1，即localhost ，inet addr用来表示网卡的IP地址 </span><br><span class="line"> </span><br><span class="line">3 网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。 </span><br><span class="line">   3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）； </span><br><span class="line">   3.2 每个容器实例内部也有一块网卡，每个接口叫eth0； </span><br><span class="line">   3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。 </span><br><span class="line"> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。 </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/43.png" class="" width="43">

<p>【代码】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080   --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080   --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><strong>两两匹配验证</strong></p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/44.png" class="" width="44">

<p><strong>Host</strong></p>
<blockquote>
<p>一、是什么</p>
<p>直接使用宿主机的IP地址与外界进行通信，不再需要额外进行NAT转换。</p>
<p>二、案例</p>
<ol>
<li>说明</li>
</ol>
<p> 容器将 不会获得 一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。 容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p>
<ol start="2">
<li>代码</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">警告：</span><br><span class="line"> docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">正确：</span><br><span class="line"> docker run -d    --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>无之前的配对显示了，看容器实例内部</li>
</ol>
 <img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/45.png" class="" width="45">

<ol start="4">
<li>没有设置-p的端口映射了，如何访问启动的tomcat83？</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://宿主机IP:8080/ </span><br><span class="line"></span><br><span class="line">在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的， </span><br><span class="line">所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>none</strong></p>
<blockquote>
<p>一、是什么</p>
<p>禁用网络功能，只有lo标识（就是127.0.0.1表示本地回环）</p>
<p>二、案例</p>
<p>docker run -d -p8084:8080 –network none –name tomcat84 billygoo/tomcat8-jdk8</p>
</blockquote>
<p><strong>container</strong></p>
<blockquote>
<p>一、是什么</p>
<p>container⽹络模式 </p>
<p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 </p>
<p>二、❎案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8085:8080                                     --name tomcat85 billygoo/tomcat8-jdk8</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat86 billygoo/tomcat8-jdk8</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">运行结果</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker：Error response from daemon: conflicting optisons: port ...........</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突</span></span> </span><br></pre></td></tr></table></figure>

<p>三、✅案例2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">Alpine操作系统是一个面向安全的轻型 Linux发行版</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -it                  --name alpine1  alpine /bin/sh</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -it --network container:alpine1 --name alpine2  alpine /bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果，验证共用搭桥</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/46.png" class="" width="46">

<p>假如此时关闭alpine1，再看看alpine2</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/47.png" class="" width="47">
</blockquote>
<p><strong>自定义网络</strong></p>
<blockquote>
<p>一、过时的link</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/48.png" class="" width="48">

<p>二、是什么</p>
<p>三、案例</p>
<p>【before】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">案例：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8081:8080   --name tomcat81 billygoo/tomcat8-jdk8</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8082:8080   --name tomcat82 billygoo/tomcat8-jdk8</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">上述成功启动并用docker <span class="built_in">exec</span>进入各自容器实例内部</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">问题：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">1. 按照IP地址ping是OK的</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">2. 按照服务名ping结果???</span></span><br><span class="line">ping： tocmat82：Name or service not known</span><br></pre></td></tr></table></figure>

<p>【after】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;案例</span><br><span class="line">&gt;自定义桥接网络,自定义网络默认使用的是桥接网络bridge</span><br><span class="line"></span><br><span class="line">&gt;新建自定义网络</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/49.png" class="" width="49">

<p>新建容器加入上一步新建的自定义网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8081:8080 --network zzyy_network  --name tomcat81 billygoo/tomcat8-jdk8</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8082:8080 --network zzyy_network  --name tomcat82 billygoo/tomcat8-jdk8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>互相ping测试</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/50.png" class="" width="50">

<p>问题结论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1、自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</span><br><span class="line">&gt;2、自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</span><br><span class="line">&gt;3、自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="4-5-Docker平台架构图解"><a href="#4-5-Docker平台架构图解" class="headerlink" title="4.5 Docker平台架构图解"></a>4.5 Docker平台架构图解</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。  </span><br><span class="line">  </span><br><span class="line">Docker 运行的基本流程为： </span><br><span class="line">  </span><br><span class="line">1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。 </span><br><span class="line">2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。 </span><br><span class="line">3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。 </span><br><span class="line">4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。 </span><br><span class="line">5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。 </span><br><span class="line">6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。 </span><br><span class="line">7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51.png" class="" width="51">

<h3 id="五、Docker-compose容器编排"><a href="#五、Docker-compose容器编排" class="headerlink" title="五、Docker-compose容器编排"></a>五、Docker-compose容器编排</h3><h4 id="5-1-Docker-compose是什么"><a href="#5-1-Docker-compose是什么" class="headerlink" title="5.1 Docker-compose是什么"></a>5.1 Docker-compose是什么</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</span><br></pre></td></tr></table></figure>

<h4 id="5-2-能干什么"><a href="#5-2-能干什么" class="headerlink" title="5.2 能干什么"></a>5.2 能干什么</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"> <span class="meta">docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</span> <span class="string"></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</span> <span class="string"></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</span> <span class="string"></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">Compose允许用户通过一个单独的</span> <span class="string">docker-compose.yml模板文件 （YAML 格式）来定义 一组相关联的应用容器为一个项目（project）。 </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose</span> <span class="string">解决了容器与容器之间如何管理编排的问题。</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-去哪里"><a href="#5-3-去哪里" class="headerlink" title="5.3 去哪里"></a>5.3 去哪里</h4><h5 id="5-3-1-官网："><a href="#5-3-1-官网：" class="headerlink" title="5.3.1 官网："></a>5.3.1 官网：</h5><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<h5 id="5-3-2-官网下载"><a href="#5-3-2-官网下载" class="headerlink" title="5.3.2 官网下载"></a>5.3.2 官网下载</h5><p><a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
<h5 id="5-3-3-安装步骤"><a href="#5-3-3-安装步骤" class="headerlink" title="5.3.3 安装步骤"></a>5.3.3 安装步骤</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose </span><br><span class="line">chmod +x /usr/local/bin/docker-compose </span><br><span class="line">docker-compose --version </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/52.png" class="" width="52">

<h5 id="5-3-4-卸载步骤"><a href="#5-3-4-卸载步骤" class="headerlink" title="5.3.4 卸载步骤"></a>5.3.4 卸载步骤</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h4 id="5-4-Compose-核心概念"><a href="#5-4-Compose-核心概念" class="headerlink" title="5.4 Compose 核心概念"></a>5.4 Compose 核心概念</h4><h5 id="5-4-1-一文件"><a href="#5-4-1-一文件" class="headerlink" title="5.4.1 一文件"></a>5.4.1 一文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose.yml</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-两要素"><a href="#5-4-2-两要素" class="headerlink" title="5.4.2 两要素"></a>5.4.2 两要素</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">服务(service):</span><br><span class="line">一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器。</span><br><span class="line"></span><br><span class="line">工程(project):</span><br><span class="line">由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</span><br></pre></td></tr></table></figure>

<h4 id="5-5-Compose-使用的三个步骤"><a href="#5-5-Compose-使用的三个步骤" class="headerlink" title="5.5 Compose 使用的三个步骤"></a>5.5 Compose 使用的三个步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</span><br><span class="line">2. 使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</span><br><span class="line">3. 最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-6-Compose常用命令"><a href="#5-6-Compose常用命令" class="headerlink" title="5.6 Compose常用命令"></a>5.6 Compose常用命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Compose 常用命令 </span><br><span class="line">docker-compose -h                           #  查看帮助 </span><br><span class="line">docker-compose up                           #  启动所有 docker-compose服务 </span><br><span class="line">docker-compose up -d                        #  启动所有 docker-compose服务 并后台运行 </span><br><span class="line">docker-compose down                         #  停止并删除容器、网络、卷、镜像。 </span><br><span class="line">docker-compose exec  yml里面的服务id                 # 进入容器实例内部  docker-compose exec  docker-compose.yml文件中写的服务id  /bin/bash </span><br><span class="line">docker-compose ps                      # 展示当前docker-compose编排过的运行的所有容器 </span><br><span class="line">docker-compose top                     # 展示当前docker-compose编排过的容器进程 </span><br><span class="line"> </span><br><span class="line">docker-compose logs  yml里面的服务id     #  查看容器输出日志 </span><br><span class="line">docker-compose config     #  检查配置 </span><br><span class="line">docker-compose config -q  #  检查配置，有问题才有输出 </span><br><span class="line">docker-compose restart   #  重启服务 </span><br><span class="line">docker-compose start     #  启动服务 </span><br><span class="line">docker-compose stop      #  停止服务 </span><br></pre></td></tr></table></figure>

<h4 id="5-5-Componse-编排微服务"><a href="#5-5-Componse-编排微服务" class="headerlink" title="5.5 Componse 编排微服务"></a>5.5 Componse 编排微服务</h4><h5 id="5-5-1-改造升级微服务工程docker-boot"><a href="#5-5-1-改造升级微服务工程docker-boot" class="headerlink" title="5.5.1 改造升级微服务工程docker_boot"></a>5.5.1 改造升级微服务工程docker_boot</h5><p><strong>以前的基础版</strong></p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/53.png" class="" width="53">

<p><strong>SQL建表建库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t_user` ( </span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT, </span><br><span class="line">  `username` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, </span><br><span class="line">  `password` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, </span><br><span class="line">  `sex` tinyint(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;, </span><br><span class="line">  `deleted` tinyint(4) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;, </span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, </span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, </span><br><span class="line">  PRIMARY KEY (`id`) </span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27; </span><br></pre></td></tr></table></figure>

<p><strong>改POM</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;? xml version =&quot;1.0&quot; encoding =&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt; project xmlns =&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns: xsi =&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi :schemaLocation =&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot; &gt; </span><br><span class="line">   &lt; modelVersion &gt; 4.0.0 &lt;/ modelVersion &gt; </span><br><span class="line">   &lt; parent &gt; </span><br><span class="line">     &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">     &lt; artifactId &gt; spring-boot-starter-parent &lt;/ artifactId &gt; </span><br><span class="line">     &lt; version &gt; 2.5.6 &lt;/ version &gt; </span><br><span class="line">     <span class="comment">&lt;!--&lt;version&gt;2.3.10.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line">     &lt; relativePath /&gt;  <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   &lt;/ parent &gt; </span><br><span class="line"></span><br><span class="line">   &lt; groupId &gt; com.atguigu.docker &lt;/ groupId &gt; </span><br><span class="line">   &lt; artifactId &gt; docker_boot &lt;/ artifactId &gt; </span><br><span class="line">   &lt; version &gt; 0.0.1-SNAPSHOT &lt;/ version &gt; </span><br><span class="line"></span><br><span class="line">   &lt; properties &gt; </span><br><span class="line">     &lt; project.build.sourceEncoding &gt; UTF-8 &lt;/ project.build.sourceEncoding &gt; </span><br><span class="line">     &lt; maven.compiler.source &gt; 1.8 &lt;/ maven.compiler.source &gt; </span><br><span class="line">     &lt; maven.compiler.target &gt; 1.8 &lt;/ maven.compiler.target &gt; </span><br><span class="line">     &lt; junit.version &gt; 4.12 &lt;/ junit.version &gt; </span><br><span class="line">     &lt; log4j.version &gt; 1.2.17 &lt;/ log4j.version &gt; </span><br><span class="line">     &lt; lombok.version &gt; 1.16.18 &lt;/ lombok.version &gt; </span><br><span class="line">     &lt; mysql.version &gt; 5.1.47 &lt;/ mysql.version &gt; </span><br><span class="line">     &lt; druid.version &gt; 1.1.16 &lt;/ druid.version &gt; </span><br><span class="line">     &lt; mapper.version &gt; 4.1.5 &lt;/ mapper.version &gt; </span><br><span class="line">     &lt; mybatis.spring.boot.version &gt; 1.3.0 &lt;/ mybatis.spring.boot.version &gt; </span><br><span class="line">   &lt;/ properties &gt; </span><br><span class="line"></span><br><span class="line">   &lt; dependencies &gt; </span><br><span class="line">     <span class="comment">&lt;!--guava Google 开源的  Guava 中自带的布隆过滤器 --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; com.google.guava &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; guava &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 23.0 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!-- redisson --&gt;</span></span><br><span class="line">    &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.redisson &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; redisson &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 3.13.4 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--SpringBoot 通用依赖模块 --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-starter-web &lt;/ artifactId &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-starter-actuator &lt;/ artifactId &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; io.springfox &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; springfox-swagger2 &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 2.9.2 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; io.springfox &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; springfox-swagger-ui &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 2.9.2 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--SpringBoot 与 Redis 整合依赖 --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-starter-data-redis &lt;/ artifactId &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--springCache--&gt;</span></span><br><span class="line">    &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-starter-cache &lt;/ artifactId &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--springCache 连接池依赖包 --&gt;</span></span><br><span class="line">    &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.apache.commons &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; commons-pool2 &lt;/ artifactId &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; redis.clients &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; jedis &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 3.1.0 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--Mysql 数据库驱动 --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; mysql &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; mysql-connector-java &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 5.1.47 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--SpringBoot 集成 druid 连接池 --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; com.alibaba &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; druid-spring-boot-starter &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 1.1.10 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; com.alibaba &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; druid &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; $&#123;druid.version&#125; &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--mybatis 和 springboot 整合 --&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.mybatis.spring.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; mybatis-spring-boot-starter &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; $&#123;mybatis.spring.boot.version&#125; &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!-- 添加 springboot 对 amqp 的支持 --&gt;</span></span><br><span class="line">    &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-starter-amqp &lt;/ artifactId &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; commons-codec &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; commons-codec &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 1.10 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!-- 通用基础配置 junit/devtools/test/log4j/lombok/hutool--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; cn.hutool &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; hutool-all &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 5.2.3 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; junit &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; junit &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; $&#123;junit.version&#125; &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-devtools &lt;/ artifactId &gt; </span><br><span class="line">       &lt; scope &gt; runtime &lt;/ scope &gt; </span><br><span class="line">       &lt; optional &gt; true &lt;/ optional &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; spring-boot-starter-test &lt;/ artifactId &gt; </span><br><span class="line">       &lt; scope &gt; test &lt;/ scope &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; log4j &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; log4j &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; $&#123;log4j.version&#125; &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; org.projectlombok &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; lombok &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; $&#123;lombok.version&#125; &lt;/ version &gt; </span><br><span class="line">       &lt; optional &gt; true &lt;/ optional &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!--persistence--&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; javax.persistence &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; persistence-api &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; 1.0.2 &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">     <span class="comment">&lt;!-- 通用 Mapper--&gt;</span></span><br><span class="line">     &lt; dependency &gt; </span><br><span class="line">       &lt; groupId &gt; tk.mybatis &lt;/ groupId &gt; </span><br><span class="line">       &lt; artifactId &gt; mapper &lt;/ artifactId &gt; </span><br><span class="line">       &lt; version &gt; $&#123;mapper.version&#125; &lt;/ version &gt; </span><br><span class="line">     &lt;/ dependency &gt; </span><br><span class="line">   &lt;/ dependencies &gt; </span><br><span class="line"></span><br><span class="line">   &lt; build &gt; </span><br><span class="line">     &lt; plugins &gt; </span><br><span class="line">       &lt; plugin &gt; </span><br><span class="line">         &lt; groupId &gt; org.springframework.boot &lt;/ groupId &gt; </span><br><span class="line">         &lt; artifactId &gt; spring-boot-maven-plugin &lt;/ artifactId &gt; </span><br><span class="line">       &lt;/ plugin &gt; </span><br><span class="line">       &lt; plugin &gt; </span><br><span class="line">         &lt; groupId &gt; org.apache.maven.plugins &lt;/ groupId &gt; </span><br><span class="line">         &lt; artifactId &gt; maven-resources-plugin &lt;/ artifactId &gt; </span><br><span class="line">         &lt; version &gt; 3.1.0 &lt;/ version &gt; </span><br><span class="line">       &lt;/ plugin &gt; </span><br><span class="line">     &lt;/ plugins &gt; </span><br><span class="line">   &lt;/ build &gt; </span><br><span class="line"></span><br><span class="line"> &lt;/ project &gt; </span><br></pre></td></tr></table></figure>

<p><strong>写YML</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.port</span> <span class="string">=</span> <span class="number">6001</span></span><br><span class="line"><span class="string">========================alibaba.druid*</span> <span class="string">相关配置</span> <span class="string">*=====================</span></span><br><span class="line"><span class="string">spring.datasource.type</span> <span class="string">=</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name</span> <span class="string">=</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="string">spring.datasource.url=</span> <span class="string">jdbc:mysql://192.168.111.169</span> <span class="string">:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="string">spring.datasource.username</span> <span class="string">=</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.datasource.password</span> <span class="string">=</span> <span class="number">123456</span></span><br><span class="line"><span class="string">spring.datasource.druid.test-while-idle</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">========================redis*</span> <span class="string">相关配置</span> <span class="string">*=====================</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.redis.database</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="string">spring.redis.host</span> <span class="string">=</span> <span class="number">192.168</span><span class="number">.111</span><span class="number">.169</span></span><br><span class="line"><span class="string">spring.redis.port</span> <span class="string">=</span> <span class="number">6379</span></span><br><span class="line"><span class="string">spring.redis.password</span> <span class="string">=</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-active</span> <span class="string">=</span> <span class="number">8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-wait</span> <span class="string">=</span> <span class="string">-1ms</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-idle</span> <span class="string">=</span> <span class="number">8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.min-idle</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">========================mybatis</span> <span class="string">相关配置</span> <span class="string">*===================*=</span></span><br><span class="line"></span><br><span class="line"><span class="string">mybatis.mapper-locations</span> <span class="string">=</span> <span class="string">classpath:mapper/\*.xml</span></span><br><span class="line"><span class="string">mybatis.type-aliases-package</span> <span class="string">=</span> <span class="string">com.atguigu.docker.entities</span></span><br><span class="line"></span><br><span class="line"><span class="string">========================swagger=====================</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.swagger2.enabled</span> <span class="string">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>主启动</strong></p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/54.png" class="" width="54">



<p><strong>业务类</strong></p>
<blockquote>
<p>一、config配置类</p>
<p>RedisConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span>  com.atguigu.docker.config;</span><br><span class="line">&gt;<span class="keyword">import</span>  lombok.extern.slf4j. Slf4j ;</span><br><span class="line">&gt;<span class="keyword">import</span>  org.springframework.context.annotation.Bean ;</span><br><span class="line">&gt;<span class="keyword">import</span>  org.springframework.context.annotation.Configuration ;</span><br><span class="line">&gt;<span class="keyword">import</span>  org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line">&gt;<span class="keyword">import</span>  org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">&gt;<span class="keyword">import</span>  org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line">&gt;<span class="keyword">import</span>  org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line">&gt;<span class="keyword">import</span>  java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@auther</span>  zzyy</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@create</span>  2021-10-27 17:19</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">RedisConfig</span></span>&#123;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  lettuceConnectionFactory     </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">* redis 序列化的工具配置类，下面这个请一定开启配置     </span></span><br><span class="line"><span class="comment">* 127.0.0.1:6379&gt; keys *    </span></span><br><span class="line"><span class="comment">* 1) &quot;ord:102&quot;   序列化过     </span></span><br><span class="line"><span class="comment">* 2) &quot;\xac\xed\x00\x05t\x00\aord:102&quot;    野生，没有序列化过     </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">&gt;<span class="meta">@Bean</span>    </span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span>  RedisTemplate&lt;String,Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span>   </span>&#123;       </span><br><span class="line">RedisTemplate&lt;String,Serializable&gt; redisTemplate =  <span class="keyword">new</span>  RedisTemplate&lt;&gt;();</span><br><span class="line">redisTemplate.setConnectionFactory(lettuceConnectionFactory);        </span><br><span class="line"><span class="comment">// 设置 key 序列化方式 string        </span></span><br><span class="line">redisTemplate.setKeySerializer( <span class="keyword">new</span>  StringRedisSerializer());        </span><br><span class="line"><span class="comment">// 设置 value 的序列化方式 json        </span></span><br><span class="line">redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">redisTemplate.setHashValueSerializer( <span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">redisTemplate.afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span>  redisTemplate;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>SwaggerConfig</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.docker.config;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> org.springframework.beans.factory.annotation. Value ;</span><br><span class="line"> <span class="keyword">import</span> org.springframework.context.annotation. Bean ;</span><br><span class="line"> <span class="keyword">import</span> org.springframework.context.annotation. Configuration ;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"> <span class="keyword">import</span> springfox.documentation.swagger2.annotations. EnableSwagger2 ;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> <span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@create</span> 2021-05-01 16:18</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableSwagger2</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">   <span class="meta">@Value</span> ( <span class="string">&quot;$&#123;spring.swagger2.enabled&#125;&quot;</span> )</span><br><span class="line">   <span class="keyword">private</span> Boolean enabled ;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType. *SWAGGER_2\* )</span><br><span class="line">         .apiInfo(apiInfo())</span><br><span class="line">         .enable( enabled )</span><br><span class="line">         .select()</span><br><span class="line">         .apis(RequestHandlerSelectors. *basePackage* ( <span class="string">&quot;com.atguigu.docker&quot;</span> )) *<span class="comment">//* 你自己的 *package</span></span><br><span class="line">         .paths(PathSelectors. *any* ())</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">         .title( <span class="string">&quot; 尚硅谷 Java 大厂技术 &quot;</span> + <span class="string">&quot; \t &quot;</span> + <span class="keyword">new</span> SimpleDateFormat( <span class="string">&quot;yyyy-MM-dd&quot;</span> ).format( <span class="keyword">new</span> Date()))</span><br><span class="line">         .description( <span class="string">&quot;docker-compose&quot;</span> )</span><br><span class="line">         .version( <span class="string">&quot;1.0&quot;</span> )</span><br><span class="line">         .termsOfServiceUrl( <span class="string">&quot;https://www.atguigu.com/&quot;</span> )</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>新建entity</strong> <strong>User</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.docker.entities;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> javax.persistence. Column ;</span><br><span class="line"> <span class="keyword">import</span> javax.persistence. GeneratedValue ;</span><br><span class="line"> <span class="keyword">import</span> javax.persistence. Id ;</span><br><span class="line"> <span class="keyword">import</span> javax.persistence. Table ;</span><br><span class="line"> <span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Table</span> (name = <span class="string">&quot;t_user&quot;</span> )</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue</span> (generator = <span class="string">&quot;JDBC&quot;</span> )</span><br><span class="line">   <span class="keyword">private</span> Integer id ;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">private</span> String username ;</span><br><span class="line">   <span class="keyword">private</span> String password ;</span><br><span class="line"> 	 <span class="keyword">private</span> Byte sex ;</span><br><span class="line">   <span class="keyword">private</span> Byte deleted ;</span><br><span class="line">   <span class="meta">@Column</span> (name = <span class="string">&quot;update_time&quot;</span> )</span><br><span class="line">   <span class="keyword">private</span> Date updateTime ;</span><br><span class="line">   <span class="meta">@Column</span> (name = <span class="string">&quot;create_time&quot;</span> )</span><br><span class="line">   <span class="keyword">private</span> Date createTime ;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> id ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> username ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . username = username;</span><br><span class="line">   &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> password ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . password = password;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Byte <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sex ;</span><br><span class="line">   &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(Byte sex)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . sex = sex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Byte <span class="title">getDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> deleted ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDeleted</span><span class="params">(Byte deleted)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . deleted = deleted;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Date <span class="title">getUpdateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> updateTime ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpdateTime</span><span class="params">(Date updateTime)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . updateTime = updateTime;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Date <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> createTime ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Date createTime)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span> . createTime = createTime;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p><strong>UserDTO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  com.atguigu.docker.entities;</span><br><span class="line"><span class="keyword">import</span>  io.swagger.annotations. ApiModel ;</span><br><span class="line"><span class="keyword">import</span>  io.swagger.annotations. ApiModelProperty ;</span><br><span class="line"><span class="keyword">import</span>  lombok. AllArgsConstructor ;</span><br><span class="line"><span class="keyword">import</span>  lombok. Data ;</span><br><span class="line"><span class="keyword">import</span>  lombok. NoArgsConstructor ;</span><br><span class="line"><span class="keyword">import</span>  java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span>  java.util.Date;</span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel</span> (value =  <span class="string">&quot; 用户信息 &quot;</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">UserDTO</span>  <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;     </span><br><span class="line"></span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 用户 ID&quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  Integer  id ;     </span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 用户名 &quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  String  username ;     </span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 密码 &quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  String  password ;     </span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 性别  0= 女  1= 男  &quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  Byte  sex ;     </span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 删除标志，默认 0 不删除， 1 删除 &quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  Byte  deleted ;     </span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 更新时间 &quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  Date  updateTime ;     </span><br><span class="line">	<span class="meta">@ApiModelProperty</span> (value =  <span class="string">&quot; 创建时间 &quot;</span> )     </span><br><span class="line">	<span class="keyword">private</span>  Date  createTime ;     </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@return</span>  id</span></span><br><span class="line"><span class="comment">	*/</span>     </span><br><span class="line">	<span class="function"><span class="keyword">public</span>  Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;         </span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>  id ;    </span><br><span class="line">	&#125;     </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@param</span>  id </span></span><br><span class="line"><span class="comment">	*/</span>     </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">this</span> . id  = id;   </span><br><span class="line">		 &#125;     </span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  获取用户名</span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@return</span>  username -  用户名</span></span><br><span class="line"><span class="comment">	*/</span>     </span><br><span class="line">	<span class="function"><span class="keyword">public</span>  String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span>  username ;    </span><br><span class="line">		&#125;    </span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  设置用户名</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@param</span>  username  用户名</span></span><br><span class="line"><span class="comment">	 */</span>     </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.username = username;</span><br><span class="line">	 &#125;     </span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  获取密码</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@return</span>  password -  密码</span></span><br><span class="line"><span class="comment">	 */</span>     </span><br><span class="line">	 <span class="function"><span class="keyword">public</span>  String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span>  password ;</span><br><span class="line">	 &#125;     </span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  设置密码</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@param</span>  password  密码</span></span><br><span class="line"><span class="comment">	 */</span>     </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.password=password;</span><br><span class="line">	 &#125;     </span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *获取性别  0= 女  1= 男</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@return</span>  sex -  性别  0= 女  1= 男</span></span><br><span class="line"><span class="comment">	 */</span>     </span><br><span class="line">	 <span class="function"><span class="keyword">public</span>  Byte <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span>  sex ;    </span><br><span class="line">	 	&#125;     </span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  设置性别  0= 女  1= 男       </span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  <span class="doctag">@param</span>  sex  性别  0= 女  1= 男       </span></span><br><span class="line"><span class="comment">	 */</span>    </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setSex</span><span class="params">(Byte sex)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">	  &#125;     </span><br><span class="line"></span><br><span class="line">	  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	  *  获取删除标志，默认 0 不删除， 1 删除      </span></span><br><span class="line"><span class="comment">	  *     </span></span><br><span class="line"><span class="comment">	  *  <span class="doctag">@return</span>  deleted -  删除标志，默认 0 不删除， 1 删除      </span></span><br><span class="line"><span class="comment">	  */</span>    </span><br><span class="line">	   <span class="function"><span class="keyword">public</span>  Byte <span class="title">getDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	   	<span class="keyword">return</span>  deleted ;</span><br><span class="line">	   &#125;     </span><br><span class="line"></span><br><span class="line">	   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	   *  设置删除标志，默认 0 不删除， 1 删除      </span></span><br><span class="line"><span class="comment">	   *</span></span><br><span class="line"><span class="comment">	   *  <span class="doctag">@param</span>  deleted  删除标志，默认 0 不删除， 1 删除      </span></span><br><span class="line"><span class="comment">	   */</span>    </span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setDeleted</span><span class="params">(Byte deleted)</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">this</span>.deleted = deleted;    </span><br><span class="line">	    	&#125;     </span><br><span class="line"></span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	    *  获取更新时间</span></span><br><span class="line"><span class="comment">	    *</span></span><br><span class="line"><span class="comment">	    *  <span class="doctag">@return</span>  update_time -  更新时间</span></span><br><span class="line"><span class="comment">	    */</span>     </span><br><span class="line">	    <span class="function"><span class="keyword">public</span>  Date <span class="title">getUpdateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">return</span>  updateTime ; </span><br><span class="line">	    	&#125;     </span><br><span class="line"></span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	    *  设置更新时间 </span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *  <span class="doctag">@param</span>  updateTime  更新时间     </span></span><br><span class="line"><span class="comment">      */</span>     </span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setUpdateTime</span><span class="params">(Date updateTime)</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">this</span> . updateTime  = updateTime;</span><br><span class="line">	    	&#125;     </span><br><span class="line"></span><br><span class="line">	    <span class="comment">/** </span></span><br><span class="line"><span class="comment">      *  获取创建时间     </span></span><br><span class="line"><span class="comment">      *   </span></span><br><span class="line"><span class="comment">      *  <span class="doctag">@return</span>  create_time -  创建时间   </span></span><br><span class="line"><span class="comment">      */</span>     </span><br><span class="line">	    <span class="function"><span class="keyword">public</span>  Date <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">	    	<span class="keyword">return</span>  createTime ;  </span><br><span class="line">        &#125;     </span><br><span class="line"></span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	    *  设置创建时间 </span></span><br><span class="line"><span class="comment">	    *</span></span><br><span class="line"><span class="comment">	    *  <span class="doctag">@param</span>  createTime  创建时间 </span></span><br><span class="line"><span class="comment">	    */</span>     </span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setCreateTime</span><span class="params">(Date createTime)</span> </span>&#123;         </span><br><span class="line">	    	<span class="keyword">this</span> . createTime  = createTime;    </span><br><span class="line">	    	&#125;     </span><br><span class="line"></span><br><span class="line">	    <span class="meta">@Override</span> </span><br><span class="line">	    <span class="function"><span class="keyword">public</span>  String <span class="title">toString</span><span class="params">()</span> </span>&#123;         \</span><br><span class="line">	    	<span class="keyword">return</span>  <span class="string">&quot;User&#123;&quot;</span>  +                 <span class="string">&quot;id=&quot;</span>  +  id  +                 <span class="string">&quot;, </span></span><br><span class="line"><span class="string">	    	username=&#x27;&quot;</span>  +  username  +  <span class="string">&#x27; \&#x27; &#x27;</span>  +                 <span class="string">&quot;, </span></span><br><span class="line"><span class="string">	    	password=&#x27;&quot;</span>  +  password  +  <span class="string">&#x27; \&#x27; &#x27;</span>  +                 <span class="string">&quot;, </span></span><br><span class="line"><span class="string">	    	sex=&quot;</span>  +  sex  + <span class="string">&#x27;&#125;&#x27;</span> ;    </span><br><span class="line">	    &#125;&#125; </span><br></pre></td></tr></table></figure>

<p><strong>新建mapper</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新建接口UserMapper</span><br><span class="line">src\main\resource路径下新建mapper文件夹并新增UserMapper.xml</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span>  com.atguigu.docker.mapper;</span><br><span class="line"><span class="keyword">import</span>  com.atguigu.docker.entities.User;</span><br><span class="line"><span class="keyword">import</span>  tk.mybatis.mapper.common.Mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">UserMapper</span>  <span class="keyword">extends</span>  <span class="title">Mapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> &lt;? xml version =&quot;1.0&quot;  encoding =&quot;UTF-8&quot; ?&gt;  </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE   <span class="meta-keyword">mapper</span>   <span class="meta-keyword">PUBLIC</span>   <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span> </span><br><span class="line">&lt; mapper  namespace =&quot;com.atguigu.docker.mapper.UserMapper&quot; &gt;     </span><br><span class="line">  &lt; resultMap  id =&quot;BaseResultMap&quot;  type =&quot;com.atguigu.docker.entities.User&quot; &gt;        </span><br><span class="line">    <span class="comment">&lt;!--        WARNING - @mbg.generated      --&gt;</span>       </span><br><span class="line">    &lt; id  column =&quot;id&quot;  jdbcType =&quot;INTEGER&quot;  property =&quot;id&quot;  /&gt;        </span><br><span class="line">    &lt; result  column =&quot;username&quot;  jdbcType =&quot;VARCHAR&quot;  property =&quot;username&quot;  /&gt;       </span><br><span class="line">    &lt; result  column =&quot;password&quot;  jdbcType =&quot;VARCHAR&quot;  property =&quot;password&quot;  /&gt;       </span><br><span class="line">    &lt; result  column =&quot;sex&quot;  jdbcType =&quot;TINYINT&quot;  property =&quot;sex&quot;  /&gt;       </span><br><span class="line">    &lt; result  column =&quot;deleted&quot;  jdbcType =&quot;TINYINT&quot;  property =&quot;deleted&quot;  /&gt;       </span><br><span class="line">    &lt; result  column =&quot;update_time&quot;  jdbcType =&quot;TIMESTAMP&quot;  property =&quot;updateTime&quot;  /&gt;       </span><br><span class="line">    &lt; result  column =&quot;create_time&quot;  jdbcType =&quot;TIMESTAMP&quot;  property =&quot;createTime&quot;  /&gt;     </span><br><span class="line">  &lt;/ resultMap &gt;  </span><br><span class="line">&lt;/ mapper &gt; </span><br></pre></td></tr></table></figure>

<p><strong>新建Service</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**新建Controller**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mvn package命令将微服务形成新的jar包</span><br><span class="line"></span><br><span class="line">并上传到Linux服务器/mydocker目录下</span><br><span class="line"></span><br><span class="line">**编写Dockerfile**</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"># 基础镜像使用java </span><br><span class="line">FROM java:8 </span><br><span class="line"># 作者 </span><br><span class="line">MAINTAINER zzyy </span><br><span class="line"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp </span><br><span class="line">VOLUME /tmp </span><br><span class="line"># 将jar包添加到容器中并更名为zzyy_docker.jar </span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar </span><br><span class="line"># 运行jar包 </span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27; </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;] </span><br><span class="line">#暴露6001端口作为微服务 </span><br><span class="line">EXPOSE 6001 </span><br></pre></td></tr></table></figure>

<p><strong>构建镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure>

<p><strong>5.5.2 不用Compose</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一、单独的mysql容器实例</span><br><span class="line">1. 新建mysql容器实例</span><br><span class="line">docker run -p 3306:3306 --name mysql57 --privileged=true -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -v /zzyyuse/mysql/logs:/logs -v /zzyyuse/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line"></span><br><span class="line">2. 进入mysql容器实例并新建库db2021+新建表t_user</span><br><span class="line">docker exec -it mysql57 /bin/bash </span><br><span class="line">mysql -uroot -p </span><br><span class="line">create database db2021; </span><br><span class="line">use db2021; </span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, </span><br><span class="line">  `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, </span><br><span class="line">  `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, </span><br><span class="line">  `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;, </span><br><span class="line">  `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;, </span><br><span class="line">  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, </span><br><span class="line">  `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, </span><br><span class="line">  PRIMARY KEY (`id`) </span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>单独的redis容器实例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  -p 6379:6379 --name redis608 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf </span><br></pre></td></tr></table></figure>

<p><strong>微服务工程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6001:6001 zzyy_docker:1.6 </span><br></pre></td></tr></table></figure>

<p><strong>上面三个容器实例依次顺序启动成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><strong>5.5.3 swagger 测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:你的微服务端口号/swagger-ui.html#/</span><br></pre></td></tr></table></figure>

<h5 id="5-5-4-上面存在什么问题？"><a href="#5-5-4-上面存在什么问题？" class="headerlink" title="5.5.4 上面存在什么问题？"></a>5.5.4 上面存在什么问题？</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">先后顺序要求固定，先mysql+redis才能微服务访问成功</span><br><span class="line"></span><br><span class="line">多个run命令......</span><br><span class="line"></span><br><span class="line">容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错，</span><br><span class="line"></span><br><span class="line">要么生产IP写死(可以但是不推荐)，要么通过服务调用</span><br></pre></td></tr></table></figure>

<h5 id="5-5-5-使用Compose"><a href="#5-5-5-使用Compose" class="headerlink" title="5.5.5 使用Compose"></a>5.5.5 使用Compose</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 服务编排，一套带走，安排</span><br><span class="line"></span><br><span class="line">2. 编写docker-componse.yml文件</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span> </span><br><span class="line">  </span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">microService:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">zzyy_docker:1.6</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ms01</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6001:6001&quot;</span> </span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/microService:/data</span> </span><br><span class="line">    <span class="attr">networks:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span>  </span><br><span class="line">    <span class="attr">depends_on:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">redis:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.0.8</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span> </span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/redis.conf:/etc/redis/redis.conf</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/redis/data:/data</span> </span><br><span class="line">    <span class="attr">networks:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">mysql:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span> </span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span> </span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span> </span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2021&#x27;</span> </span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zzyy&#x27;</span> </span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zzyy123&#x27;</span> </span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span> </span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/db:/var/lib/mysql</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/conf/my.cnf:/etc/my.cnf</span> </span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/mysql/init:/docker-entrypoint-initdb.d</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment">#解决外部无法访问 </span></span><br><span class="line">  </span><br><span class="line"><span class="attr">networks:</span>  </span><br><span class="line">   <span class="attr">atguigu_net:</span>  </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3. 第二次修改微服务工程docker_boot</span><br><span class="line">写YML 通过服务名访问，IP无关</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span> = <span class="string">6001</span></span><br><span class="line"><span class="comment"># ========================alibaba.druid 相关配置 =====================</span></span><br><span class="line"><span class="meta">spring.datasource.type</span> = <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://192.168.111.169:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="meta">spring.datasource.url</span> = <span class="string">jdbc:mysql://mysql:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false spring.datasource.username = rootspring.datasource.password = 123456spring.datasource.druid.test-while-idle = false</span></span><br><span class="line"><span class="comment"># ========================redis 相关配置 =====================</span></span><br><span class="line"><span class="meta">spring.redis.database</span> = <span class="string">0</span></span><br><span class="line"><span class="comment">#spring.redis.host=192.168.111.169</span></span><br><span class="line"><span class="meta">spring.redis.host</span> = <span class="string">redis </span></span><br><span class="line"><span class="meta">spring.redis.port</span> = <span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span> =<span class="string"></span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span> = <span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span> = <span class="string">-1ms</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span> = <span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span> = <span class="string">0</span></span><br><span class="line"><span class="comment"># ========================mybatis 相关配置 ===================</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span> = <span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span> = <span class="string">com.atguigu.docker.entities</span></span><br><span class="line"><span class="comment"># ========================swagger=====================</span></span><br><span class="line"><span class="meta">spring.swagger2.enabled</span> = <span class="string">true </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mvn package命令将微服务形成新的jar包</span><br><span class="line">并上传到Linux服务器/mydocker目录下</span><br><span class="line"></span><br><span class="line">编写Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基础镜像使用java</span> </span><br><span class="line">FROM java:8 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 作者</span> </span><br><span class="line">MAINTAINER zzyy </span><br><span class="line"><span class="meta">#</span><span class="bash"> VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span> </span><br><span class="line">VOLUME /tmp </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将jar包添加到容器中并更名为zzyy_docker.jar</span> </span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar </span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行jar包</span> </span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27; </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;] </span><br><span class="line"><span class="meta">#</span><span class="bash">暴露6001端口作为微服务</span> </span><br><span class="line">EXPOSE 6001 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构建镜像</span><br><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4. 执行 docker-compose up 或者 执行 docker-compose up -d</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5. 进入mysql容器实例并新建库db2021+新建表t_user</span><br><span class="line">docker exec -it 容器实例id /bin/bash </span><br><span class="line">mysql -uroot -p </span><br><span class="line">create database db2021; </span><br><span class="line">use db2021; </span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, </span><br><span class="line">  `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, </span><br><span class="line">  `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, </span><br><span class="line">  `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;, </span><br><span class="line">  `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;, </span><br><span class="line">  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, </span><br><span class="line">  `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, </span><br><span class="line">  PRIMARY KEY (`id`) </span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">6. 测试通过</span><br><span class="line">7. Compose常用命令</span><br><span class="line">Compose 常用命令 </span><br><span class="line">docker-compose -h                           #  查看帮助 </span><br><span class="line">docker-compose up                           #  启动所有 docker-compose服务 </span><br><span class="line">docker-compose up -d                        #  启动所有 docker-compose服务 并后台运行 </span><br><span class="line">docker-compose down                         #  停止并删除容器、网络、卷、镜像。 </span><br><span class="line">docker-compose exec  yml里面的服务id                 # 进入容器实例内部  docker-compose exec  docker-compose.yml文件中写的服务id  /bin/bash </span><br><span class="line">docker-compose ps                      # 展示当前docker-compose编排过的运行的所有容器 </span><br><span class="line">docker-compose top                     # 展示当前docker-compose编排过的容器进程 </span><br><span class="line"> </span><br><span class="line">docker-compose logs  yml里面的服务id     #  查看容器输出日志 </span><br><span class="line">dokcer-compose config     #  检查配置 </span><br><span class="line">dokcer-compose config -q  #  检查配置，有问题才有输出 </span><br><span class="line">docker-compose restart   #  重启服务 </span><br><span class="line">docker-compose start     #  启动服务 </span><br><span class="line">docker-compose stop      #  停止服务 </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">8. 关停</span><br><span class="line">docker -compose stop</span><br></pre></td></tr></table></figure>

<h3 id="六、Docker轻量级可视化工具Portainer"><a href="#六、Docker轻量级可视化工具Portainer" class="headerlink" title="六、Docker轻量级可视化工具Portainer"></a>六、Docker轻量级可视化工具Portainer</h3><h4 id="6-1-是什么"><a href="#6-1-是什么" class="headerlink" title="6.1 是什么"></a>6.1 是什么</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。 </span><br></pre></td></tr></table></figure>

<h4 id="6-2-安装"><a href="#6-2-安装" class="headerlink" title="6.2 安装"></a>6.2 安装</h4><blockquote>
<p>一、官网</p>
<p><a href="https://www.portainer.io/">https://www.portainer.io/</a></p>
<p><a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p>
<p>二、步骤</p>
<ol>
<li>docker命令安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 8000:8000 -p 9000:9000 --name portainer     --restart=always     -v /var/run/docker.sock:/var/run/docker.sock     -v portainer_data:/data     portainer/portainer</span> </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第一次登录需创建admin，访问地址：xxx.xxx.xxx.xxx:9000</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">用户名，直接用默认admin</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">密码记得8位，随便你写</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置admin用户和密码后首次登陆</li>
<li>选择local选项卡后本地docker详细信息展示</li>
<li>上一步的图形展示，能想得起对应命令吗？</li>
<li>登陆并演示介绍常用操作case</li>
</ol>
</blockquote>
<h3 id="七、Docker容器监控之CAdvisor-InfluxDB-Granfana"><a href="#七、Docker容器监控之CAdvisor-InfluxDB-Granfana" class="headerlink" title="七、Docker容器监控之CAdvisor+InfluxDB+Granfana"></a>七、Docker容器监控之CAdvisor+InfluxDB+Granfana</h3><h4 id="7-1-原生命令"><a href="#7-1-原生命令" class="headerlink" title="7.1 原生命令"></a>7.1 原生命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats命令的结果 </span><br><span class="line"></span><br><span class="line">问题</span><br><span class="line">通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据， 一般小公司够用了。。。。 </span><br><span class="line">但是</span><br><span class="line">docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能 </span><br></pre></td></tr></table></figure>

<h4 id="7-2-是什么"><a href="#7-2-是什么" class="headerlink" title="7.2 是什么"></a>7.2 是什么</h4><blockquote>
<p>容器监控3剑客</p>
<p>一句话</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</span></span><br></pre></td></tr></table></figure>

<p><strong>CAdvisor</strong></p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/71.png" class="" width="71">

<p><strong>InfluxDB</strong></p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/72.png" class="" width="72">

<p>Granfana</p>
<img src="/2022/02/13/docker%E9%AB%98%E7%BA%A7%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/73.png" class="" width="73">
</blockquote>
<h4 id="7-3-compose容器编排，一套带走"><a href="#7-3-compose容器编排，一套带走" class="headerlink" title="7.3 compose容器编排，一套带走"></a>7.3 compose容器编排，一套带走</h4><blockquote>
<p>一、新建目录</p>
<p>二、新建3件套组合的 docker-compose.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;version:</span> <span class="string">&#x27;3.1&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="string">&gt;volumes:</span> </span><br><span class="line"><span class="string">&gt;grafana_data:</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&gt;services:</span> </span><br><span class="line"><span class="string">&gt;influxdb:</span> </span><br><span class="line"><span class="string">&gt;image:</span> <span class="string">tutum/influxdb:0.9</span> </span><br><span class="line"><span class="string">&gt;restart:</span> <span class="string">always</span> </span><br><span class="line"><span class="string">&gt;environment:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">PRE_CREATE_DB=cadvisor</span> </span><br><span class="line"><span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span> </span><br><span class="line"><span class="attr">volumes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">./data/influxdb:/data</span> </span><br><span class="line"></span><br><span class="line"><span class="string">&gt;cadvisor:</span> </span><br><span class="line"><span class="attr">image:</span> <span class="string">google/cadvisor</span> </span><br><span class="line"><span class="attr">links:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span> </span><br><span class="line"><span class="attr">command:</span> <span class="string">-storage_driver=influxdb</span> <span class="string">-storage_driver_db=cadvisor</span> <span class="string">-storage_driver_host=influxsrv:8086</span> </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span> </span><br><span class="line"><span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span> </span><br><span class="line"><span class="attr">volumes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span> </span><br><span class="line"></span><br><span class="line"><span class="string">&gt;grafana:</span> </span><br><span class="line"><span class="attr">user:</span> <span class="string">&quot;104&quot;</span> </span><br><span class="line"><span class="attr">image:</span> <span class="string">grafana/grafana</span> </span><br><span class="line"><span class="attr">user:</span> <span class="string">&quot;104&quot;</span> </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span> </span><br><span class="line"><span class="attr">links:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span> </span><br><span class="line"><span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span> </span><br><span class="line"><span class="attr">volumes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">grafana_data:/var/lib/grafana</span> </span><br><span class="line"><span class="attr">environment:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">HTTP_USER=admin</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">HTTP_PASS=admin</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">INFLUXDB_HOST=influxsrv</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">INFLUXDB_PORT=8086</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">INFLUXDB_NAME=cadvisor</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">INFLUXDB_USER=root</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">INFLUXDB_PASS=root</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三、启动docker-compose文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>四、查看三个服务容器是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker ps</span></span><br></pre></td></tr></table></figure>

<p>五、测试</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;1.</span> <span class="string">浏览cAdvisor收集服务，http://ip:8080/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&gt;第一次访问慢，请稍等</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&gt;cadvisor也有基础的图形展现功能，这里主要用它来作数据采集</span></span><br><span class="line"><span class="meta">&gt;2.</span> <span class="string">浏览influxdb存储服务，http://ip:8083/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;3. 浏览grafana展现服务，http://ip:3000</span><br><span class="line">ip+3000端口的方式访问,默认帐户密码（admin/admin）</span><br><span class="line">https://gitee.com/yooome/golang/tree/main/Docker详细教程</span><br><span class="line">配置步骤</span><br><span class="line">[1] 配置数据源</span><br><span class="line">[2] 选择influxdb数据源</span><br><span class="line">[3] 配置细节</span><br><span class="line">[4] 配置面板panel</span><br><span class="line">[5] 到这里cAdvisor+InfluxDB+Grafana容器监控系统就部署完成了</span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1gr4y1U7CY?p=88">原视频地址</a></p>
<p><a href="https://gitee.com/yooome/golang">原文章地址</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr>
<span id="more"></span>

<h3 id="Docker-详细教程"><a href="#Docker-详细教程" class="headerlink" title="Docker 详细教程"></a>Docker 详细教程</h3><h3 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h3><h4 id="1-1-docker是什么"><a href="#1-1-docker是什么" class="headerlink" title="1.1 docker是什么"></a>1.1 docker是什么</h4><p>【问题】：问什么会有docker出现</p>
<pre><code>Docker的出现 使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。 
</code></pre>
<p>【docker理念】：解决了运行环境和配置问题的软件容器，方便持续继承并有助于整体发布的容器虚拟化技术。</p>
<h4 id="1-2-容器与虚拟机比较"><a href="#1-2-容器与虚拟机比较" class="headerlink" title="1.2 容器与虚拟机比较"></a>1.2 容器与虚拟机比较</h4><h5 id="1-2-1-容器发展简史"><a href="#1-2-1-容器发展简史" class="headerlink" title="1.2.1 容器发展简史"></a>1.2.1 容器发展简史</h5><p>￼￼￼<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" width="1"></p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" width="2">

<h5 id="1-2-2-传统虚拟机技术"><a href="#1-2-2-传统虚拟机技术" class="headerlink" title="1.2.2 传统虚拟机技术"></a>1.2.2 传统虚拟机技术</h5><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。 </p>
<p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。  </p>
<table>
<thead>
<tr>
<th>Win10</th>
<th>VMWare</th>
<th>Centos7</th>
<th>各种cpu、内存网络额配置+各种软件</th>
<th>虚拟机实例</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>虚拟机的缺点： </p>
<p>1   资源占用多         2   冗余步骤多          3   启动慢 </p>
<h5 id="1-2-3-容器虚拟化技术"><a href="#1-2-3-容器虚拟化技术" class="headerlink" title="1.2.3 容器虚拟化技术"></a>1.2.3 容器虚拟化技术</h5><p>由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术： </p>
<p>Linux容器(Linux Containers，缩写为 LXC) </p>
<p>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 </p>
<p>Linux 容器不是模拟一个完整的操作系统 而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。 容器与虚拟机不同，不需要捆绑一整套操作系统 ，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 </p>
<h5 id="1-2-4-对比"><a href="#1-2-4-对比" class="headerlink" title="1.2.4 对比"></a>1.2.4 对比</h5> <img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" width="3">

<p>比较了 Docker 和传统虚拟化方式的不同之处： </p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核 且也没有进行硬件虚拟 。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。  </p>
<h4 id="1-3-能干什么"><a href="#1-3-能干什么" class="headerlink" title="1.3 能干什么"></a>1.3 能干什么</h4><h5 id="1-3-1-技术职级变化"><a href="#1-3-1-技术职级变化" class="headerlink" title="1.3.1 技术职级变化"></a>1.3.1 技术职级变化</h5><p>coder -&gt; programmer -&gt; software engineer -&gt; DevOps engineer</p>
<h5 id="1-3-2-开发-运维（Devops-新一代开发工程师"><a href="#1-3-2-开发-运维（Devops-新一代开发工程师" class="headerlink" title="1.3.2 开发/运维（Devops)新一代开发工程师"></a>1.3.2 开发/运维（Devops)新一代开发工程师</h5><ul>
<li>一次构建、随处运行</li>
<li>更快速的应用交付和部署</li>
<li>更便捷的升级和扩缩容</li>
<li>更简单的系统运维</li>
<li>更高效的计算资源利用</li>
</ul>
<h5 id="1-3-3-Docker应用场景"><a href="#1-3-3-Docker应用场景" class="headerlink" title="1.3.3 Docker应用场景"></a>1.3.3 Docker应用场景</h5><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" width="4">

<p>Docker 借鉴了标砖集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p>
<h4 id="1-4-那些企业在使用"><a href="#1-4-那些企业在使用" class="headerlink" title="1.4 那些企业在使用"></a>1.4 那些企业在使用</h4><ul>
<li><p>新浪</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" width="5">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" width="6">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" width="7">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" width="8"></li>
<li><p>美团</p>
</li>
</ul>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" width="9">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" width="10">

<ul>
<li>蘑菇街</li>
</ul>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" class="" width="11">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" class="" width="12">

<h4 id="1-5-下载地址"><a href="#1-5-下载地址" class="headerlink" title="1.5 下载地址"></a>1.5 下载地址</h4><p>官网：<a href="http://www.docker.com/">http://www.docker.com</a></p>
<p>Docker Hub 官网：<a href="https://hub.docker.com/">https://hub.docker.com</a></p>
<h3 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h3><h4 id="2-1-前提说明"><a href="#2-1-前提说明" class="headerlink" title="2.1 前提说明"></a>2.1 前提说明</h4><h5 id="2-1-1-CentOS-Docker-安装"><a href="#2-1-1-CentOS-Docker-安装" class="headerlink" title="2.1.1 CentOS Docker 安装"></a>2.1.1 <strong>CentOS Docker</strong> <strong>安装</strong></h5><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" class="" width="13">

<h5 id="2-1-2-前提条件"><a href="#2-1-2-前提条件" class="headerlink" title="2.1.2 前提条件"></a>2.1.2 前提条件</h5><p>目前，CentOS仅发行版本中的内核支持Docker。Docker运行在CentOS 7（64-bit）上，要求系统为64位，Linux系统内核版本为3.8以上，这里选用Centos7.x</p>
<h5 id="2-1-3-查看自己的内核"><a href="#2-1-3-查看自己的内核" class="headerlink" title="2.1.3 查看自己的内核"></a>2.1.3 查看自己的内核</h5><p>uname 命令用于打印当前系统相关信息（内核版本号，硬件架构，主机名称和操作系统类型等）。</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" class="" width="14">

<h4 id="2-2-Docker的基本组成"><a href="#2-2-Docker的基本组成" class="headerlink" title="2.2 Docker的基本组成"></a>2.2 Docker的基本组成</h4><h5 id="2-2-1-镜像（image）"><a href="#2-2-1-镜像（image）" class="headerlink" title="2.2.1 镜像（image）"></a>2.2.1 镜像（image）</h5><p>Docker 镜像（Image）就是一个 <strong>只读</strong> 的模板。镜像可以用来创建 Docker 容器， 一个镜像可以创建很多容器 。 </p>
<p>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 </p>
<p>相当于容器的“源代码”， docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。</p>
<h5 id="2-2-2-容器（container）"><a href="#2-2-2-容器（container）" class="headerlink" title="2.2.2 容器（container）"></a>2.2.2 容器（container）</h5><ul>
<li>从面向对象角度 </li>
</ul>
<p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境， 容器是用镜像创建的运行实例 。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境 ，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台 </p>
<ul>
<li>从镜像容器角度 </li>
</ul>
<p><strong>可以把容器看做是一个简易版的</strong> *<strong>Linux*</strong> <strong>环境</strong> （包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 </p>
<h5 id="2-2-3-仓库（repository）"><a href="#2-2-3-仓库（repository）" class="headerlink" title="2.2.3 仓库（repository）"></a>2.2.3 仓库（repository）</h5><p>仓库（Repository）是 集中存放镜像 文件的场所。 </p>
<p>类似于 </p>
<p>Maven仓库，存放各种jar包的地方； </p>
<p>github仓库，存放各种git项目的地方； </p>
<p>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。 </p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 </p>
<p>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com/</a>) ， </p>
<p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等 </p>
<h5 id="2-2-4-小总结"><a href="#2-2-4-小总结" class="headerlink" title="2.2.4 小总结"></a>2.2.4 小总结</h5><ul>
<li>需要正确的理解仓库/镜像/容器这几个概念: </li>
</ul>
<p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 </p>
<p>image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 </p>
<ul>
<li>镜像文件 </li>
</ul>
<p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 </p>
<ul>
<li>容器实例 </li>
</ul>
<p>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器 。</p>
<ul>
<li>仓库 </li>
</ul>
<p>就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。 </p>
<h4 id="2-3-Docker平台架构图解（入门版）"><a href="#2-3-Docker平台架构图解（入门版）" class="headerlink" title="2.3 Docker平台架构图解（入门版）"></a>2.3 Docker平台架构图解（入门版）</h4><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" class="" width="15">

<h5 id="2-3-1-Docker工作原理"><a href="#2-3-1-Docker工作原理" class="headerlink" title="2.3.1 Docker工作原理"></a>2.3.1 Docker工作原理</h5><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器 。 容器，是一个运行时环境，就是我们前面说到的集装箱。可以对比mysql演示对比讲解 </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" class="" width="16">

<h5 id="2-3-2-整体架构及底层通信原理简述"><a href="#2-3-2-整体架构及底层通信原理简述" class="headerlink" title="2.3.2 整体架构及底层通信原理简述"></a>2.3.2 整体架构及底层通信原理简述</h5><p>Docker是一个C/S模式的架构，后端是一个松耦合架构，众多模块各司其职</p>
<h5 id="2-3-3-Docker运行的基本流程为："><a href="#2-3-3-Docker运行的基本流程为：" class="headerlink" title="2.3.3 Docker运行的基本流程为："></a>2.3.3 Docker运行的基本流程为：</h5><ol>
<li>用户是使用Docker Client 与Docker Daemon 建立通信，并发送请求给后者。</li>
<li>Docker Daemon 作为Docker架构中的主体部分，首先提供Docker Server 的功能时期可以接受 Docker Client的请求。</li>
<li>Docker Engine 执行Docker内部的一些列工作，每一项工作都是以一个Job的形式的存在。</li>
<li>Job的运行过程中，当需要容器镜像是，则从Docker Register中下载镜像，并通过镜像管理驱动Graph driver 将下载镜像以Graph的形式存储。</li>
<li>当需要为Docker创建网络环境时，通过网络驱动Network driver创建并配置Docker容器网络环境。</li>
<li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。</li>
<li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体容器进行的操作。</li>
</ol>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png" class="" width="17">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.png" class="" width="18">

<h4 id="2-4、安装步骤"><a href="#2-4、安装步骤" class="headerlink" title="2.4、安装步骤"></a>2.4、安装步骤</h4><h5 id="2-4-1-CentOS7安装Docker"><a href="#2-4-1-CentOS7安装Docker" class="headerlink" title="2.4.1 CentOS7安装Docker"></a>2.4.1 CentOS7安装Docker</h5><ol>
<li>确定你是CentOS7以上版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看CentOS版本命令</span></span><br><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>卸载旧版本</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/19.png" class="" width="19"></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载旧版本docker命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line"><span class="bash">									docker-client \</span></span><br><span class="line"><span class="bash">									docker-client-latest \</span></span><br><span class="line"><span class="bash">									docker-common \</span></span><br><span class="line"><span class="bash">									docker-latest \</span></span><br><span class="line"><span class="bash">									docker-latest-logrotate \</span></span><br><span class="line"><span class="bash">									docker-logrotate \</span></span><br><span class="line"><span class="bash">									docker-engine</span>		</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>yum安装gcc相关命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum安装gcc相关命令</span></span><br><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>安装需要的软件包</p>
<p><img src="docker学习笔记/20.png" alt="20" style="zoom:50%;" /><strong>使用存储库安装</strong></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在新主机上首次安装Docker Engine之前，您需要设置Docker存储库。之后，您可以从存储库安装和更新Docker</span><br><span class="line">设置存储库</span><br><span class="line">安装 yum-utils 包（提供yum-config-manager 实用程序）并设置稳定的存储库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 官网要求</span></span><br><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>设置stable镜像仓库</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/21.png" class="" width="21"></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推荐使用 使用阿里的 docker 镜像仓库，国外的镜像仓库是比较慢的</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>更新yum软件包索引</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>安装DOCKER CE 引擎</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>启动docker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动命令</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>测试</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">docker version </span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.png" class="" width="22">

<ol start="10">
<li>卸载</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载命令</span></span><br><span class="line">systemctl stop docker </span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h4 id="2-5、阿里云镜像加速"><a href="#2-5、阿里云镜像加速" class="headerlink" title="2.5、阿里云镜像加速"></a>2.5、阿里云镜像加速</h4><h4 id="2-5-1-是什么"><a href="#2-5-1-是什么" class="headerlink" title="2.5.1 是什么"></a>2.5.1 是什么</h4><ul>
<li><p>地址：<a href="https://promotion.aliyun.com/ntms/act/kubernetes.html">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>
</li>
<li><p>注册一个属于自己的阿里云账户</p>
</li>
<li><p>获得加速器地址连接：</p>
<ol>
<li>登陆阿里云开发者平台</li>
<li>点击控制台</li>
<li>选择容器镜像服务</li>
<li>获取加速器地址</li>
</ol>
</li>
<li><p>粘贴脚本直接执行</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker </span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123; </span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;] </span><br><span class="line">&#125; </span><br><span class="line">EOF </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.png" class="" width="23">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 或者分开步骤执行</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启服务器</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-永远的HelloWorld"><a href="#2-5-2-永远的HelloWorld" class="headerlink" title="2.5.2 永远的HelloWorld"></a>2.5.2 永远的HelloWorld</h4><p>启动Docker后台容器（测试运行 hello-world）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24.png" class="" width="24">

<h4 id="2-5-3-底层原理"><a href="#2-5-3-底层原理" class="headerlink" title="2.5.3 底层原理"></a>2.5.3 底层原理</h4><p>为什么Docker会比VM虚拟机快:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">(1)docker有着比虚拟机更少的抽象层</span> <span class="string"></span></span><br><span class="line">   <span class="meta">由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</span> <span class="string"></span></span><br><span class="line"><span class="meta">(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核</span> <span class="string"></span></span><br><span class="line">   <span class="attr">当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.png" class="" width="25">

<h3 id="三、Docker常用命令"><a href="#三、Docker常用命令" class="headerlink" title="三、Docker常用命令"></a>三、Docker常用命令</h3><h4 id="3-1-帮助启动类命令"><a href="#3-1-帮助启动类命令" class="headerlink" title="3.1 帮助启动类命令"></a>3.1 帮助启动类命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动命令</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止命令</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启命令</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 docker 概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker 总体帮助文档</span></span><br><span class="line">docker --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker命令帮助文档：</span></span><br><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure>

<h4 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h4><h5 id="3-2-1-docker-images"><a href="#3-2-1-docker-images" class="headerlink" title="3.2.1 docker images"></a>3.2.1 docker images</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出本地主机上的镜像</span></span><br><span class="line">docker images </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/26.png" class="" width="26">

<p>各个选项说明: </p>
<ul>
<li><p>REPOSITORY：表示镜像的仓库源 </p>
</li>
<li><p>TAG：镜像的标签版本号 </p>
</li>
<li><p>IMAGE ID：镜像ID </p>
</li>
<li><p>CREATED：镜像创建时间 </p>
</li>
<li><p>SIZE：镜像大小 </p>
</li>
</ul>
<p> 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 </p>
<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像 </p>
<h5 id="3-2-2-OPTIONS-说明"><a href="#3-2-2-OPTIONS-说明" class="headerlink" title="3.2.2 OPTIONS 说明"></a>3.2.2 OPTIONS 说明</h5><p>-a :  列出本地所有的镜像（含历史映像层）</p>
<p>-q：只显示镜像ID</p>
<h5 id="3-2-3-docker-search-某个XXX镜像名字"><a href="#3-2-3-docker-search-某个XXX镜像名字" class="headerlink" title="3.2.3 docker search 某个XXX镜像名字"></a>3.2.3 docker search 某个XXX镜像名字</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 网站</span></span><br><span class="line">https://hub.docker.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker search [OPTIONS]镜像名字</span><br><span class="line"><span class="meta">#</span><span class="bash"> OPTIONS说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">limit</span> ：只列出N个镜像，默认25个</span></span><br><span class="line">docker search  --limit 5 redis</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/27.png" class="" width="27">

<h5 id="3-2-4-docker-pull-某个XXX镜像名字"><a href="#3-2-4-docker-pull-某个XXX镜像名字" class="headerlink" title="3.2.4 docker pull 某个XXX镜像名字"></a>3.2.4 docker pull 某个XXX镜像名字</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像</span></span><br><span class="line"> docker pull 镜像名字[:TAG]</span><br><span class="line"> </span><br><span class="line"> docker pull  镜像名字 </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 没有TAG就是最新版本 等价于</span></span><br><span class="line"> docker pull 镜像名字：latest</span><br><span class="line"> docker pull ubuntu </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/28.png" class="" width="28">

<h5 id="3-2-5-docker-system-df-查看镜像-容器-数据卷所占用的空间"><a href="#3-2-5-docker-system-df-查看镜像-容器-数据卷所占用的空间" class="headerlink" title="3.2.5 docker system df 查看镜像/容器/数据卷所占用的空间"></a>3.2.5 docker system df 查看镜像/容器/数据卷所占用的空间</h5><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/29.png" class="" width="29">

<h5 id="3-2-6-docker-rmi-删除镜像"><a href="#3-2-6-docker-rmi-删除镜像" class="headerlink" title="3.2.6 docker rmi 删除镜像"></a>3.2.6 docker rmi 删除镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除单个</span></span><br><span class="line">docker rmi -f 镜像ID</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除多个</span></span><br><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除全部</span></span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-7-谈谈docker虚悬镜像是什么？"><a href="#3-2-7-谈谈docker虚悬镜像是什么？" class="headerlink" title="3.2.7 谈谈docker虚悬镜像是什么？"></a>3.2.7 谈谈docker虚悬镜像是什么？</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">仓库名称，标签都是&lt;none&gt;的镜像，俗称虚悬镜像dangling</span> <span class="string">image</span></span><br><span class="line"><span class="attr">长什么样子</span></span><br><span class="line"><span class="attr">后续Dockerfile章节在介绍</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h4><blockquote>
<p>有镜像才能创建容器，这是根本前提（下载一个CentOS或者ubuntu镜像演示）</p>
<h5 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h5><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.png" class="" width="30">

<h5 id="2-docker-pull-centos"><a href="#2-docker-pull-centos" class="headerlink" title="2.docker pull centos"></a>2.docker pull centos</h5><h5 id="3-docker-pull-ubuntu"><a href="#3-docker-pull-ubuntu" class="headerlink" title="3.docker pull ubuntu"></a>3.docker pull ubuntu</h5><h5 id="4-本次演示用ubuntu演示"><a href="#4-本次演示用ubuntu演示" class="headerlink" title="4.本次演示用ubuntu演示"></a>4.本次演示用ubuntu演示</h5><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/31.png" class="" width="31">
</blockquote>
<h5 id="3-3-1-新建-启动容器"><a href="#3-3-1-新建-启动容器" class="headerlink" title="3.3.1 新建+启动容器"></a>3.3.1 新建+启动容器</h5><blockquote>
<h6 id="新建-启动容器-命令"><a href="#新建-启动容器-命令" class="headerlink" title="新建+启动容器 命令"></a>新建+启动容器 命令</h6><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<h6 id="OPTIONS说明"><a href="#OPTIONS说明" class="headerlink" title="OPTIONS说明"></a>OPTIONS说明</h6><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号 </p>
<p>–name=”容器新名字”       为容器指定一个名称；<br>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)； </p>
<p>-i：以交互模式运行容器，通常与 -t 同时使用；<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>也即 启动交互式容器(前台有伪终端，等待交互) ； </p>
<p>-P:  随机 端口映射，大写P<br>-p:  指定 端口映射，小写p </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/32.png" class="" width="32">
</blockquote>
<blockquote>
<p>启动交互式容器（前台命令行）</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/33.png" class="" width="33">

<p>使用镜像centos:latest以 交互模式 启动一个容器,在容器内执行/bin/bash命令。 </p>
<p><strong>docker run -it centos /bin/bash</strong> </p>
<p>参数说明： </p>
<ul>
<li><p>-i: 交互式操作。</p>
</li>
<li><p> -t: 终端。 </p>
</li>
<li><p>centos : centos 镜像。</p>
</li>
<li><p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 要退出终端，直接输入 exit: </p>
</li>
</ul>
</blockquote>
<h5 id="3-3-2-列出当前所有正在运行的容器"><a href="#3-3-2-列出当前所有正在运行的容器" class="headerlink" title="3.3.2 列出当前所有正在运行的容器"></a>3.3.2 列出当前所有正在运行的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有正在运行的容器</span></span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"><span class="meta">#</span><span class="bash"> OPTIONS说明</span></span><br><span class="line">-a : 列出当前所有 正在运行 的容器 + 历史上运行过 的 </span><br><span class="line">-l :显示最近创建的容器。 </span><br><span class="line">-n：显示最近n个创建的容器。 </span><br><span class="line">-q :静默模式，只显示容器编号。 </span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-退出容器"><a href="#3-3-3-退出容器" class="headerlink" title="3.3.3 退出容器"></a>3.3.3 退出容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 两种退出方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、run进去容器，<span class="built_in">exit</span>退出，容器停止</span></span><br><span class="line">exit </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、run进去容器，ctrl+p+q退出，容器不停止</span></span><br><span class="line">ctrl+p+q</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-启动已停止运行的容器"><a href="#3-3-4-启动已停止运行的容器" class="headerlink" title="3.3.4 启动已停止运行的容器"></a>3.3.4 启动已停止运行的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动已停止运行的容器</span></span><br><span class="line">docker start 容器ID或者容器名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器</span></span><br><span class="line">docker restart 容器ID或者容器名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop 容器ID或者容器名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制停止容器</span></span><br><span class="line">docker kill 容器ID或容器名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已停止的容器</span></span><br><span class="line">docker rm 容器ID</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性删除多个容器实例</span></span><br><span class="line">docker rm -rf $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure>

<h5 id="3-3-5-重要"><a href="#3-3-5-重要" class="headerlink" title="3.3.5 重要"></a>3.3.5 重要</h5><p><strong>启动守护式容器（后台服务器）：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">有镜像才能创建容器，这是根本前提（下载一个Redis6.0.8镜像演示）</span><br><span class="line"></span><br><span class="line">在大部分的场景下，我们希望docker的服务是在后台运行的，我们可以通过 -d 指定容器的后台运行模式。</span><br><span class="line"></span><br><span class="line">docker run -d 容器名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像centos:latest以后台模式启动一个容器</span> </span><br><span class="line">docker run -d centos </span><br><span class="line">  </span><br><span class="line">问题：然后docker ps -a 进行查看,  会发现容器已经退出 </span><br><span class="line">很重要的要说明的一点:  Docker容器后台运行,就必须有一个前台进程. </span><br><span class="line">容器运行的命令如果不是那些 一直挂起的命令 （比如运行top，tail），就是会自动退出的。 </span><br><span class="line">  </span><br><span class="line">这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下, </span><br><span class="line">我们配置启动服务只需要启动响应的service即可。例如service nginx start </span><br><span class="line">但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用, </span><br><span class="line">这样的容器后台启动后,会立即自杀因为他觉得他没事可做了. </span><br><span class="line">所以，最佳的解决方案是, 将你要运行的程序以前台进程的形式运行， </span><br><span class="line">常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>redis前后台启动演示case</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 前台交互式启动</span></span><br><span class="line">docker run -it redis:6.0.8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台交互式启动</span></span><br><span class="line">docker run -d redis:6.0.8</span><br></pre></td></tr></table></figure>

<p><strong>查看容器日志</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器日志</span></span><br><span class="line">docker logs 容器ID</span><br></pre></td></tr></table></figure>

<p><strong>查看容器内运行的进程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内运行的进程</span></span><br><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>

<p><strong>查看容器内部细节</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部细节</span></span><br><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<p><strong>进入正在运行的容器并以命令行交互</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID bashShell</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/34.png" class="" width="34">

<blockquote>
<p>重新进入docker attach 容器ID</p>
<p>案例演示，用centos或者unbuntu都可以<br><strong>上述两个区别：</strong></p>
<ol>
<li>attach 直接进入容器启动命令的终端，不会启动新的进程用exit退出，会导致容器的停止。</li>
</ol>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.png" class="" width="35">2. exec 是在容器中打开新的终端，并且可以启动新的进程用exit退出，不会导致容器的停止。

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36.png" class="" width="36">

<p>推荐大家使用docker exec 命令，因为退出容器终端，不会导致容器的停止。</p>
<p><strong>使用之前的redis容器实例进入试试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line">docker exec -it 容器ID redis-cli</span><br><span class="line"></span><br><span class="line">一般用-d后台启动的程序，在用exec进入对应容器实例</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>从容器内拷贝文件到主机上</strong></p>
<blockquote>
<p>容器 -&gt; 主机</p>
<p>docker cp 容器ID:容器内路径  目的主机路径</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/37.png" class="" width="37">

<p>公式： docker cp  容器 ID: 容器内路径  目的主机路径</p>
</blockquote>
<p><strong>导入和导出容器</strong></p>
<blockquote>
<p>Export 导出容器的内容留作为一个tar归档文件[对应import命令]</p>
<p>import 从tar 包中的内容创建一个新的文件系统在导入为镜像[对应export]</p>
<p>【案例】：</p>
<p>docker export 容器ID  &gt; 文件.tar </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/38.png" class="" width="38">

<p>cat 文件名.tar  | docker  import  -镜像用户/镜像名:镜像版本号</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/39.png" class="" width="39">
</blockquote>
<h4 id="3-4-小总结"><a href="#3-4-小总结" class="headerlink" title="3.4 小总结"></a>3.4 小总结</h4><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/40.png" class="" width="40">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像 </span><br><span class="line">build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像 </span><br><span class="line">commit    Create a new image from a container changes   # 提交当前容器为新的镜像 </span><br><span class="line">cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中 </span><br><span class="line">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器 </span><br><span class="line">diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化 </span><br><span class="line">events    Get real time events from the server          # 从 docker 服务获取容器实时事件 </span><br><span class="line">exec      Run a command in an existing container        # 在已存在的容器上运行命令 </span><br><span class="line">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ] </span><br><span class="line">history   Show the history of an image                  # 展示一个镜像形成历史 </span><br><span class="line">images    List images                                   # 列出系统当前镜像 </span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export] </span><br><span class="line">info      Display system-wide information               # 显示系统相关信息 </span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息 </span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器 </span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save] </span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器 </span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出 </span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息 </span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口 </span><br><span class="line">pause     Pause all processes within a container        # 暂停容器 </span><br><span class="line">ps        List containers                               # 列出容器列表 </span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像 </span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器 </span><br><span class="line">restart   Restart a running container                   # 重启运行的容器 </span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器 </span><br><span class="line">rmi       Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] </span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令 </span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load] </span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像 </span><br><span class="line">start     Start a stopped containers                    # 启动容器 </span><br><span class="line">stop      Stop a running containers                     # 停止容器 </span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签 </span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息 </span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器 </span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号 </span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值 </span><br></pre></td></tr></table></figure>

<h3 id="四、Docker镜像"><a href="#四、Docker镜像" class="headerlink" title="四、Docker镜像"></a>四、Docker镜像</h3><h4 id="4-1-是什么"><a href="#4-1-是什么" class="headerlink" title="4.1 是什么"></a>4.1 是什么</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">【镜像】</span> <span class="string"></span></span><br><span class="line"><span class="meta">是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</span> <span class="string"></span></span><br><span class="line"><span class="attr">只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">【分层镜像】</span></span><br><span class="line"><span class="meta">以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</span> <span class="string">。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">【UnionFS（联合文件系统）】</span></span><br><span class="line"><span class="meta">UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持</span> <span class="string">对文件系统的修改作为一次提交来一层层的叠加， 同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承 ，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</span> <span class="string"></span></span><br></pre></td></tr></table></figure>

<p><strong>Docker镜像加载原理</strong></p>
<blockquote>
<p> Docker镜像加载原理： </p>
<p> docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 </p>
<p> bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是引导文件系统bootfs。 这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 </p>
<p> rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。  </p>
 <img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/41.png" class="" width="41">

<p> 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ </p>
 <img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/42.png" class="" width="42">

<p> 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 </p>
</blockquote>
<p><strong>为什么Docker镜像要采用这种分层结构呢</strong></p>
<blockquote>
<p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。 </p>
<p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；<br>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
</blockquote>
<h4 id="4-2-重点理解"><a href="#4-2-重点理解" class="headerlink" title="4.2 重点理解"></a>4.2 重点理解</h4><blockquote>
<p>Docker镜像层都是只读的，容器层是可写的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作”容器层”，”容器层”之下的都叫”镜像层”。</p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/43.png" class="" width="43">
</blockquote>
<h4 id="4-3-Docker镜像commit操作案例"><a href="#4-3-Docker镜像commit操作案例" class="headerlink" title="4.3 Docker镜像commit操作案例"></a>4.3 Docker镜像commit操作案例</h4><blockquote>
<p>docker commit 提交容器副本使之成为一个新的镜像</p>
<p>docker commit -m=”提交的描述信息” -a=”作者” 容器ID  要创建的目标镜像名:[标签名]</p>
<p>【案例演示】ubuntu安装vim</p>
<ol>
<li>从Hub上下ubuntu镜像到笨地并成功运行</li>
<li>原始默认Ubuntu镜像是不带着vim命令的</li>
<li>外网连通情况下，安装vim</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先更新我们的包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后安装我们需要的vim</span></span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<p>docker容器内执行上述两条命令： </p>
<p>apt-get update </p>
<p>apt-get -y install vim </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/44.png" class="" width="44">

<ol start="4">
<li><p>安装完成后，commit我们自己的新镜像</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/45.png" class="" width="45"></li>
<li><p>启动我们的新镜像并和原来的对比</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/46.png" class="" width="46">

<p>官网是默认下载的Ubuntu没有vim命令 </p>
<p>我们自己commit构建的镜像，新增加了vim功能，可以成功使用。 </p>
</li>
</ol>
</blockquote>
<p><strong>总结</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> Docker中的镜像分层， 支持通过扩展现有镜像，创建新的镜像 。类似Java继承于一个Base基础类，自己再按需扩展。 </span><br><span class="line">新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层 </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/47.png" class="" width="47">

<h3 id="五、本地镜像发布到阿里云"><a href="#五、本地镜像发布到阿里云" class="headerlink" title="五、本地镜像发布到阿里云"></a>五、本地镜像发布到阿里云</h3><h4 id="5-1-本地镜像发布到阿里云流程"><a href="#5-1-本地镜像发布到阿里云流程" class="headerlink" title="5.1 本地镜像发布到阿里云流程"></a>5.1 本地镜像发布到阿里云流程</h4><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/48.png" class="" width="48">

<h4 id="5-2-镜像生成的方法"><a href="#5-2-镜像生成的方法" class="headerlink" title="5.2 镜像生成的方法"></a>5.2 镜像生成的方法</h4><blockquote>
<p>上一讲已经介绍过</p>
<p>基于当前容器创建一个新的镜像，新功能增强</p>
<p>docker commit [OPTIONS]容器ID [REPOSOTORY[:TAG]]</p>
<p><strong>OPTIONS说明：</strong> </p>
<p>-a :提交的镜像作者； </p>
<p>-m :提交时的说明文字； </p>
<p>本次案例centos+ubuntu两个，当堂讲解一个，家庭作业一个，请大家务必动手，亲自实操。 </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/49.png" class="" width="49">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/50.png" class="" width="50">
</blockquote>
<h4 id="5-3-将本地镜像推送到阿里云"><a href="#5-3-将本地镜像推送到阿里云" class="headerlink" title="5.3 将本地镜像推送到阿里云"></a>5.3 将本地镜像推送到阿里云</h4><blockquote>
<p><strong>本地镜像素材原型</strong></p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51.png" class="" width="51">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/52.png" class="" width="52">

<p><strong>阿里云开发者平台</strong></p>
<p>地址：<a href="https://promotion.aliyun.com/ntms/act/kubernetes.html">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></p>
<p><strong>将镜像推送到阿里云</strong></p>
<p>将镜像推送到阿里云registry ，管理界面脚本</p>
<p><strong>脚本实例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login --username=zzyybuy registry.cn-hangzhou.aliyuncs.com </span><br><span class="line"></span><br><span class="line">docker tag cea1bb40441c registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 </span><br><span class="line"></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 </span><br><span class="line"></span><br><span class="line">上面命令是阳哥自己本地的，你自己酌情处理，不要粘贴我的。 </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/53.png" class="" width="53">
</blockquote>
<h4 id="5-4-将阿里云上的镜像下载到本地"><a href="#5-4-将阿里云上的镜像下载到本地" class="headerlink" title="5.4 将阿里云上的镜像下载到本地"></a>5.4 将阿里云上的镜像下载到本地</h4><img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/54.png" class="" width="54">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 </span><br></pre></td></tr></table></figure>

<h3 id="六、本地镜像发布到私有库"><a href="#六、本地镜像发布到私有库" class="headerlink" title="六、本地镜像发布到私有库"></a>六、本地镜像发布到私有库</h3><h4 id="6-1-本地镜像发布到私有库流程"><a href="#6-1-本地镜像发布到私有库流程" class="headerlink" title="6.1 本地镜像发布到私有库流程"></a>6.1 本地镜像发布到私有库流程</h4><blockquote>
<ol>
<li><p>下载镜像Docker Registry</p>
<p>docker pull registry  </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/55.png" class="" width="55">

<ol start="2">
<li><p>运行私有库Registry，相当于本地有个私有库Docker hub</p>
<p>docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry –privileged=true registry </p>
<p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/56.png" class="" width="56"></li>
<li><p>案例演示创建一个新镜像，ubuntu安装ifconfig命令</p>
<p>从Hub上下载ubuntu镜像到本地并成功运行</p>
<p> 原始Ubuntu镜像是不带着ifconfig命令的</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/57.png" class="" width="57">

<p>从Hub上下载ubuntu镜像到本地并成功运行</p>
<p> 原始Ubuntu镜像是不带着ifconfig命令的</p>
<p><strong>外网连通情况下，安装ifconfig命令通过测试</strong></p>
<p>docker容器内 执行上述两条命令： </p>
<p>apt-get update </p>
<p>apt-get install net-tools </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/58.png" class="" width="58">

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/59.png" class="" width="59">

<p><strong>安装完成后，commit我们自己的新镜像</strong></p>
<p>公式： </p>
<p>docker commit -m=” 提交的描述信息 “ -a=” 作者 “ 容器 ID 要创建的目标镜像名 :[ 标签名 ] </p>
<p>命令： 在容器外执行，记得 </p>
<p>docker commit -m=” ifconfig cmd add “ -a=” zzyy “ a69d7c825c4f zzyyubuntu:1.2 </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/60.png" class="" width="60">

<p><strong>启动我们的新镜像并和原来的对比</strong></p>
<p>1.官网是默认下载的Ubuntu没有ifconfig命令 </p>
<p>2.我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/61.png" class="" width="61"></li>
<li><p>curl验证私服库上有什么镜像</p>
<p> curl -XGET <a href="http://192.168.111.162:5000/v2/_catalog">http://192.168.111.162:5000/v2/_catalog</a> </p>
<p>可以看到，目前私服库没有任何镜像上传过。。。。。。 </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/62.png" class="" width="62"></li>
<li><p>将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">按照公式： docker   tag   镜像:Tag   Host:Port/Repository:Tag </span><br><span class="line">自己host主机IP地址，填写同学你们自己的，不要粘贴错误，O(∩_∩)O </span><br><span class="line">使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000/zzyyubuntu:1.2 </span><br><span class="line">   </span><br><span class="line">docker tag  zzyyubuntu:1.2  192.168.111.162:5000/zzyyubuntu:1.2 </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/63.png" class="" width="63"></li>
</ol>
<ol start="6">
<li>修改配置文件使之支持http</li>
</ol>
   <img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/64.png" class="" width="64">

   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">别无脑照着复制，registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。</span><br><span class="line">2个配置中间有个逗号 &#x27;,&#x27;别漏了 ，这个配置是json格式的。 </span><br><span class="line">2个配置中间有个逗号 &#x27;,&#x27;别漏了 ，这个配置是json格式的。 </span><br><span class="line">2个配置中间有个逗号 &#x27;,&#x27;别漏了 ，这个配置是json格式的。 </span><br></pre></td></tr></table></figure>

<p>   vim命令新增如下红色内容：vim /etc/docker/daemon.json </p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;] , </span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.111.162:5000&quot;] </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>   上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt;  修改完后如果不生效，建议重启docker </p>
<ol start="7">
<li><p>push推送到私服库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push 192.168.111.162:5000/zzyyubuntu:1.2 </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/65.png" class="" width="65"></li>
<li><p>curl验证私服库上有什么镜像2</p>
<p>curl -XGET <a href="http://192.168.111.162:5000/v2/_catalog">http://192.168.111.162:5000/v2/_catalog</a> </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/66.png" class="" width="66"></li>
<li><p>pull到本地并运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.111.162:5000/zzyyubuntu:1.2 </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/67.png" class="" width="67">

<p>docker run -it 镜像ID /bin/bash </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/68.png" class="" width="68"></li>
</ol>
</blockquote>
<h3 id="七、Docker容器数据卷"><a href="#七、Docker容器数据卷" class="headerlink" title="七、Docker容器数据卷"></a>七、Docker容器数据卷</h3><h4 id="7-1-坑：容器卷记得加入"><a href="#7-1-坑：容器卷记得加入" class="headerlink" title="7.1 坑：容器卷记得加入"></a>7.1 坑：容器卷记得加入</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--privileged=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原因</span></span><br><span class="line">  Docker挂载主机目录访问 如果出现cannot open directory .: Permission denied </span><br><span class="line">解决办法：在挂载目录后多加一个--privileged=true参数即可 </span><br><span class="line">  </span><br><span class="line">如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为， </span><br><span class="line">在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用--privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即 </span><br><span class="line">使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-2-回顾下上一将的知识点，参数V"><a href="#7-2-回顾下上一将的知识点，参数V" class="headerlink" title="7.2 回顾下上一将的知识点，参数V"></a>7.2 回顾下上一将的知识点，参数V</h4><p>还记得蓝色框框中的内容嘛</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/69.png" class="" width="69">

<h4 id="7-3-是什么"><a href="#7-3-是什么" class="headerlink" title="7.3 是什么"></a>7.3 是什么</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一句话：有点类似我们Redis里面的rdb和aof文件</span><br><span class="line">将docker容器内的数据保存进宿主机的磁盘中</span><br><span class="line">运行一个带有容器卷存储功能的容器实例</span><br><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录      镜像名</span><br></pre></td></tr></table></figure>

<h4 id="7-4-能干什么"><a href="#7-4-能干什么" class="headerlink" title="7.4 能干什么"></a>7.4 能干什么</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是 持久化的 </span><br><span class="line"> </span><br><span class="line">Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。 </span><br><span class="line">为了能保存数据在docker中我们使用卷。 </span><br><span class="line">  </span><br><span class="line">特点： </span><br><span class="line">1：数据卷可在容器之间共享或重用数据 </span><br><span class="line">2：卷中的更改可以直接实时生效，爽 </span><br><span class="line">3：数据卷中的更改不会包含在镜像的更新中 </span><br><span class="line">4：数据卷的生命周期一直持续到没有容器使用它为止 </span><br></pre></td></tr></table></figure>

<h4 id="7-5-数据卷案例"><a href="#7-5-数据卷案例" class="headerlink" title="7.5 数据卷案例"></a>7.5 数据卷案例</h4><blockquote>
<h5 id="7-5-1-宿主vs容器之间映射添加容器卷"><a href="#7-5-1-宿主vs容器之间映射添加容器卷" class="headerlink" title="7.5.1 宿主vs容器之间映射添加容器卷"></a>7.5.1 宿主vs容器之间映射添加容器卷</h5><p><strong>直接命令添加</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">公式：docker run -it -v /宿主机目录:/容器内目录</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ubuntu /bin/bash</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -it --name myu3 --privileged=<span class="literal">true</span> -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash</span> </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.png" class="" width="70">

<p><strong>查看数据卷是否挂成功</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker inspect 容器ID </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/71.png" class="" width="71">

<p><strong>容器和宿主机之间数据共享</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1. docker修改，主机同步获得  </span><br><span class="line">&gt;2. 主机修改，docker同步获得 </span><br><span class="line">&gt;3. docker容器stop，主机修改，docker容器重启看数据是否同步。</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/72.png" class="" width="72">
</blockquote>
<blockquote>
<h5 id="7-5-2-读写规则映射添加说明"><a href="#7-5-2-读写规则映射添加说明" class="headerlink" title="7.5.2 读写规则映射添加说明"></a>7.5.2 读写规则映射添加说明</h5><p><strong>读写(默认)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw  镜像名</span><br><span class="line">默认同上案例，默认就是rw</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/73.png" class="" width="73">

<p>默认同上案例，默认就是rw</p>
</blockquote>
<blockquote>
<p><strong>只读</strong></p>
<p>容器实例内部被限制，只能读取不能写</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/74.png" class="" width="74">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/容器目录:ro 镜像名               就能完成功能，此时容器自己只能读取不能写   </span><br><span class="line">ro = read only </span><br><span class="line">此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro      镜像名</span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<h5 id="7-5-3-卷的集成和共享"><a href="#7-5-3-卷的集成和共享" class="headerlink" title="7.5.3 卷的集成和共享"></a>7.5.3 卷的集成和共享</h5><p>容器1完成和宿主机的映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -it --privileged=<span class="literal">true</span> -v /mydocker/u:/tmp --name u1 ubuntu</span> </span><br></pre></td></tr></table></figure>



<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/75.png" class="" width="75">

<p>容器2集成容器1的卷规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -it --privileged=<span class="literal">true</span> --volumes-from 父类 --name u2 ubuntu</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="八、Docker常规安装简介"><a href="#八、Docker常规安装简介" class="headerlink" title="八、Docker常规安装简介"></a>八、Docker常规安装简介</h3><h4 id="8-1-总体步骤"><a href="#8-1-总体步骤" class="headerlink" title="8.1 总体步骤"></a>8.1 总体步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 搜索镜像</span><br><span class="line">2. 拉去镜像</span><br><span class="line">3. 查看镜像</span><br><span class="line">4. 查看镜像</span><br><span class="line">5. 启动镜像</span><br><span class="line">	 服务端口映射</span><br><span class="line">6. 停止容器</span><br></pre></td></tr></table></figure>

<h4 id="8-2-安装tomcat"><a href="#8-2-安装tomcat" class="headerlink" title="8.2 安装tomcat"></a>8.2 安装tomcat</h4><blockquote>
<p>1、docker hub 上面查找tomcat镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure>

<p>2、从docker hub 上拉去tomcat镜像到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<p>3、docker images 查看是否有拉去到tomcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker images tomcat</span><br></pre></td></tr></table></figure>

<p>4、使用tomcat镜像创建容器实例（也叫运行镜像）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker run -it -p 8080:8080 tomcat</span><br><span class="line"></span><br><span class="line">-p 小写，主机端口:docker容器端口</span><br><span class="line"></span><br><span class="line">-P 大写，随机分配端口</span><br><span class="line"></span><br><span class="line">i:交互</span><br><span class="line"></span><br><span class="line">t:终端</span><br><span class="line"></span><br><span class="line">d:后台</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、访问tomcat首页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可能出现404 的情况</span><br><span class="line"></span><br><span class="line">解决</span><br><span class="line"></span><br><span class="line">1、可能没有映射端口或者没有关闭防火墙</span><br><span class="line">2、把webapps.dist 目录换成webapps </span><br><span class="line">	先成功启动tomcat</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/76.png" class="" width="76">

<p>查看webapps文件夹查看为空</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/77.png" class="" width="77">

<p>6、免修改版说明</p>
<p>docker pull billygoo/tomcat8-jdk8</p>
<p>Docker run -d -p 8080:8080 –name mytomcat8 billygoo/tomcat8-djk8</p>
</blockquote>
<h4 id="8-3-安装mysql"><a href="#8-3-安装mysql" class="headerlink" title="8.3 安装mysql"></a>8.3 安装mysql</h4><blockquote>
<p>1、docker hub上面查找mysql镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<p>2、从docker hub上（阿里云加速器）拉去mysql镜像到本地标签为5.7 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>3、使用mysql5.7 镜像创建容器（也叫运行镜像）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、命令出处，哪里来的</span></span><br><span class="line">地址：https://hub.docker.com/_/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、简单版</span></span><br><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 </span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/78.png" class="" width="78">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 4、 建库建表插入数据</span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/79.png" class="" width="79">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">外部Win10也来连接运行在dokcer上的mysql容器实例服务</span><br><span class="line">【问题】</span><br><span class="line">插入中文数据试试，为什么报错？ docker 上默认字符集编码隐患</span><br><span class="line"></span><br><span class="line">docker里面的mysql容器实例查看，内容如下： </span><br><span class="line">SHOW VARIABLES LIKE &#x27;character%&#x27; </span><br><span class="line"></span><br><span class="line">删除容器后，里面的mysql数据如何办</span><br><span class="line"></span><br><span class="line">容器实例一删除，你还有什么？</span><br><span class="line">删容器到跑路。。。。。？</span><br></pre></td></tr></table></figure>

<p>【实战版】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、新建mysql容器实例</span></span><br><span class="line">docker run -d -p 3306:3306 --privileged=true -v /zzyyuse/mysql/log:/var/log/mysql -v /zzyyuse/mysql/data:/var/lib/mysql -v /zzyyuse/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql mysql:5.7 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">2、新建my.cnf  通过容器卷同步给MySQL容器实例</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8 </span><br><span class="line">[mysqld] </span><br><span class="line">collation_server = utf8_general_ci </span><br><span class="line">character_set_server = utf8 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">3、重新启动mysql容器实例在重新进入并查看字符编码</span></span><br><span class="line">docker restart mysql</span><br><span class="line"></span><br><span class="line">docker exec -it mysql_bash</span><br><span class="line"></span><br><span class="line">show variables like &#x27;character%&#x27;;</span><br><span class="line"><span class="meta">#</span><span class="bash">4、再新建库新建表再插入中文测试</span></span><br><span class="line">完全正常</span><br><span class="line"><span class="meta">#</span><span class="bash">5、结论</span></span><br><span class="line">之前的DB  无效 </span><br><span class="line">修改字符集操作+重启mysql容器实例 </span><br><span class="line">之后的DB  有效，需要新建 </span><br><span class="line">结论： docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据 </span><br><span class="line"><span class="meta">#</span><span class="bash">6、假如将当前容器实例删除，再重新来一次，之前建的db01实例还有吗？trytry</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="8-4-安装redis"><a href="#8-4-安装redis" class="headerlink" title="8.4 安装redis"></a>8.4 安装redis</h4><blockquote>
<p>1、从docker hub上（阿里云加速器）拉去redis镜像到本地标签6.0.8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 拉去镜像</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker pull redis:6.0.8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 查看镜像</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker images</span></span><br></pre></td></tr></table></figure>

<p>2、入门命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 启动命令</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker run -d -p 6379:6379 redis:6.0.8</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># docker ps</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 后台启动</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">docker <span class="built_in">exec</span> -it CONTAINER ID /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>3、命令提醒：容器卷记得加入 –privileged=true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied </span><br><span class="line">&gt;解决办法：在挂载目录后多加一个--privileged=true参数即可 </span><br></pre></td></tr></table></figure>

<p>4、在CentOS宿主机下新建目录/app/redis </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 新建目录</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir -p /app/redis</span></span><br></pre></td></tr></table></figure>

<p>5、将一个redis.conf文件模板拷贝进 /app/redis目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir -p /app/redis</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp /myredis/redis.conf  /app/redis/</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp /app/redis</span></span><br></pre></td></tr></table></figure>

<p>6、/app/redis 目录下修改redis.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 修改redis.conf文件</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">/app/redis目录下修改redis.conf文件</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">开启redis验证     可选</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">requirepass 123</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">允许redis外地连接  必须</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">注释掉 <span class="comment"># bind 127.0.0.1</span></span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 注释daemonize no</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">daemonize no</span> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># 开启redis数据持久化</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">appendonly yes  可选</span> </span><br></pre></td></tr></table></figure>

<p>7、使用redis6.0.8 镜像创建容器(也叫运行镜像)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">docker run  -p 6379:6379 --name myr3 --privileged=<span class="literal">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</span> </span><br></pre></td></tr></table></figure>

<p>8、测试redis-cli连接上</p>
<p>docker exec -it 运行着Rediis服务的容器ID redis-cli </p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/81.png" class="" width="81">

<p>9、请证明docker启动使用了我们自己指定的配置文件</p>
<p>【修改前】</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/82.png" class="" width="82">

<p>【修改后】</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/83.png" class="" width="83">

<p>10、测试redis-cli连接上来第2次</p>
<img src="/2022/02/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/84.png" class="" width="84">
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1gr4y1U7CY?p=88">原视频地址</a></p>
<p><a href="https://gitee.com/yooome/golang">原文章地址</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记</title>
    <url>/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr>
<span id="more"></span>

<h3 id="Redis学习笔记"><a href="#Redis学习笔记" class="headerlink" title="Redis学习笔记"></a>Redis学习笔记</h3><h4 id="一-、Redis简介"><a href="#一-、Redis简介" class="headerlink" title="一 、Redis简介"></a>一 、Redis简介</h4><h5 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis"></a>1.1 什么是Redis</h5><p>Redis 是完全开源免费的，遵守<strong>BSD</strong>协议，是一个高性能(<strong>NOSQL</strong>)的key-value<strong>数据库</strong>*，Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存可持久化的日志型，Key-Value数据库，并提供多种语言的API。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">BSD是&quot;Berkeley Software Distribution&quot;的缩写，意思是“伯克利软件发型版本”。</span><br><span class="line">BSD开源协议是一个给予使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件在发布。BSD代码鼓励代码共享，但需要尊重代码作者的著作权。</span><br><span class="line">BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，一次是对商业集成很友好的协议。</span><br></pre></td></tr></table></figure>

<h5 id="1-2-NoSQL"><a href="#1-2-NoSQL" class="headerlink" title="1.2 NoSQL"></a>1.2 NoSQL</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">NoSQL,泛指非关系型的数据库，NoSQL即Not-only SQL,它可以作为关系型数据库的良好补充。随着互谅网web2.0网站的兴起，非关系型的数据库现在成为了一个及其热门的新领域，非关系型数据库产品的发展非常迅速。</span><br></pre></td></tr></table></figure>

<p>传统数据库暴露很多难以克服的问题，如下问题：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、High performance - 对数据库高并发读写的需求。</span><br><span class="line"></span><br><span class="line">2、Huge Storage - 对海量数据的高效存储和访问的需求。</span><br><span class="line"></span><br><span class="line">3、High Scalability &amp;&amp; High Availability - 对数据库的高可扩展性和高课用性的需求。</span><br></pre></td></tr></table></figure>

<h5 id="1-3-NoSQL的类别"><a href="#1-3-NoSQL的类别" class="headerlink" title="1.3 NoSQL的类别"></a>1.3 NoSQL的类别</h5><p><strong>键值（Key-Value）存储数据库</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。</span><br><span class="line">key/value模型对于IT系统涞水的优势在于简单，已部署。但是如果DBA只对部分值进行查询或者更新的时候，key/value显示的效率低下。</span><br><span class="line">相关产品 ： Redis，Tokyo Cabinet</span><br><span class="line">典型应用 ： 内存缓存，主要用于处理大量数据的高访问负载。</span><br><span class="line">数据模型 ： 一系列键值对</span><br><span class="line">优势 ： 快速查询</span><br><span class="line">劣势 ： 存储的数据缺少结构化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>列存储数据库</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">这部分数据库通常是用来对分布式存储的海量数据。键仍然存在，但是他们的特点是指向了多个列。这些列是由列家族来安排的。</span><br><span class="line">相关产品 : HBase 、Riak</span><br><span class="line">典型应用 ： 分布式的文件系统</span><br><span class="line">数据模型 ： 以列簇式存储，将同一列数据存在一起</span><br><span class="line">优势 ： 查找速度快，可扩展性强，更容易进行分布式扩展</span><br><span class="line">劣势 ： 功能相对于局限</span><br></pre></td></tr></table></figure>

<p><strong>文档型数据库</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">文档型数据库：该类型的数据库模型是版本化的文档，半结构化的文档一特定的格式存储，比如JSON。文档数据库可以看做键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。</span><br><span class="line">相关产品：MOngoDB</span><br><span class="line">典型应用 ： web应用</span><br><span class="line">数据模型 ： 一系列键值对</span><br><span class="line">优势 ： 数据结构要求不严格</span><br><span class="line">劣势 ： 查询性能不高，而且缺乏统一的查询语言</span><br></pre></td></tr></table></figure>

<h5 id="1-4-总结："><a href="#1-4-总结：" class="headerlink" title="1.4 总结："></a>1.4 总结：</h5><p>NoSQL 数据库在一下的这几种情况下比较适用 ：</p>
<p>1、数据模型比较简单；</p>
<p>2、需要灵活更前的IT系统；</p>
<p>3、对数据库性能要求较高；</p>
<p>4、不需要高度的数据一致性；</p>
<p>5、对于给定key，比较容易映射复杂的环境；</p>
<h5 id="1-5-Redis-描述"><a href="#1-5-Redis-描述" class="headerlink" title="1.5 Redis 描述"></a>1.5 Redis 描述</h5><pre><code>Redis是完全开源免费的，遵守BSD协议，是一个高性能(NoSQL)的（key-value）数据库，Redis是一个开源的使用ANSI C语言编写，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。
</code></pre>
<h5 id="1-6-Redis的特点"><a href="#1-6-Redis的特点" class="headerlink" title="1.6 Redis的特点"></a>1.6 Redis的特点</h5><ul>
<li> <strong>性能极高</strong> - Redis读写的熟读110000次/s，写的速度是81000次/s。</li>
<li><strong>丰富的数据类型</strong> - Redis支持的类型String， Hash 、List 、Set 及 Ordered Set数据类型操作。</li>
<li><strong>原子性</strong>  - Redis的所有操作都是原子性的，意思就是要么成功，要么失败。单个操作时原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li><strong>丰富的特性</strong> - Redis还支持publis/subscribe，通知，key过期等等特性。</li>
<li><strong>高速读写</strong> ，redis使用自己实现的分离器，代码量很短，没有使用lock(MySQL),因此效率非常高。</li>
</ul>
<p>Redis是一个简单的，高效的，分布式的，基于内存的缓存工具。</p>
<p>架设好服务器后，通过网络连接(类似数据库)，提供Key-Value缓存服务。</p>
<p>简单，是Redis突出的特色。</p>
<p>简单可以保证核心功能的稳定和优异。</p>
<h5 id="1-7-Redis的应用场景"><a href="#1-7-Redis的应用场景" class="headerlink" title="1.7 Redis的应用场景"></a>1.7 Redis的应用场景</h5><p><strong>可以作为数据库，缓存，热点数据(经常别查询，但是不经常被修改或者删除的数据)和消息中间件等大部分功能。</strong></p>
<p>Redis常用的场景示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、缓存</span><br><span class="line">   缓存现在几乎是所有大中型网站都在用的必杀技，合理利用缓存提升网站的访问速度，还能大大降低数据库的访问压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</span><br><span class="line">2、排行榜</span><br><span class="line">   Redis提供的有序集合数据类结构能够实现葛洪复杂的排行榜应用。</span><br><span class="line">3、计数器</span><br><span class="line">   什么是计数器，，视频网站的播放量等等，每次浏览+1，并发量高时如果每次都请求数据库操作无疑是中挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常是用于这些技术场景。</span><br><span class="line">4、分布式会话</span><br><span class="line">   集群模式下，在应用不多的情况下一般使用容日自带的session复制功能就能够满足，当应用相对复杂的系统中，一般都会搭建Redis等内存数据库为中心的session服务，session不在由容器管理，而是有session服务及内存数据管理。</span><br><span class="line">5、分布式锁</span><br><span class="line">   在很多互联网公司中都是用来分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID，减库存，秒杀等场景，并发量不发的场景可以使用数据库的悲观锁，乐观锁来实现，但是在并发高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1，说明获取所成功，否则获取锁失败，实际应用中药考虑的细节要更多。</span><br><span class="line">6、社交网络</span><br><span class="line">   点赞、踩、关注/被关注，共同好友等是社交网站的基本功能，社交网站的访问量通常老说比较大，而且传统的关系数据库不适合这种类型的数据，Redis提供的哈希，集合等数据结构能很方便的实现这些功能。</span><br><span class="line">7、最新列表</span><br><span class="line">   Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可以用来限制列表的数量，这样列表永远为N个ID。无需查询最新的列表，直接根据ID 去到对应的内容也即可。</span><br><span class="line">8、消息系统</span><br><span class="line">   消息对队列是网站比用中间件，如ActiveMQ，RabbitMQ，Kafaka等流行的消息队列中间件，主要用于业务解耦，流量削峰及异步处理试试性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能喝专业的消息中间件相比。</span><br></pre></td></tr></table></figure>

<h5 id="1-8-Redis总结"><a href="#1-8-Redis总结" class="headerlink" title="1.8  Redis总结"></a>1.8  Redis总结</h5><p><strong>优势</strong> </p>
<ul>
<li> <strong>性能极高</strong> - Redis读写的熟读110000次/s，写的速度是81000次/s。</li>
<li><strong>丰富的数据类型</strong> - Redis支持的类型String， Hash 、List 、Set 及 Ordered Set数据类型操作。</li>
<li><strong>原子性</strong>  - Redis的所有操作都是原子性的，意思就是要么成功，要么失败。单个操作时原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li><strong>丰富的特性</strong> - Redis还支持publis/subscribe，通知，key过期等等特性。</li>
<li><strong>高速读写</strong> ，redis使用自己实现的分离器，代码量很短，没有使用lock(MySQL),因此效率非常高。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>持久化</strong>。 Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以使用两种方式实现持久化过程。定时快照(snapshot)：每个一端时间将整个数据库写到磁盘上，每次均是写全部数据，代价非常高。第二种方式基于语句追加（aof）：只追踪变化的数据，但是追加的log可能过大，同时所有的操作均重新执行一遍，<strong>回复速度慢</strong>。</li>
<li><strong>耗内存</strong>  、占用内存过高。</li>
</ul>
<h4 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h4><h5 id="2-1-Redis官网"><a href="#2-1-Redis官网" class="headerlink" title="2.1 Redis官网"></a>2.1 Redis官网</h5><p>官方网站 ： <a href="https://redis.io/">https://redis.io/</a></p>
<p>官方下载 ： <a href="https://redis.io/download">https://redis.io/download</a> 可以根据需要下载不同版本</p>
<h5 id="2-2-Redis-安装"><a href="#2-2-Redis-安装" class="headerlink" title="2.2 Redis 安装"></a>2.2 Redis 安装</h5><p>Redis是C语言开发，安装Redis需要先将官网下载的源码进行编译。编译依赖gcc环境，如果没有gcc环境，需要安装gcc</p>
<h5 id="2-3-安装gcc"><a href="#2-3-安装gcc" class="headerlink" title="2.3 安装gcc"></a>2.3 安装gcc</h5><p>gcc的安装很简单，首先要确保root登录，其次就是Linux要能连外网</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">yum -y install gcc automake autoconf libtool make</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 运行yum是出现/var/run/yum.pid已被锁定，PID为xxxx的另外一个程序正在运行的问题解决。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">rm -f /var/run/yum.pid</span><br></pre></td></tr></table></figure>

<h5 id="2-4-安装Redis"><a href="#2-4-安装Redis" class="headerlink" title="2.4 安装Redis"></a>2.4 安装Redis</h5><p><strong>下载redis二进制安装包</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/release/redis-6.0.5.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>解压/apps目录下</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">tar zxvf redis-6.0.5.tar.gz -C /apps</span><br><span class="line">#Linux 中剪切命令</span><br><span class="line">mv redis-6.0.5.tar.gz 安装包</span><br><span class="line">#Linux中复制命令: cp Files path</span><br><span class="line">cp redis-6.0.5.tar.gz /root/apps</span><br></pre></td></tr></table></figure>

<p>进入redis中使用make命令进行编译</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@centos redis-5.0.8]# make MALLOC=libc</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    LINK redis-cli</span><br><span class="line">    CC redis-benchmark.o</span><br><span class="line">    LINK redis-benchmark</span><br><span class="line">    INSTALL redis-check-rdb</span><br><span class="line">    INSTALL redis-check-aof</span><br><span class="line"></span><br><span class="line">Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)</span><br><span class="line"></span><br><span class="line">make[1]: 离开目录“/root/apps/redis-5.0.8/src”</span><br><span class="line">[root@centos redis-5.0.8]# ll</span><br></pre></td></tr></table></figure>

<p><strong>安装成功如上</strong></p>
<h5 id="2-5-安装到指定的位置"><a href="#2-5-安装到指定的位置" class="headerlink" title="2.5 安装到指定的位置"></a>2.5 安装到指定的位置</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">make PREFIX=/root/apps/redis install</span><br></pre></td></tr></table></figure>

<p>（安装编译后的文件）安装到指定目录；</p>
<p>注意：PREFIX必须为大写，同时会自动为我们创建redis目录，并将结果安装此目录；</p>
<h4 id="三-、Redis启动"><a href="#三-、Redis启动" class="headerlink" title="三 、Redis启动"></a>三 、Redis启动</h4><h5 id="3-1-启动Redis服务端，进入到Redis的安装目录"><a href="#3-1-启动Redis服务端，进入到Redis的安装目录" class="headerlink" title="3.1 启动Redis服务端，进入到Redis的安装目录"></a>3.1 启动Redis服务端，进入到Redis的安装目录</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis</span><br></pre></td></tr></table></figure>

<h5 id="3-2-执行命令"><a href="#3-2-执行命令" class="headerlink" title="3.2 执行命令"></a>3.2 执行命令</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./bin/redis-server</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200701230641144.png" class="" title="image-20200701230641144">

<h5 id="3-3-Redis的客户端进行启动"><a href="#3-3-Redis的客户端进行启动" class="headerlink" title="3.3 Redis的客户端进行启动"></a>3.3 Redis的客户端进行启动</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./bin/redis-cli</span><br></pre></td></tr></table></figure>

<h5 id="3-4-启动Redis客户端命令语法："><a href="#3-4-启动Redis客户端命令语法：" class="headerlink" title="3.4 启动Redis客户端命令语法："></a>3.4 启动Redis客户端命令语法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-cli -h IP地址 -p 端口   <span class="comment">//默认IP本机  端口号6379</span></span><br></pre></td></tr></table></figure>

<h5 id="3-5-检测是否服务端启动"><a href="#3-5-检测是否服务端启动" class="headerlink" title="3.5 检测是否服务端启动"></a>3.5 检测是否服务端启动</h5><p>启动redis客户端，打开终端并输入命令redis-cli。该命令连接本地的redis服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br></pre></td></tr></table></figure>

<p>在以上实例中我们连接到本地的redis服务并执行<strong>PING</strong> 命令，该命令用于检测redis服务是否启动</p>
<h5 id="3-6-检查redis的进程"><a href="#3-6-检查redis的进程" class="headerlink" title="3.6 检查redis的进程"></a>3.6 检查redis的进程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#执行 ps -ef | grep -i redis 来查看进程</span><br><span class="line">ps -ef | grep -i redis</span><br><span class="line">root      <span class="number">10050</span>   <span class="number">5728</span>  <span class="number">0</span> <span class="number">23</span>:<span class="number">03</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> ./bin/redis-server *:<span class="number">6379</span></span><br><span class="line">root      <span class="number">10077</span>  <span class="number">10056</span>  <span class="number">0</span> <span class="number">23</span>:<span class="number">10</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ./bin/redis-cli</span><br><span class="line">root      <span class="number">10100</span>  <span class="number">10081</span>  <span class="number">0</span> <span class="number">23</span>:<span class="number">22</span> pts/<span class="number">2</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=auto -i redis</span><br><span class="line">[root<span class="meta">@centos</span> ~]#   </span><br></pre></td></tr></table></figure>

<h4 id="四、Redis配置详细"><a href="#四、Redis配置详细" class="headerlink" title="四、Redis配置详细"></a>四、Redis配置详细</h4><p>Redis默认定义了很多默认配置。但在实际开发中，一般我们都会通过手动配置完成。回到安装目录下找到解压文件中的redis.conf。</p>
<p>Redis的配置文件位于Redis安装目录下，文件名称为redis.conf</p>
<h5 id="4-1-配置Redis"><a href="#4-1-配置Redis" class="headerlink" title="4.1 配置Redis"></a>4.1 配置Redis</h5><p>命令：解压目录下的redis.conf配置文件复制到安装文件的目录下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#把编译的redis.conf文件放 ，安装的redis文件目录下</span><br><span class="line">[root<span class="meta">@centos</span> redis-<span class="number">5.0</span><span class="number">.8</span>]# pwd</span><br><span class="line">/root/apps/redis-<span class="number">5.0</span><span class="number">.8</span></span><br><span class="line">[root<span class="meta">@centos</span> redis-<span class="number">5.0</span><span class="number">.8</span>]# cp redis.conf /root/apps/redis</span><br><span class="line">[root<span class="meta">@centos</span> redis-<span class="number">5.0</span><span class="number">.8</span>]# cd ..</span><br><span class="line">[root<span class="meta">@centos</span> apps]# ll</span><br></pre></td></tr></table></figure>

<h5 id="4-2-Redis-conf"><a href="#4-2-Redis-conf" class="headerlink" title="4.2 Redis.conf"></a>4.2 Redis.conf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class="line">    daemonize no</span><br><span class="line"><span class="number">2</span>、当Redis以守护进程方式运行时，Redis默认会把pid写入/<span class="keyword">var</span>/run/redis.pid文件，可以通过pidfile指定 </span><br><span class="line">    pidfile /<span class="keyword">var</span>/run/redis.pid</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、指定Redis监听端口，默认端口为<span class="number">6379</span>；’</span><br><span class="line">    port <span class="number">6379</span></span><br><span class="line"><span class="number">4</span>、绑定的主机地址</span><br><span class="line">    bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">5</span>、当客户端限制多长时间后关闭连接，如果指定为<span class="number">0</span>，表示关闭该功能</span><br><span class="line">    timeout <span class="number">300</span></span><br><span class="line"><span class="number">6</span>、指定日志记录几倍，Redis总共支持四个级别：debug，verbose，notice，warning，默认为verbose</span><br><span class="line">    loglevel verbos</span><br><span class="line"><span class="number">7</span>、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置日志记录方式标准输出，则日志将会发送给/dev/<span class="keyword">null</span></span><br><span class="line">    logfile stdout</span><br><span class="line"><span class="number">8</span>、设置数据库的数量，默认数据库为<span class="number">0</span>，可以使用SELECT&lt;dbid&gt;命令在连接上指定数据库id</span><br><span class="line">    databases <span class="number">16</span></span><br><span class="line"><span class="number">9</span>、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line">    save&lt;seconds&gt;&lt;changes&gt;</span><br><span class="line">    Redis默认配置文件中提供了三个条件</span><br><span class="line">    save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">    save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">    save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line">    分别表示<span class="number">900</span>秒(<span class="number">15</span>分钟)内有<span class="number">1</span>个更改，<span class="number">300</span>秒(<span class="number">5</span>分钟)内有<span class="number">10</span>个更改以及<span class="number">60</span>秒内有<span class="number">10000</span>个更改。</span><br><span class="line"><span class="number">10</span>、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF(压缩算法)压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line">    rdbcompression yes</span><br></pre></td></tr></table></figure>

<p><strong>中间10个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>、指定本地数据库文件名，默认为dump.rdb</span><br><span class="line">	dbfilename dump.rdb</span><br><span class="line"><span class="number">12</span>、指定本地数据库存放目录</span><br><span class="line">	dir ./</span><br><span class="line"><span class="number">13</span>、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步slaveof&lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="number">14</span>、当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line">    masterauth&lt;master-password&gt;</span><br><span class="line"><span class="number">15</span>、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis是需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line">    requirepass foobared</span><br><span class="line"><span class="number">16</span>、设置同一时间最大客户端连接数，默认是无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置maxclients <span class="number">0</span>，表示不作限制。当客户端连接数到达限制是，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class="line">    maxclients <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="number">17</span>、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，档次方法处理后，仍然达最大内存设置，将无法再进行写入操作，但仍然可以静心读取操作。Rdis新的vm机制，会把key存放内存，Value会存放在swap区</span><br><span class="line">    maxmemory &lt;bytes&gt;</span><br><span class="line"><span class="number">18</span>、指定是否每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一端时间内的数据丢失。因为 redis 本省同步数据文件是按上面save条件来同步的，所有的数据会在一端时间内只存在于内存中。默认为no</span><br><span class="line">    appendonly no</span><br><span class="line"><span class="number">19</span>、指定更新日志文件名，默认为appendonly.aof</span><br><span class="line">    appendfulename appendonly.aof</span><br><span class="line"><span class="number">20</span>、指定更新日志条件，共有<span class="number">3</span>个可选值：</span><br><span class="line">    no: 表示等操作系统进行数据缓存同步到磁盘(快)</span><br><span class="line">    always: 表示每次更新操作后活动调用fsync()将数据写到磁盘(慢，安全)</span><br><span class="line">    everysec: 表示每秒同步一个(折中，默认值)</span><br><span class="line">    appendfsync everysec</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">maxmemory-policy noeviction  #  内存达到上限之后的处理策略</span><br><span class="line">1、volatile-lru ： 只对设置了过期时间的key进行LRU（默认值）</span><br><span class="line">2、allkeys-lru ： 产出lru算法的key</span><br><span class="line">3、volatile-random  ： 随机删除即将过期key</span><br><span class="line">4、allkey -random : 随机删除</span><br><span class="line">5、volatile-ttl  :  删除即将过期的</span><br><span class="line">6、noeviction    ： 永不过期，返回错误</span><br></pre></td></tr></table></figure>







<p><strong>结尾10个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>、指定是否启用虚拟内存机制，默认为no，简单的介绍一下，vm机制将数据分页存放，有Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中(在后面的文章会仔细分析Redis的vm机制)</span><br><span class="line">    vm-enabled no</span><br><span class="line"><span class="number">22</span>、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line">    vm-swap-file /tmp/redis.swap</span><br><span class="line"><span class="number">23</span>、将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(Redis的索引数据 就是keys)，也就是说，当vm-max-memory设置为<span class="number">0</span>的时候，其实是所有value都存在于磁盘。默认值为<span class="number">0</span></span><br><span class="line">    vm-page-size <span class="number">32</span></span><br><span class="line"><span class="number">24</span>、Redis swap文件分成了很多的page，一个对象可以保存咱几多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果村粗很多小对象，page大小最好设置为<span class="number">32</span>或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不确定，就是用默认值</span><br><span class="line">    vm-page-size <span class="number">32</span></span><br><span class="line"><span class="number">25</span>、设置swap文件中的page数量，由于页表(一种表示页面空闲或是欧诺个的bitmap)是放在内存中的，在磁盘上每<span class="number">8</span>个pages将消耗1byte的内存</span><br><span class="line">    vm-pages <span class="number">134217728</span></span><br><span class="line"><span class="number">26</span>、设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为<span class="number">0</span>，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 <span class="number">4</span></span><br><span class="line">    vm-max-threads <span class="number">4</span></span><br><span class="line"><span class="number">27</span>、设置在向客户端应答时，是否把较小的包含并未一个包发送，默认为开启</span><br><span class="line">    glueoutputbuf yes</span><br><span class="line"><span class="number">28</span>、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line">    hash-max-zipmap-entries <span class="number">64</span></span><br><span class="line">    hash-max-zipmap-value <span class="number">512</span></span><br><span class="line"><span class="number">29</span>、指定是否激活重置哈希。默认为开启(后面在介绍Redis的哈希算法时具体介绍)</span><br><span class="line">    activerehasing yes</span><br><span class="line"><span class="number">30</span>、指定包含其他的配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class="line">    include /path/to/local.conf    </span><br></pre></td></tr></table></figure>

<h5 id="4-2、内存中的维护策略"><a href="#4-2、内存中的维护策略" class="headerlink" title="4.2、内存中的维护策略"></a>4.2、内存中的维护策略</h5><p>redis作为优秀的中间缓存件，时常会存储大量的数据，即使采取了集群部署来动态扩容，也应该即使的整理内存，维持系统性能。</p>
<h6 id="4-2-1-在redis中有两种解决方案"><a href="#4-2-1-在redis中有两种解决方案" class="headerlink" title="4.2.1 在redis中有两种解决方案"></a>4.2.1 在redis中有两种解决方案</h6><ul>
<li>为数据设置超时时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置过期时间</span></span><br><span class="line"><span class="function">expire key <span class="title">time</span><span class="params">(以秒为单位)</span>--这是最常用的方式</span></span><br><span class="line"><span class="function"><span class="title">setex</span><span class="params">(String key, <span class="keyword">int</span> seconds, String value)</span> --字符串独有的方式</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</span></span><br><span class="line"><span class="function">2、如果没有设置时间，那缓存就是永不过期</span></span><br><span class="line"><span class="function">3、如果设置了过期时间，之后又想让缓存永不过期没使用persist key    </span></span><br></pre></td></tr></table></figure>

<ul>
<li>采用LRU算法动态将不用的数据删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">内存管理的一种页面置换算法，对于在内存中但又不用的数据块(内存块)叫做LRU，</span><br><span class="line">操作系统会根据哪些数据属于LRU而将其移除内存而腾出空间来加载另外的数据。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>1.<strong>volatile-lru</strong>：设定超时时间的数据中，删除最不常使用的数据</p>
<p>2.<strong>allkeys-lru</strong>：查询所有的key只能怪最近最不常使用的数据进行删除，这是应用最广泛的策略。</p>
<p>3.<strong>volatile-random</strong>：在已经设定了超时的数据中随机删除。</p>
<p>4.<strong>allkeys-random</strong>：查询所有的key，之后随机删除。</p>
<p>5.<strong>volatile-ttl</strong>：查询全部设定超时时间的数据，之后排序，将马上要过期的数据进行删除操作。</p>
<p>6.<strong>noeviction</strong>：如果设置为该属性，则不会进行删除操作，如果内存溢出则报错返回。</p>
<p>7.<strong>volatile-lfu</strong>：从所有配置了过去时间的键中驱逐使用频率最少的键</p>
<p>8.<strong>allkeys-lfu</strong>：从所有键中驱逐使用频率最少的键</p>
<h6 id="4-2-2-自定义配置redis"><a href="#4-2-2-自定义配置redis" class="headerlink" title="4.2.2 自定义配置redis"></a>4.2.2 自定义配置redis</h6><p>进入对应的安装目录：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/root/apps/redis</span><br></pre></td></tr></table></figure>

<p>修改redis.conf配置文件 vim redis.conf（进入命令模式 通过/内容 查找相应字符串）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">daemonize no 修改为 daemonize yes 守护进程启动</span><br><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 注释掉  允许除本机 外的机器访问redis服务</span><br><span class="line">requirepass 设置密码  设定数据库密码 (保证服务安全/有些情况下不设定密码是无法进行远程连接访问的)</span><br></pre></td></tr></table></figure>

<p>Redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成为yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入值redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。但当daemonize选项设置为no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具（putty,xshell等）都会呆滞redis进程退出。</p>
<p>服务端开发的大部分应用都是采用后台运行的模式</p>
<p>requirepass设置密码。因为redis速度相当快，所以一台比较好的服务器下，一个外部用户在一秒内可以进行15w密码尝试，这意味你需要设定非常强大的密码来防止暴力破解。</p>
<p>可以通过redis的配置文件设置密码参数，这样客户端连接大redis服务就需要密码验证，这样可以让你的redis服务更加安全。</p>
<h4 id="五-、Redis启动"><a href="#五-、Redis启动" class="headerlink" title="五 、Redis启动"></a>五 、Redis启动</h4><h5 id="5-1-Redis以守护进程服务端进行启动"><a href="#5-1-Redis以守护进程服务端进行启动" class="headerlink" title="5.1 Redis以守护进程服务端进行启动"></a>5.1 Redis以守护进程服务端进行启动</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用该命令进行启动：【./bin/redis-server ./redis.conf 】</span></span><br><span class="line">[root<span class="meta">@centos</span> redis]# ./bin/redis-server ./redis.conf </span><br><span class="line"><span class="number">11450</span>:C <span class="number">05</span> Jul <span class="number">2020</span> <span class="number">12</span>:<span class="number">23</span>:<span class="number">34.257</span> # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line"><span class="number">11450</span>:C <span class="number">05</span> Jul <span class="number">2020</span> <span class="number">12</span>:<span class="number">23</span>:<span class="number">34.257</span> # Redis version=<span class="number">5.0</span><span class="number">.8</span>, bits=<span class="number">64</span>, commit=<span class="number">00000000</span>, modified=<span class="number">0</span>, pid=<span class="number">11450</span>, just started</span><br><span class="line"><span class="number">11450</span>:C <span class="number">05</span> Jul <span class="number">2020</span> <span class="number">12</span>:<span class="number">23</span>:<span class="number">34.257</span> # Configuration loaded</span><br><span class="line">[root<span class="meta">@centos</span> redis]# </span><br></pre></td></tr></table></figure>

<h5 id="5-2-Redis客户端进行启动："><a href="#5-2-Redis客户端进行启动：" class="headerlink" title="5.2 Redis客户端进行启动："></a>5.2 Redis客户端进行启动：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Redis 客户端启动命令：./redis-cli</span></span><br><span class="line">[root<span class="meta">@centos</span> bin]# ./redis-cli </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br></pre></td></tr></table></figure>

<h4 id="六、Redis关闭"><a href="#六、Redis关闭" class="headerlink" title="六、Redis关闭"></a>六、Redis关闭</h4><h5 id="6-1、第一种关闭方式："><a href="#6-1、第一种关闭方式：" class="headerlink" title="6.1、第一种关闭方式："></a>6.1、第一种关闭方式：</h5><p>(断电、非正常关闭，容易数据丢失) 查询不到redis进程id</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">PID ps -ef | grep -i redis</span><br></pre></td></tr></table></figure>

<p>kill 查询的id进行强制关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -<span class="number">9</span> PID</span><br></pre></td></tr></table></figure>

<h5 id="6-2、第二种关闭方式"><a href="#6-2、第二种关闭方式" class="headerlink" title="6.2、第二种关闭方式"></a>6.2、第二种关闭方式</h5><p>(正常关闭，数据保存)</p>
<p><strong>关闭redis服务，通过客户端进行shutdown</strong></p>
<p>如果redis设置了密码，需要先在客户端通过密码登录，在进行shutdown即可关闭服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在客户端使用【shutdown】命令关闭Redis服务端</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SHUTDOWN</span><br><span class="line">not connected&gt; y</span><br><span class="line">Could not connect to Redis at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>: Connection refused</span><br><span class="line">not connected&gt; shutdown</span><br></pre></td></tr></table></figure>

<h4 id="七、远程连接"><a href="#七、远程连接" class="headerlink" title="七、远程连接"></a>七、远程连接</h4><h5 id="7-1-Redis远程连接比较流行的软件：RedisDesktoManager"><a href="#7-1-Redis远程连接比较流行的软件：RedisDesktoManager" class="headerlink" title="7.1 Redis远程连接比较流行的软件：RedisDesktoManager"></a>7.1 Redis远程连接比较流行的软件：RedisDesktoManager</h5><p>默认不允许远程连接，需要修改一下信息才可以进行修改，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 注释掉 允许除本机以外的机器访问Redis服务</span><br><span class="line">requirepass 设置密码 设定数据库密码(有些情况系不设定密码是无法进行远程连接访问的)</span><br></pre></td></tr></table></figure>

<h5 id="7-2-Redis使用密码登录"><a href="#7-2-Redis使用密码登录" class="headerlink" title="7.2 Redis使用密码登录"></a>7.2 Redis使用密码登录</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redis客户端使用密码进行登录  【./bin/redis-cli -a redis】</span></span><br><span class="line">[root<span class="meta">@centos</span> redis]# ./bin/redis-cli -a redis</span><br><span class="line">Warning: Using a password with <span class="string">&#x27;-a&#x27;</span> or <span class="string">&#x27;-u&#x27;</span> option on the command line <span class="class"><span class="keyword">interface</span> <span class="title">may</span> <span class="title">not</span> <span class="title">be</span> <span class="title">safe</span>.</span></span><br><span class="line"><span class="class">127.0.0.1:6379&gt; <span class="title">keys</span> *</span></span><br><span class="line"><span class="class">1) &quot;<span class="title">name</span>&quot;</span></span><br><span class="line"><span class="class">127.0.0.1:6379&gt; </span></span><br></pre></td></tr></table></figure>



<h4 id="Centos-防火墙端口"><a href="#Centos-防火墙端口" class="headerlink" title="Centos 防火墙端口"></a>Centos 防火墙端口</h4><p>开放8080端口（如下命令只针对Centos7以上）</p>
<p>查看已经开放的端口：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>

<p>开启端口：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port-6379/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>重启防火墙：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload  #重启</span><br><span class="line">Firewall systemctl stop firewalld.service  #停止</span><br><span class="line">firewall systemctl disable firewalld.service #禁止firewall 开机启动</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="八-、Docker安装Redis"><a href="#八-、Docker安装Redis" class="headerlink" title="八 、Docker安装Redis"></a>八 、Docker安装Redis</h4><h5 id="8-1-搜索redis"><a href="#8-1-搜索redis" class="headerlink" title="8.1 搜索redis"></a>8.1 搜索redis</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<h5 id="8-2-下载镜像"><a href="#8-2-下载镜像" class="headerlink" title="8.2 下载镜像"></a>8.2 下载镜像</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull redis：<span class="number">4.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h5 id="8-3-创建并运行容器"><a href="#8-3-创建并运行容器" class="headerlink" title="8.3 创建并运行容器"></a>8.3 创建并运行容器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis6379 -p <span class="number">6379</span>:<span class="number">6379</span> redis:<span class="number">4.0</span><span class="number">.1</span> --requirepass <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="8-4-测试进入Redis进入客户端"><a href="#8-4-测试进入Redis进入客户端" class="headerlink" title="8.4 测试进入Redis进入客户端"></a>8.4 测试进入Redis进入客户端</h5><p>使用redis镜像执行redis-cli命令连接到刚启动的容器</p>
<h4 id="九、Redis常用命令"><a href="#九、Redis常用命令" class="headerlink" title="九、Redis常用命令"></a>九、Redis常用命令</h4><p>Redis 命令用于在redis服务上执行操作。要在redis服务上执行命令需要一个redis客户端。</p>
<p>Redis 客户端在我们之前下载的Redis的安装包中。</p>
<p>**Redis支持的物种数据类型 ：string(字符串)，hash(哈希)，list(列表)，set(集合)及zset（sorted set : 有序集合）等</p>
<h5 id="9-1-常用命令key管理"><a href="#9-1-常用命令key管理" class="headerlink" title="9.1 常用命令key管理"></a>9.1 常用命令key管理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、 keys * :返回满足的所有键，可以模糊匹配，比如 keys abc* ：表示以 abc 开头的 key</span><br><span class="line"><span class="number">2</span>、 exists key ： 是否存在指定的key ，存在返回<span class="number">1.</span>不存在返回<span class="number">0</span></span><br><span class="line"><span class="number">3</span>、 expire key second ：设置某个key的过期时间 时间为妙</span><br><span class="line"><span class="number">4</span>、 del key : 删除某个key</span><br><span class="line"><span class="number">5</span>、 ttl key ：查看剩余时间，当key不存在是，返回-<span class="number">2</span>；存在但没有设置剩余生存时间时，返回 -<span class="number">1</span>，否              则，以秒为单位，返回key 的剩余生存时间。</span><br><span class="line"><span class="number">6</span>、 persist key ：取消过去时间</span><br><span class="line"><span class="number">7</span>、 PEXPIRE key millisseconds 修改key 的过期时间为毫秒</span><br><span class="line"><span class="number">8</span>、 select ： 选择数据库 数据库为<span class="number">0</span>-<span class="number">15</span>（默认一共<span class="number">16</span>个数据库）</span><br><span class="line"><span class="number">9</span>、 设计成多个数据库实际上是为了数据库安全和备份</span><br><span class="line"><span class="number">10</span>、 move key dbindex ： 将当前数据中的key转移到其他数据库</span><br><span class="line"><span class="number">11</span>、 randomkey ： 随机返回一个key</span><br><span class="line"><span class="number">12</span>、 rename key key2 : 种命名key</span><br><span class="line"><span class="number">13</span>、 echo ： 打印命令</span><br><span class="line"><span class="number">14</span>、 dbsize : 查看数据库的key数量</span><br><span class="line"><span class="number">15</span>、 info : 查看数据库信息</span><br><span class="line"><span class="number">16</span>、 config get * 实时存储收到的请求，返回相关的配置</span><br><span class="line"><span class="number">17</span>、 flushdb ： 清除当前数据库</span><br><span class="line"><span class="number">18</span>、 flushall ： 清空所有数据库 </span><br></pre></td></tr></table></figure>

<h5 id="9-2-DEL-key"><a href="#9-2-DEL-key" class="headerlink" title="9.2 DEL key"></a>9.2 DEL key</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">该命令用于在key存在时删除key。</span><br></pre></td></tr></table></figure>

<h5 id="9-3-EXISTS-key"><a href="#9-3-EXISTS-key" class="headerlink" title="9.3 EXISTS key"></a>9.3 EXISTS key</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">检查给定key是否存在。</span><br></pre></td></tr></table></figure>

<h5 id="9-4-EXPIRE-key-seconds"><a href="#9-4-EXPIRE-key-seconds" class="headerlink" title="9.4 EXPIRE key seconds"></a>9.4 EXPIRE key seconds</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">为给定key设置过期时间(以秒计)</span><br></pre></td></tr></table></figure>

<h5 id="9-5-PEXPIRE-key-milliseconds"><a href="#9-5-PEXPIRE-key-milliseconds" class="headerlink" title="9.5 PEXPIRE key milliseconds"></a>9.5 PEXPIRE key milliseconds</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设置key的过期时间以毫秒计</span><br></pre></td></tr></table></figure>

<h5 id="9-6-TTL-key"><a href="#9-6-TTL-key" class="headerlink" title="9.6 TTL key"></a>9.6 TTL key</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">以秒为单位，返回给定key的剩余生存时间(TTL, time to live)</span><br></pre></td></tr></table></figure>

<h5 id="9-7-PTTL-key"><a href="#9-7-PTTL-key" class="headerlink" title="9.7 PTTL key"></a>9.7 PTTL key</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">以秒为单位，返回 key 的剩余生存时间</span><br></pre></td></tr></table></figure>

<h5 id="9-8-KEYS-pattern"><a href="#9-8-KEYS-pattern" class="headerlink" title="9.8 KEYS pattern"></a>9.8 KEYS pattern</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">查找所有服务给定模式(pattern)的key。</span><br><span class="line">keys 通配符  获取所有与pattern匹配的key，返回所有与该匹配</span><br><span class="line">  通配符 ： </span><br><span class="line">		* 代表所有</span><br><span class="line">        ? 表示代表一个字符</span><br></pre></td></tr></table></figure>

<h5 id="9-9-RENAME-key-newkey"><a href="#9-9-RENAME-key-newkey" class="headerlink" title="9.9 RENAME key newkey"></a>9.9 RENAME key newkey</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改key的名称</span><br></pre></td></tr></table></figure>

<h5 id="9-10-MOVE-key-db"><a href="#9-10-MOVE-key-db" class="headerlink" title="9.10 MOVE key db"></a>9.10 MOVE key db</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将当前数据库的 key 移动到给定的数据库db当中</span><br></pre></td></tr></table></figure>

<h5 id="9-11-TYPE-key"><a href="#9-11-TYPE-key" class="headerlink" title="9.11 TYPE key"></a>9.11 TYPE key</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回 key 所存储的值的类型</span><br></pre></td></tr></table></figure>

<h5 id="9-12-应用场景"><a href="#9-12-应用场景" class="headerlink" title="9.12 应用场景"></a>9.12 应用场景</h5><p><strong>EXPIPER key seconds</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、限时的优惠活动信息</span><br><span class="line"><span class="number">2</span>、网站数据缓存(对于一些需要定时更新的数据，例如:积分排行榜)</span><br><span class="line"><span class="number">3</span>、手机验证码</span><br><span class="line"><span class="number">4</span>、限制网站访客访问频率(例如：<span class="number">1</span>分钟最多访问<span class="number">10</span>次)</span><br></pre></td></tr></table></figure>

<h5 id="9-13-key的命名建议"><a href="#9-13-key的命名建议" class="headerlink" title="9.13 key的命名建议"></a>9.13 key的命名建议</h5><p><strong>redis单个key允许存入512M大小</strong> </p>
<ul>
<li>1、key 不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率</li>
<li>2、key 也不要太短，太短的话，key的可读性会降低</li>
<li>3、在一个项目中，key最好使用提议的命名模式，例如user:12:password</li>
<li>4、key名称区分大小写</li>
</ul>
<h4 id="十-、Redis数据类型"><a href="#十-、Redis数据类型" class="headerlink" title="十 、Redis数据类型"></a>十 、Redis数据类型</h4><h5 id="10-1-String-类型"><a href="#10-1-String-类型" class="headerlink" title="10.1 String 类型"></a>10.1 String 类型</h5><p>String类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p>String 数据结构最贱但的key-value类型，value其不仅是string，也可以是数字，是包含很多种类型的特殊类型，</p>
<p>String类型是二进制安全的。意思是redis的string可以包含任何数据。</p>
<p>比如序列化的对象进行存储，比如一张图片进行二进制存储，比如一个简单的字符串，数值等等。</p>
<h5 id="String命令"><a href="#String命令" class="headerlink" title="String命令"></a>String命令</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、复制语法：</span><br><span class="line">	SET KEY_NAME VALUE : (说明：多次设置name会覆盖)(Redis SET 命令用于设置给定 key 的值。如果 key 已经存储值，SET 就要写旧值，且无视类型)。</span><br><span class="line"><span class="number">2</span>、命令：</span><br><span class="line">    SETNX key1 value：(not exist) 如果key1不存在，则设置 并返回<span class="number">1</span>。如果key1存在，则不设置并返回<span class="number">0</span>;(解决分布式锁  方案之一，只有在key 不存在时设置 key 的值。setnx (SET <span class="keyword">if</span> not exits)命令在指定的key不存在时，为key设置指定的值)。</span><br><span class="line">    SETEX key1 <span class="number">10</span> lx :(expired)设置key1的值为lx,过期时间为<span class="number">10</span>秒，<span class="number">10</span>秒后key1清除（key也清除）</span><br><span class="line"></span><br><span class="line">SETEX key1 <span class="number">10</span> lx :(expired) 设置key1的值为lx，过期时间为<span class="number">10</span>秒，<span class="number">10</span>秒后key1清除(key 也清除)</span><br><span class="line"></span><br><span class="line">SETRANG STRING range value : 替换字符串</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、取值语法：</span><br><span class="line">	GET KEY_NAME : Redis GET 命令用于获取指定 key 的值。如果 key 不存在，返回 nil。如果key存储的值不是字符串类型，返回一个错误。</span><br><span class="line"></span><br><span class="line">  GETRANGE  key start end : 用于获取存储在指定key中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量来决定(包括 start 和 end 在内)</span><br><span class="line"></span><br><span class="line">	GETBIT key offset ：对 key 所存储的字符串值，获取指定偏移量上的为(bit)；</span><br><span class="line">GETTEST语法 ： GETSET KEY_NAME VALUE : GETSET 命令用于设置指定 key 的值，并返回key的旧值。当key不存在是，返回 nil</span><br><span class="line">	STRLEN key :返回 key 所存储的字符串值的长度</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、删除语法：</span><br><span class="line">DEL KEY_NAME : 删除指定的key，如果存在，返回数字类型。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、批量写：MSET K1 V1 K2 V2 ... (一次性写入多个值)</span><br><span class="line"><span class="number">6</span>、批量读：MGET K1 K2 K3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、GETSET NAME VALUE : 一次性设置和读取(返回旧值，写上新值)</span><br><span class="line"><span class="number">8</span>、自增/自减：</span><br><span class="line">  INCR KEY_Name : Incr 命令将key中存储的数组值增<span class="number">1</span>。如果 key 不存在，那么key的值会先被初始化为<span class="number">0</span>，然后在执行INCR操作</span><br><span class="line">  自增: INCRBY KEY_Name : 增量值Incrby 命令将key中存储的数字加上指定的增量值</span><br><span class="line">  自减: DECR KEY_Name 或 DECYBY KEY_NAME 减值：DECR 命令将key中存储的数字减少<span class="number">1</span></span><br><span class="line"></span><br><span class="line">：(注意这些key对应的必须是数字类型字符串，否则会出错。)</span><br><span class="line"></span><br><span class="line">字符串拼接：APPEND  KEY_NAME VALUE</span><br><span class="line">:Append 命令用于为指定的key追加至末尾，如果不存在，为其赋值</span><br><span class="line"></span><br><span class="line">字符串长度 ：STRLEN key</span><br><span class="line">    </span><br><span class="line">##########################    </span><br><span class="line"> setex   (set with expire) #设置过期时间</span><br><span class="line"> setnx   (set <span class="keyword">if</span> not exist) #不存在设置 在分布式锁中会常常使用！</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="10-2-应用场景"><a href="#10-2-应用场景" class="headerlink" title="10.2 应用场景"></a>10.2 应用场景</h5><ul>
<li><p><strong>1、String通常用于保存单个字符串或JSON字符串数据</strong></p>
</li>
<li><p><strong>2、因String是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储</strong></p>
</li>
<li><p><strong>3、计数器(常规key-value缓存应用。常规计数：微博数，粉丝数)</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INCR 等指令本身就具有原子操作的特定，所以我们完全可以利用redis的INCR，INCRBY,DECR,DECRBY等指令来实现原子计数的效果。假如，在某种场景下有3个客户端同时读取了mynum的值(值为2)，然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。</span><br><span class="line">不少网站都利用redis的这个特性来实现业务上的统计计数需求。</span><br></pre></td></tr></table></figure>

<h5 id="10-3-Hash类型"><a href="#10-3-Hash类型" class="headerlink" title="10.3 Hash类型"></a>10.3 Hash类型</h5><p>Hash类型是String类型的field和value的映射表，或者说是一个String集合。hash特别适合用于存储对象，相比较而言，将一个对象类型存储在Hash类型要存储在String类型里占用更少的内存空间，并对整个对象的存取。可以看成具有KEY和VALUE的MAP容器，该类型非常适合于存储值对象的信息。</p>
<p>如：uname，upass，age等。该类型的数据仅占用很少的磁盘空间(相比于JSON).</p>
<p>Redis 中每一个hash 可以存储 2的32次方 -1 键值对(40 多亿)</p>
<h5 id="10-4-Hash命令"><a href="#10-4-Hash命令" class="headerlink" title="10.4 Hash命令"></a>10.4 Hash命令</h5><p>常用命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、赋值语法：</span><br><span class="line">	<span class="number">1</span>、 HSET KEY FIELD VALUE   ： 为指定的KEY,设定FILD/VALUE</span><br><span class="line">	<span class="number">2</span>、 HMSET KEY FIELD VALUE [FIELD1，VALUE]... : 同时将多个 field-value(域-值)对设置到哈希表key中。</span><br><span class="line"></span><br><span class="line">二、取值语法：</span><br><span class="line">    HGET KEY FIELD  :获取存储在HASH中的值，根据FIELD得到VALUE</span><br><span class="line">    HMGET KEY FIELD [FIELD1]   :获取key所有给定字段的值</span><br><span class="line">    HGETALL KEY     :返回HASH表中所有的字段和值</span><br><span class="line">        </span><br><span class="line"> HKEYS KEY : 获取所有哈希表中的字段</span><br><span class="line"> HLEN  KEY : 获取哈希表中字段的数量</span><br><span class="line"></span><br><span class="line">三、删除语法：</span><br><span class="line">     HDEL KEY FIELD[FIELD2]  :删除一个或多个HASH表字段</span><br><span class="line"> </span><br><span class="line">四、其它语法：</span><br><span class="line">     HSETNX KEY FIELD VALUE : 只有在字段field 不存在时，设置哈希表字段的值</span><br><span class="line">     </span><br><span class="line">     HINCRBY KEY FIELD INCREMENT :为哈希key中的指定字段的整数值加上增量 increment。</span><br><span class="line">         </span><br><span class="line">     HINCRBYFLOAT KEY FIELD INCREMENT  :为哈希表key 中的指定字段的浮点数值加上增量 increment</span><br><span class="line">         </span><br><span class="line">     HEXISTS KEY FIELD  : 查看哈希表中key中，指定的字段是否存在  </span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200804213506025.png" class="" title="image-20200804213506025">



<h5 id="10-5-应用场景"><a href="#10-5-应用场景" class="headerlink" title="10.5 应用场景"></a>10.5 应用场景</h5><p><strong>Hash的应用场景 ：(存储一个用户信息对象数据)</strong></p>
<ul>
<li><p><strong>常用于存储一个对象</strong></p>
</li>
<li><p><strong>为什么不用string存储一个对象</strong></p>
<p>hash值最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有一下2中村粗方式：</p>
<pre><code>    第一种方式将用户ID作为查找key，把其他信息封装成为一个对象以序列化的方式存储，这种方式的却但是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。

  第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取的对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。
</code></pre>
<h5 id="10-6-总结："><a href="#10-6-总结：" class="headerlink" title="10.6 总结："></a>10.6 总结：</h5><p>Redis提供的Hash很好的解决了这个问题，Redis的Hash实际内部存储的Value为一个HashMap，</p>
</li>
</ul>
<h5 id="10-6-List类型"><a href="#10-6-List类型" class="headerlink" title="10.6 List类型"></a>10.6 List类型</h5><p><strong>简介：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、   List 类型是一个链表结构的集合，其主要功能有push、pop、获取元素等。更详细的说，List类型是一个双端链表的节后，我们可以通过相关的操作进行集合的头部或者尾部添加和删除元素，List的设计是非常简单精巧，即可以最为栈，有可以最为队列，满足绝大多数的需求。</span><br></pre></td></tr></table></figure>

<p><strong>常用命令</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">1、赋值语法：</span> <span class="string"></span></span><br><span class="line">	<span class="attr">LPUSH</span> <span class="string">KEY VALUE1 [VALUE2] :将一个或多个值插入到列表头部（从左侧添加）</span></span><br><span class="line">  <span class="attr">RPUSH</span> <span class="string">KEY VALUE1 [VALUE2] ：在列表中添加一个或多个值（从有侧添加）</span></span><br><span class="line">	<span class="attr">LPUSHX</span> <span class="string">KEY VAKUE :将一个值插入到已存在的列表头部。如果列表不在，操作无效</span></span><br><span class="line">	<span class="attr">RPUSHX</span> <span class="string">KEY VALUE :一个值插入已经在的列表尾部（最右边）。如果列表不在，操作无效</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">2、取值语法：</span></span><br><span class="line">	<span class="attr">LLEN</span> <span class="string">KEY   :获取列表长度</span></span><br><span class="line">  <span class="attr">LINDEX</span> <span class="string">KEY INDEX	:通过索引获取列表中的元素</span></span><br><span class="line">	<span class="attr">LRANGE</span> <span class="string">KEY START STOP	:获取列表指定范围内的元素</span></span><br></pre></td></tr></table></figure>

<p>描述：返回列表中指定区间的元素，区间以偏移量START和END指定。</p>
<p>其中0表示列表的第一个元素，1表示列表的第二个元素，以此类推。。。</p>
<p>也可以使用负数下标，以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，一次类推。。。</p>
<p>start：页大小（页数-1）</p>
<p>stop：（页大小页数）-1</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">3、删除语法：</span></span><br><span class="line">	<span class="attr">LPOP</span> <span class="string">KEY :移除并获取列表的第一个元素（从左侧删除）</span></span><br><span class="line">	<span class="attr">RPOP</span> <span class="string">KEY :移除列表的最后一个元素，返回值为移除的元素（从右侧删除）</span></span><br><span class="line"></span><br><span class="line">	<span class="attr">BLPOP</span> <span class="string">key1 [key2]timeout :移除并获取列表的第一个元素，如果列表没有元素会阻塞列表知道等待超时或发现可弹出元素为止。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">4、修改语法：</span></span><br><span class="line">	<span class="attr">LSET</span> <span class="string">KEY INDEX VALUE :通过索引设置列表元素的值</span></span><br><span class="line">	<span class="attr">LINSERT</span> <span class="string">KEY BEFORE|AFTER WORIL VALUE :在列表的元素前或者后 插入元素 描述：将值 value 插入到列表key当中，位于值world之前或之后。</span></span><br></pre></td></tr></table></figure>

<p><strong>高级命令</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">高级语法：</span></span><br><span class="line">	<span class="attr">RPOPLPUSH</span> <span class="string">source destiation : 移除列表的最后一个元素，并将该元素添加到另外一个列表并返回</span></span><br><span class="line">	<span class="attr">示例描述：</span></span><br><span class="line">		<span class="attr">RPOPLPUSH</span> <span class="string">a1  a2  : a1的最后元素移到a2的左侧</span></span><br><span class="line">		<span class="attr">RPOPLPUSH</span> <span class="string">a1  a1  : 循环列表，将最后元素移到最左侧</span></span><br><span class="line">   <span class="attr">BRPOPLPUSH</span> <span class="string">source destination timeout  :从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；如果列表没有元素会阻塞列表知道等待超时或发现可弹出的元素为止。</span></span><br></pre></td></tr></table></figure>

<p><strong>List代码案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tyx.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tyx.po.User;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> papi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020/7/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis有什么命令，Jedis有什么方法</span></span><br><span class="line"><span class="comment">     * Lettuce-----》RedisTemplate进一步的封装</span></span><br><span class="line"><span class="comment">     *RedisTemplate 方法和命令是肯定不一样的</span></span><br><span class="line"><span class="comment">     * Redis 和 String类型</span></span><br><span class="line"><span class="comment">     * 需求输入一个key</span></span><br><span class="line"><span class="comment">     * 先判断该key是否存在如果不存在则在mysql中进行查询，写入到redis中。并返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRedisValueByKey</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            <span class="comment">//表示存在值，进行获取</span></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; redis中查询的数据&quot;</span>);</span><br><span class="line">            Object o = redisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">return</span> (String) o;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在去mysql中查并且赋值给reids</span></span><br><span class="line">            String val = <span class="string">&quot;redis中不存在的key&quot;</span>;</span><br><span class="line">            log.info(<span class="string">&quot;------&gt;mysql中查询出来的：&quot;</span>+val);</span><br><span class="line">            redisTemplate.opsForValue().set(key,val);</span><br><span class="line">            log.info(<span class="string">&quot;------&gt;mysql中查出的数据存入redis中&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试String类型</span></span><br><span class="line"><span class="comment">     * 需求：用户输入一个redis数据。该key的有效期为28小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireStr</span><span class="params">(String key, String val)</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,val);</span><br><span class="line">        redisTemplate.expire(key,<span class="number">2</span>,TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询用户对象信息</span></span><br><span class="line"><span class="comment">     *  先判断redis中是否存在该key</span></span><br><span class="line"><span class="comment">     *  如果不存在，查询数据库中mysql中的值，并将结果添加到redis中。</span></span><br><span class="line"><span class="comment">     *  如果存在，直接将结果在redis查询，并返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getHashKey</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.opsForHash().hasKey(<span class="string">&quot;user&quot;</span>,id))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;-----&gt;查询redis数据库&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> (User) redisTemplate.opsForHash().get(<span class="string">&quot;user&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;-----&gt;查询mysql数据库&quot;</span>);</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(id);</span><br><span class="line">            user.setAge(<span class="number">18</span>);</span><br><span class="line">            user.setName(<span class="string">&quot;速速&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                @param  h  用户的实体</span></span><br><span class="line"><span class="comment">                @param  hk 用户主键id</span></span><br><span class="line"><span class="comment">                @param  hv 整个对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            redisTemplate.opsForHash().put(<span class="string">&quot;user&quot;</span>,id,user);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lpushAll</span><span class="params">(String key, List&lt;Object&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().leftPush(key, list);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间（秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lpushAll</span><span class="params">(String key, List&lt;Object&gt; list, <span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().leftPushAll(key, list);</span><br><span class="line">            <span class="keyword">if</span> (time &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                redisTemplate.expire(key,time,TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在变量左边添加元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lpush</span><span class="params">(String key, Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().leftPush(key,obj);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在变量左边添加元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prvot 中间参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要放的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lpush</span><span class="params">(String key, Object prvot,Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().leftPush(key,prvot,object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在变量左边添加元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prvot 中间参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要放的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rpush</span><span class="params">(String key, Object prvot,Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key,prvot,object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在变量左边添加元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要放的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rpush</span><span class="params">(String key, Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key,object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在变量左边添加元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要放的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lpushIfPresent</span><span class="params">(String key, Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().leftPushIfPresent(key,object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除集合中的左边第一个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回右边第一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除集合中的右边的元素，一般用在队列取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回右边的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">rpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定区间的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lrange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key,start,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前位置上的值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lindex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().index(key,index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 统计</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 移除的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">remove</span><span class="params">(String key,<span class="keyword">long</span> count, Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().remove(key,count,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">llen</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在集合的指定位置插入元素，如果指定的位置已有元素，则覆盖，没有则新增，超过集合的下标+n则会报错；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,Long index, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 截取集合元素，保留成都内地数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">(String key,Long start, Long end)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().trim(key,start,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *出去集合右边的值，同时集合的左边添加一个值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 入栈的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">rightPopAndleftPush</span><span class="params">(String key,String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(key,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *出去集合右边的值，同时集合的左边添加一个值,如果超过等待的时间仍然没有元素则退出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 左边新增的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回移除右边的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">rightPopAndleftPush</span><span class="params">(String key,String str,<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(key,str,time,TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String ... keys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys!=<span class="keyword">null</span> || keys.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (keys.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(keys[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(keys));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds 过期时间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(String key,<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        redisTemplate.expire(key,seconds,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10-7-List-的应用场景"><a href="#10-7-List-的应用场景" class="headerlink" title="10.7 List 的应用场景"></a>10.7 List 的应用场景</h5><p><strong>项目应用于：1、对数据量大的集合数据删除；2、任务队列</strong></p>
<p><strong>1、对数据量大的集合数据删减</strong></p>
<pre><code>列表数据显示，关注列表，粉丝列表，留言评论等.....分页，热点新闻等
</code></pre>
<p>利用LRANG还可以很方便的实现分页的功能，在博客系统中，每片博文的评论也可以存入一个单独的list中。</p>
<p><strong>2、任务队列</strong></p>
<p>(list 通常用来实现一个消息队列，而且可以却表先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任务队列介绍(生产者和消费者模式：)</span><br><span class="line">    在处理web客户端发送的命令请求是，某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后队列进行处理，用户可以推迟执行那些需要一段时间才能完成的操作，这种将工作交个任务处理器来执行的做法被称为任务队列（task queue）。</span><br><span class="line">    </span><br><span class="line">RPOPLPUSH source destination</span><br><span class="line"> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span><br></pre></td></tr></table></figure>

<p><strong>3、List应用场景案例1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10-8-Set类型"><a href="#10-8-Set类型" class="headerlink" title="10.8 Set类型"></a>10.8 Set类型</h5><p><strong>简介</strong></p>
<pre><code>Redis的Set是String类型的无需集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，set是通过hashtable实现的
</code></pre>
<p>集合中最大的成员数为2^32 -1,类似于JAVA中的Hashtable集合。</p>
<p><strong>命令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、复制语法：</span><br><span class="line">    SADD KEY member1 [member2]:向集合添加一个或多个成员</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>、取值语法：</span><br><span class="line">    SCARD KEY :获取集合的成员数</span><br><span class="line">    SMEMBERS KEY ：返回集合中的所有成员</span><br><span class="line">    SISMEMBER  KEY  MEMBER  :判断member元素是否是集合key的成员(开发中：验证是否存在判断)</span><br><span class="line">    SRANDMEMBER KEY [COUNT] :返回集合中一个或对个随机数</span><br><span class="line">        </span><br><span class="line"><span class="number">3</span>、删除语法：</span><br><span class="line">      SREM key member1 [member2] : 移除集合中一个或多个成员</span><br><span class="line">      SPOP key [count] : 移除并返回集合中的一个随机元素</span><br><span class="line">      SMOVE source destination member :将member 元素从Source集合移动到destination集合中</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、差集语言：</span><br><span class="line">   SDIFF  key1  [key2]  :返回给定所有集合的差集</span><br><span class="line">   SDIFFSTORE destination key1 [key2]  :返回给定所有集合的茶几并存储在destination中</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、交集语言：          </span><br><span class="line">    SUNION key1 [key2] : 返回所有给定集合的并集</span><br><span class="line">    SUNIONSTORE destination key1 [key2] :所有给定集合的并集存储在 destinatiion集合中                              </span><br></pre></td></tr></table></figure>

<h5 id="10-9-ZSet类型"><a href="#10-9-ZSet类型" class="headerlink" title="10.9 ZSet类型"></a>10.9 ZSet类型</h5><p>有序集合(sorted set)</p>
<p><strong>简介</strong></p>
<p>1、Redis有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。</p>
<p>2、不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>3、有序集合的成员是唯一的，但分数（score）却可以重复。</p>
<p>4、集合是通过哈希表实现的。集合中最大的成员数为2^32 -1。Redis的ZSet是有序，且不重复。</p>
<p>（很多时候，我们都将redis中的有序结合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的）</p>
<p><strong>命令</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、复制语法：</span><br><span class="line">	ZADD KEY score1 member1 【score2 member2】  ：向有序集合添加一个或多个成员，或者更新已经存在成员的分数</span><br><span class="line"></span><br><span class="line">2、取值语法：</span><br><span class="line">	ZCARD key ：获取有序结合的成员数</span><br><span class="line">  ZCOUNT key min max :计算在有序结合中指定区间分数的成员数</span><br><span class="line"></span><br><span class="line">	127.0.0.1:6379&gt; ZADD kim 1 tian</span><br><span class="line">	(integer) 0</span><br><span class="line">	127.0.0.1:6379&gt; zadd kim 2 yuan 3 xing</span><br><span class="line">	(integer) 2</span><br><span class="line">	127.0.0.1:6379&gt; zcount kim 1 2</span><br><span class="line">	(integer) 2</span><br><span class="line">	127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line">  ZRANK  key member  :返回有序集合中指定成员的所有</span><br><span class="line">  ZRANGE KEY START STOP  [WITHSCORES]:通过索引区间返回有序集合成指定区间内的成员(低到高)</span><br><span class="line">	ZRANGEBYSCORE KEY MIN MAX [WITHSCORES] [LIMIT] :通过分数返回有序集合指定区间内的成员</span><br><span class="line">	ZREVRANGE KEY START STOP [WITHSCORES] :返回有序集中是定区间内的成员，通过索引，分数从高到底</span><br><span class="line">	ZREVERANGEBYSCORE KEY MAX MIN [WITHSCORES] :返回有序集中指定分数区间的成员，分数从高到低排序</span><br><span class="line"></span><br><span class="line">删除语法：</span><br><span class="line">	DEL KEY   : 移除集合</span><br><span class="line">	ZREM key member [member...] 移除有序集合中的一个或多个成员</span><br><span class="line">	ZREMRANGEBYSCORE KEY MIN MAX  :移除有序集合中给定的分数区间的所有成员。</span><br><span class="line">	ZREMRANGEBYSCORE KEY MIN MAX  :移除有序集合中给定的分数区间的所有成员。</span><br><span class="line">	</span><br><span class="line">ZINCRBY KEY INCREMENT MEMBER :增加member元素的分数increment，返回值是更改后的分数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10-10-HyperLogLog"><a href="#10-10-HyperLogLog" class="headerlink" title="10.10 HyperLogLog"></a>10.10 HyperLogLog</h5><p><strong>常用命令</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">PFADD key element [element ...] : 添加指定元素到HyperLoglog中</span><br><span class="line">PFCOUNT KEY [key ...] :返回给定 HyperLogLog的基数估算值</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] :将过个HyperLogLog 合并为一个HyperLoglog</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p>基数不大，数据量不大就用不上，会有点大材小用浪费空间</p>
<p>有局限性，就是指能统计基数数量，而没办法去知道具体的内容是什么</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">统计注册 IP 数</span><br><span class="line">统计每日访问 IP 数</span><br><span class="line">统计页面实时 UV 数</span><br><span class="line">统计在线用户数</span><br><span class="line">统计用户每天搜索不同词条的个数</span><br><span class="line">统计真实文章阅读数</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200722003520767.png" class="" title="#####">

<h5 id="10-11-geospatial-地理位置"><a href="#10-11-geospatial-地理位置" class="headerlink" title="10.11 geospatial 地理位置"></a>10.11 geospatial 地理位置</h5><p>GEORANDIUSBYMEMBER  找出指定元素周围的其他元素</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200805112212991.png" class="" title="image-20200805112212991">



<h4 id="十一、SpringBoot整合Jedis"><a href="#十一、SpringBoot整合Jedis" class="headerlink" title="十一、SpringBoot整合Jedis"></a>十一、SpringBoot整合Jedis</h4><h5 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h5><pre><code>    我们在使用springboot搭建微服务的时候，在很多时候还是需要redis的高速缓存来缓存一些数据，存储一些高品率访问的数据，如果直接使用redis的话由比较麻烦，在这里，我们使用jedis来实现redis缓存达到高效缓存的目的。
</code></pre>
<h5 id="11-2-引入Jedis依赖"><a href="#11-2-引入Jedis依赖" class="headerlink" title="11.2 引入Jedis依赖"></a>11.2 引入Jedis依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为SpringBoot内默认引用了jedis版本。</p>
<p>所以我们直接引入jedis依赖无需配置jedis的版本号了。</p>
<h5 id="11-3-application-yml"><a href="#11-3-application-yml" class="headerlink" title="11.3 application.yml"></a>11.3 application.yml</h5><p>例如 在application.yml中配置如下信息：</p>
<h4 id="十二、SpringBoot2-x中redis使用（lettuce）"><a href="#十二、SpringBoot2-x中redis使用（lettuce）" class="headerlink" title="十二、SpringBoot2.x中redis使用（lettuce）"></a>十二、SpringBoot2.x中redis使用（lettuce）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">java代码操作Redis，需要使用Jedis，也就是redis支持java的第三方类库</span><br><span class="line">注意：Jedis2.7以上的版本才支持集群操作</span><br></pre></td></tr></table></figure>

<h5 id="12-1-maven配置"><a href="#12-1-maven配置" class="headerlink" title="12.1 maven配置"></a>12.1 maven配置</h5><p>新建SpringBoot2.0.3的WEB工程，在MAVEN的pom.xml文件中加入如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tyx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>lettuce-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认是lettuce客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- redis依赖common-pool 这个依赖一定要添加 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200414004122171.png" class="" title="image-20200715231230345">

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200715231337580.png" class="" title="image-20200715231337580">

<h5 id="12-2-视频中的代码"><a href="#12-2-视频中的代码" class="headerlink" title="12.2 视频中的代码"></a>12.2 视频中的代码</h5><p><strong>POM文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tyx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>lettuce-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认是lettuce客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- redis依赖common-pool 这个依赖一定要添加 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>RedisConfig</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tyx.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> papi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020/7/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.tyx.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> papi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020/7/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java常用编码规范</span></span><br><span class="line"><span class="comment"> * Java规范</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tyx.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tyx.po.User;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> papi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020/7/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis有什么命令，Jedis有什么方法</span></span><br><span class="line"><span class="comment">     * Lettuce-----》RedisTemplate进一步的封装</span></span><br><span class="line"><span class="comment">     *RedisTemplate 方法和命令是肯定不一样的</span></span><br><span class="line"><span class="comment">     * Redis 和 String类型</span></span><br><span class="line"><span class="comment">     * 需求输入一个key</span></span><br><span class="line"><span class="comment">     * 先判断该key是否存在如果不存在则在mysql中进行查询，写入到redis中。并返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRedisValueByKey</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">            <span class="comment">//表示存在值，进行获取</span></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; redis中查询的数据&quot;</span>);</span><br><span class="line">            Object o = redisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">return</span> (String) o;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不存在去mysql中查并且赋值给reids</span></span><br><span class="line">            String val = <span class="string">&quot;redis中不存在的key&quot;</span>;</span><br><span class="line">            log.info(<span class="string">&quot;------&gt;mysql中查询出来的：&quot;</span>+val);</span><br><span class="line">            redisTemplate.opsForValue().set(key,val);</span><br><span class="line">            log.info(<span class="string">&quot;------&gt;mysql中查出的数据存入redis中&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试String类型</span></span><br><span class="line"><span class="comment">     * 需求：用户输入一个redis数据。该key的有效期为28小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireStr</span><span class="params">(String key, String val)</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,val);</span><br><span class="line">        redisTemplate.expire(key,<span class="number">2</span>,TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询用户对象信息</span></span><br><span class="line"><span class="comment">     *  先判断redis中是否存在该key</span></span><br><span class="line"><span class="comment">     *  如果不存在，查询数据库中mysql中的值，并将结果添加到redis中。</span></span><br><span class="line"><span class="comment">     *  如果存在，直接将结果在redis查询，并返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getHashKey</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.opsForHash().hasKey(<span class="string">&quot;user&quot;</span>,id))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;-----&gt;查询redis数据库&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> (User) redisTemplate.opsForHash().get(<span class="string">&quot;user&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;-----&gt;查询mysql数据库&quot;</span>);</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(id);</span><br><span class="line">            user.setAge(<span class="number">18</span>);</span><br><span class="line">            user.setName(<span class="string">&quot;速速&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                @param  h  用户的实体</span></span><br><span class="line"><span class="comment">                @param  hk 用户主键id</span></span><br><span class="line"><span class="comment">                @param  hv 整个对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            redisTemplate.opsForHash().put(<span class="string">&quot;user&quot;</span>,id,user);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tyx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tyx.po.User;</span><br><span class="line"><span class="keyword">import</span> com.tyx.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LettuceDemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        String tyx = userService.getRedisValueByKey(<span class="string">&quot;tyx&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回redis中的值为：&quot;</span> + tyx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User hashKey = userService.getHashKey(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line">        System.out.println(hashKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="12-3-查看Redis客户端信息"><a href="#12-3-查看Redis客户端信息" class="headerlink" title="12.3 查看Redis客户端信息"></a>12.3 查看Redis客户端信息</h5><p>原因：把任何数据保存到redis中时，<strong>都需要进行序列化</strong>，默认使用JdkSerializationRedisSerializer进行数据序列化。所有的key和value还有hashkey和hashvalue的原始字符前，都加了一串字符。</p>
<h4 id="十三、Redis的发布订阅"><a href="#十三、Redis的发布订阅" class="headerlink" title="十三、Redis的发布订阅"></a>十三、Redis的发布订阅</h4><h5 id="13-1-redis发布订阅简介"><a href="#13-1-redis发布订阅简介" class="headerlink" title="13.1 redis发布订阅简介"></a>13.1 redis发布订阅简介</h5><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者（pub）发送消息，订阅者（sub)接受消息。</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Redis 发布订阅(pub/sub)是一种消息通信模式：发送者（pub）发送消息，订阅者（sub)接受消息。</span><br><span class="line">Redis 客户端可以订阅任意数量的频道。</span><br><span class="line">下图展示了频道channel1，以及订阅这个频道的三个客户端---client2，client5和client1之间的关系。</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200722224456077.png" class="" title="image-20200722224456077">

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200809152404791.png" class="" title="image-20200809152404791">

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//订阅端</span></span><br><span class="line"><span class="attr">SUBSCRIBE</span> <span class="string">redischannel</span></span><br><span class="line"><span class="attr">Reading</span> <span class="string">messages ...(press  ctrl-c quit)</span></span><br><span class="line"><span class="attr">//发送端</span></span><br><span class="line"><span class="attr">PUBLIC</span> <span class="string">redischannel &quot;redis channel&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="十四、Redis多数据库"><a href="#十四、Redis多数据库" class="headerlink" title="十四、Redis多数据库"></a>十四、Redis多数据库</h4><h5 id="14-1-Redis下，数据库是由一个整数索引标识，而不是一个数据库名称。默认情况下，一个客户端连接到数据库0。"><a href="#14-1-Redis下，数据库是由一个整数索引标识，而不是一个数据库名称。默认情况下，一个客户端连接到数据库0。" class="headerlink" title="14.1 Redis下，数据库是由一个整数索引标识，而不是一个数据库名称。默认情况下，一个客户端连接到数据库0。"></a>14.1 Redis下，数据库是由一个整数索引标识，而不是一个数据库名称。默认情况下，一个客户端连接到<strong>数据库0</strong>。</h5><p>redis配置问阿金中下面的参数来控制数据库总数：</p>
<p>database 16  //（从0开始 1,2,3…15）</p>
<p><strong>select  数据库</strong>  //数据库的切换</p>
<p><strong>移动数据(将当前key移动另一库)</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">move key 名称  数据库</span><br></pre></td></tr></table></figure>

<h5 id="14-2-数据库清空："><a href="#14-2-数据库清空：" class="headerlink" title="14.2 数据库清空："></a>14.2 数据库清空：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flushdb  ：清除当前数据库的所有key</span><br><span class="line">flushall :清除整个redis的数据库所有key</span><br></pre></td></tr></table></figure>

<h4 id="十五、Redis事务"><a href="#十五、Redis事务" class="headerlink" title="十五、Redis事务"></a>十五、Redis事务</h4><p>Redis事务可以一次执行多个命令，（按顺序地串行化执行，执行中不会被其他命令插入，不许加塞）</p>
<p><strong>简介</strong></p>
<p>Redis事务可以一次指定多个命令（允许在一个单独的步骤中执行一组命令），并且带有一下两个中要的保证：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">批量操作在发送EXEC命令前被放入队列缓存。</span><br><span class="line">收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。</span><br><span class="line">在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令列中。</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Redis会将一个事务中的所有命令序列化，然后按顺序执行</strong></li>
<li><strong>执行中不会被其它命令插入，不许出现加赛行为</strong></li>
</ol>
<p><strong>常用命令</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">DISCARD</span> :<span class="string"></span></span><br><span class="line">	<span class="attr">取消事务，放弃执行事务块内的所有命令。</span></span><br><span class="line"><span class="attr">MULTI</span> :<span class="string"></span></span><br><span class="line">	<span class="attr">标记一个事务块的开始。</span></span><br><span class="line"><span class="attr">EXEC</span> :<span class="string"></span></span><br><span class="line">	<span class="attr">执行所有事务块内的命令。</span></span><br><span class="line"><span class="attr">UNWATCH</span>:<span class="string"></span></span><br><span class="line">	<span class="attr">取消watch命令对所有key的监视。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">WATCH</span> <span class="string">KEY [KEY ...]</span></span><br><span class="line">	:<span class="meta">监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断。</span>	<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>一个事务从开始到执行会经历以下三个阶段：</p>
<p>1、开始事务。</p>
<p>2、命令入队。</p>
<p>3、执行事务。</p>
<h5 id="15-1示例-1-MULTI-EXEC"><a href="#15-1示例-1-MULTI-EXEC" class="headerlink" title="15.1示例 1 MULTI EXEC"></a>15.1示例 1 MULTI EXEC</h5><p>转账功能，A向B转账50元</p>
<p>一个事务的例子，它先以MULTI开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令触发事务</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200725220940140.png" class="" title="image-20200725220940140">

<ol>
<li><strong>输入Multi命令开始，输入的命令都会一次进入命令队列中，但不会执行</strong></li>
<li><strong>知道输入Exce后，Redis会将之前的命令队列中的命令一次执行。</strong></li>
</ol>
<h5 id="15-2-示例-DISCARD放弃队列运行"><a href="#15-2-示例-DISCARD放弃队列运行" class="headerlink" title="15.2 示例 DISCARD放弃队列运行"></a>15.2 示例 DISCARD放弃队列运行</h5><img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200725223959473.png" class="" title="image-20200725223959473">

<ol>
<li><strong>输入MULTI命令，输入的命令都会依次进入命令队列中，但不会执行。</strong></li>
<li><strong>直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</strong></li>
<li><strong>命令队列的过程中可以使用命令DISCARD来放弃队列运行。</strong></li>
</ol>
<h4 id="15-3-示例3事务的错误处理"><a href="#15-3-示例3事务的错误处理" class="headerlink" title="15.3 示例3事务的错误处理"></a>15.3 示例3事务的错误处理</h4><p>事务的错误处理：</p>
<p>如果执行的某个命令报出了错误，则只有报错的命令不会被执行，<strong>而其他的命令都会执行，不会回滚</strong>。</p>
<h5 id="15-4-示例4-事务的错误处理"><a href="#15-4-示例4-事务的错误处理" class="headerlink" title="15.4  示例4 事务的错误处理"></a>15.4  示例4 事务的错误处理</h5><p>事务的错误处理：</p>
<p>队列中的某个命令出现了 报告错误，执行是整个的所有队列都会被取消。</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726083227677.png" class="" title="image-20200726083227677">

<p><strong>由于之前的错误，事务执行失败</strong></p>
<h5 id="15-5-示例5-事务的watch"><a href="#15-5-示例5-事务的watch" class="headerlink" title="15.5 示例5 事务的watch"></a>15.5 示例5 事务的watch</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">WATCH  key [key ...]</span><br><span class="line">:监视一个(或多个)key，如果在事务执行前这个(或这些)key被其他命令所改动，那么事务将被打断。</span><br></pre></td></tr></table></figure>

<p>需求：某一账户在一事务内进行操作，在提交事务前，另一个进程对该账户进行操作。</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726191147022.png" class="" title="image-20200726191147022">

<h5 id="15-6-应用场景"><a href="#15-6-应用场景" class="headerlink" title="15.6 应用场景"></a>15.6 应用场景</h5><p>一组命令必须同时都执行，或者都不执行。</p>
<p>我们想要保证一组命令在执行的过程之中不被其他命令插入。</p>
<p><strong>案例</strong>： 秒杀</p>
<h5 id="15-7-Redis事务的总结"><a href="#15-7-Redis事务的总结" class="headerlink" title="15.7 Redis事务的总结"></a>15.7 Redis事务的总结</h5><p>Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！一次性，顺序性，排他性！执行一些列的命令！</p>
<p><strong>Redis事务没有隔离级别的概念！</strong></p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec</p>
<p><strong>Redis单条命令保存原子性，但是事务不保证原子性！</strong></p>
<p>Redis 事务其实是支持原子性的！即使 Redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。</p>
<h4 id="十六、Redis持久化"><a href="#十六、Redis持久化" class="headerlink" title="十六、Redis持久化"></a>十六、Redis持久化</h4><h5 id="16-1-什么是Redis-持久化？"><a href="#16-1-什么是Redis-持久化？" class="headerlink" title="16.1 什么是Redis 持久化？"></a>16.1 什么是Redis 持久化？</h5><p>持久化就是把内存的数据写到磁盘中去，防止府服务宕机内存数据丢失。</p>
<p>Redis提供了两种持久化方式：<strong>RDB(默认)和AOF</strong></p>
<p><strong>简介</strong></p>
<p>数据存放于：</p>
<p><strong>内存：高效，断电（关机）内存数据会丢失</strong></p>
<p><strong>硬盘：读写速度慢于内存，断电数据不会丢失</strong></p>
<p><strong>Redis持久化存储支持两种方式：RDB和AOF。RDB一定时间取存储文件，AOF默认每秒去存储历史命令，</strong></p>
<p><strong>Redis是支持持久化的内存数据库，也就是说redis需要经常将内存中的数据同步到硬盘来保证持久化。</strong></p>
<h5 id="16-2-RDB"><a href="#16-2-RDB" class="headerlink" title="16.2 RDB"></a>16.2 RDB</h5><p>RDB是Redis DataBase缩写  </p>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘中，那么一旦服务器进程退出，服务器中的数据库的状态也会消失。造成数据的丢失，所以redis提供了持久化的功能。</p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是所说的snapshot快照，它恢复是将卡UN关照文件爱你直接读到内存里。</p>
<p>Redis会单独创建（fock）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，在用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模的数据的恢复，且对于数据恢复的完整性不死非常敏感，那RDB方式要比AOF 方式更加的高效。RDB的缺点是最后一次持久化的数据可能丢失。</p>
<p>功能核心函数rdbSave（生成RDB文件）和rdbLoad（从文件加载内存）两个函数</p>
<ul>
<li><strong>rdbSave：生成RDB文件</strong></li>
<li><strong>rdbLoad：从文件夹杂内存</strong></li>
</ul>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726194030744.png" class="" title="image-20200726194030744">

<p>RDB : 是redis默认的持久化机制</p>
<p>快照是默认的持久化方式。这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为<strong>dump.rdb</strong>。</p>
<p><strong>优点：</strong></p>
<ul>
<li>快照保存数据极快，还原数据极快</li>
<li>适用于灾难备份</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>小内存机器不适合使用，RDB机制符合要求就会照快照</li>
</ul>
<p><strong>快照条件：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、服务器正常关闭：./bin/redis-cli shutdown</span><br><span class="line">2、key满足一定条件，会进行快照</span><br><span class="line"> vim redis.config 搜索save</span><br><span class="line"> /save</span><br><span class="line">save   900  1      //每秒900秒（15分钟）至少1个key发生变化，产生快照</span><br><span class="line">save   300  10     //每300秒  （5分钟）至少10个key发生变化，产生快照</span><br><span class="line">save   60   10000  //每60秒（1分钟）至少10000个key发生变化，产生快照</span><br></pre></td></tr></table></figure>

<h5 id="16-3-AOF"><a href="#16-3-AOF" class="headerlink" title="16.3 AOF"></a>16.3 AOF</h5><p>由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一个快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof持久化方式。</p>
<p>Append-only file：aof比rdb有更好的持久化性，是由于在使用aof持久化方式是，redis会将每一个收到的命令都通过write函数追加到文件中（默认是appendonly.aof)。当redis重启是会通过重新执行文件中保存的写命令来在内存冲重建整个数据库的内容。</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726222819545.png" class="" title="image-20200726222819545">



<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200806232428617.png" class="" title="image-20200806232428617">

<p>每当执行服务器（定时）任务或者函数时flushAppendOnlyFile函数都会被调用，这个函数执行以下两个工作aof写入保存：</p>
<p><strong>WRITE：根据条件，将aof_buf中的缓存写入到AOF文件。</strong></p>
<p><strong>SAVE：根据条件，调用fsync或fdatasync函数，将AOF文件保存到磁盘中。</strong></p>
<p><strong>有三种方式如下（默认是：每秒fsync一次）</strong></p>
<ul>
<li>appendonly yes      //启用aof持久化方式</li>
<li><code>#</code> appendfsync always  //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化</li>
<li>appendfysnceverysec    //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</li>
<li><code>#</code> appendfysnc no        //完全依赖os，性能孔，持久化没保证</li>
</ul>
<p><strong>产生的问题：</strong></p>
<pre><code>aof的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令 100次，问价中必须保存全部的1000条命令，其实有99条都是多余的。
</code></pre>
<h4 id="十七、Redis缓存与数据库一致性"><a href="#十七、Redis缓存与数据库一致性" class="headerlink" title="十七、Redis缓存与数据库一致性"></a>十七、Redis缓存与数据库一致性</h4><h5 id="17-1-实时同步"><a href="#17-1-实时同步" class="headerlink" title="17.1 实时同步"></a>17.1 实时同步</h5><p>对强一直要求比较高的，应采用实时同步方案，即查询缓存查询不到在从DB查询，保存到缓存；更新缓存时，先更新数据库，在将缓存的设置过期（建议不要去更新缓存内容，直接设置缓存过期）。</p>
<p>@Cacheable：查询时使用，注意Long类型需要转换为String类型，否则会抛异常</p>
<p>@CachePut：跟新是使用，使用此注解，一定会从DB上查询数据</p>
<p>@CacheEvict：删除时使用；</p>
<p>@Caching ：组合用法</p>
<h5 id="17-2-异步队列"><a href="#17-2-异步队列" class="headerlink" title="17.2 异步队列"></a>17.2 异步队列</h5><p>对于并发程度高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。</p>
<h5 id="17-3-使用阿里的同步工具canal"><a href="#17-3-使用阿里的同步工具canal" class="headerlink" title="17.3 使用阿里的同步工具canal"></a>17.3 使用阿里的同步工具canal</h5><h5 id="17-4-采用UDF自定义函数的方式"><a href="#17-4-采用UDF自定义函数的方式" class="headerlink" title="17.4 采用UDF自定义函数的方式"></a>17.4 采用UDF自定义函数的方式</h5><p>面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是C/C++语言实现，学习成本高。</p>
<h4 id="十八、总结"><a href="#十八、总结" class="headerlink" title="十八、总结"></a>十八、总结</h4><h5 id="18-1-缓存穿透"><a href="#18-1-缓存穿透" class="headerlink" title="18.1 缓存穿透"></a>18.1 缓存穿透</h5><p>缓存穿透是指查询一个一定不存在的数据，由于缓存时不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p><strong>解决办法</strong>：持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key)，如果有直接返回空，没有则查询后返回，</p>
<p>注意insert时需要清除查询的key，否则即便DB中有值也查询不到（当然可以设置空缓存的过去时间）</p>
<blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据没法安redis内存数据库没有，也就是缓存没有命中，于是向持久层数据量查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<h6 id="18-1-1-布隆过滤器"><a href="#18-1-1-布隆过滤器" class="headerlink" title="18.1.1 布隆过滤器"></a>18.1.1 布隆过滤器</h6><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200809190855071.png" class="" title="image-20200809190855071">

<p>但是这种方法存在两个问题：</p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更过的空间村粗更过的键，因为这当中可能回有很多的空值的键；</p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响；</p>
<h5 id="18-1-2-缓存击穿"><a href="#18-1-2-缓存击穿" class="headerlink" title="18.1.2 缓存击穿"></a>18.1.2 缓存击穿</h5><blockquote>
<p>概念</p>
</blockquote>
<p>这里需要主要的是缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就行在一个屏幕上凿开一个洞</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所有不会出现热点key过期后产生的问题。</p>
<p><strong>加锁互斥</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后盾服务，其他线程没有获得分布式锁的权限，因此只需要等待即可，这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h5 id="18-2-雪崩"><a href="#18-2-雪崩" class="headerlink" title="18.2 雪崩"></a>18.2 雪崩</h5><p><strong>雪崩：缓存大量失效的时候，引发大量查询数据库。</strong></p>
<p><strong>解决办法：</strong></p>
<pre><code>用锁/分布式锁或者队列串行访问

缓存失效时间均匀分布
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果缓存集中在一端时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。</span><br><span class="line"></span><br><span class="line">这个没有完美解决办法，但是可以分析用户的行为，尽量让失效时间点均匀分布。大所属系统设计者考虑用加锁或者队列的方式保证缓存的单线程写，从而避免失效时大量的并发请求落到底层存储系统上。</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>加锁排队。限流—限流算法</strong></p>
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redisde SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功是，在进行koad db 的操作应设缓存；否则，就重试整个get缓存的方法。</p>
<p>SETNX ,是【SET IF NOT EXISTS]的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p>
</li>
<li><p><strong>数据预热</strong></p>
<p>可以通过缓存reload机制，预选去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</li>
</ol>
<h5 id="18-3-热点key"><a href="#18-3-热点key" class="headerlink" title="18.3 热点key"></a>18.3 热点key</h5><pre><code>热点key：某个key访问非常频繁。当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。
</code></pre>
<p>解决办法：</p>
<ol>
<li>使用锁，单机用synchronized ， lock等，分布式使用分布式锁</li>
<li>缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则 异步跟新缓存。</li>
<li>在value设置一个比过去时间t0小的过期时间值t1,当t1过期的时候，延长t1并做更新缓存操作。</li>
<li>设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地跟新实际缓存。</li>
</ol>
<p><strong>案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设并发有10000个请求，想达到对个请求从数据库中获取，其他9999个请求冲redis中获取这种效果</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200727233009577.png" class="" title="image-20200727233009577">

<p>双重检测锁测压：</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200727233804236.png" class="" title="image-20200727233804236">









<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200727225050871.png" class="" title="image-20200727225050871">

<h4 id="十九、可能的问题"><a href="#十九、可能的问题" class="headerlink" title="十九、可能的问题"></a>十九、可能的问题</h4><p>一般来说，要将redis运用于工程项目中，只是用一台Redis是万万不能的，原因如下：</p>
<p>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；（容错性）</p>
<p>2、从容量上，单个redis服务器内存容量有限，就算一台redis服务器内存容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p>
<p>问题：</p>
<ul>
<li>内存容量有限</li>
<li>处理能力有限</li>
<li>无法高可用。</li>
</ul>
<h4 id="二十、主从复制"><a href="#二十、主从复制" class="headerlink" title="二十、主从复制"></a>二十、主从复制</h4><p><strong>简介</strong></p>
<p>电子商务网站上的商品，一般都是一次上传，无数次的浏览的，说专业点的也就是“多读少些”。</p>
<h5 id="20-1主从复制："><a href="#20-1主从复制：" class="headerlink" title="20.1主从复制："></a>20.1主从复制：</h5><p>一个Redis服务可以有多个该服务的复制品，这个Redis服务成为Master，其他的复制成为Slaves</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200728000743754.png" class="" title="image-20200728000743754">

<p>如图中所示：我们将一台Redis服务器作为主库（master），其他的三台作为（salve），主库负责写数据，每次有数据跟新都更新的数据同步到它的所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p>
<p>1、读写分离：不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数据。</p>
<p>2、数据被复制成了好几份，就算一台机器出现故障，也可以使用其它机器的数据快速的恢复。</p>
<p>需要注意的是：Redis主从复制模式中，一台主库可以用用多个从库，一个从库只能属于一个主库。</p>
<h5 id="20-2-Redis主从复制配置"><a href="#20-2-Redis主从复制配置" class="headerlink" title="20.2 Redis主从复制配置"></a>20.2 Redis主从复制配置</h5><p>在Redis中，要实现主从复制架构非常的简单，只需要在从数据库的配置文件中加上如下命令即可：</p>
<p>1、主数据库不需要任务配置，创建爱哪一个从数据库：</p>
<p>redis.config（配置文件信息）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-- port 6380  : 从服务的端口号</span><br><span class="line">--slaveof  127.0.0.1 6379   ：指定主服务器</span><br></pre></td></tr></table></figure>

<p>2、启动从数据库：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./bin/redis-server   ./redis.conf  --port  6380  --slaveof  127.0.0.1   6379</span><br></pre></td></tr></table></figure>

<p>3、登录到从服务客户端</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./bin/redis-cli   -p  6380  -a  redis</span><br></pre></td></tr></table></figure>

<p>4、哨兵模式</p>
<p><strong>简介</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis-Sentinel(哨兵模式)是高可用解决方案，当redis在做master-slave的高可用方案时，假如master宕机了，redis本身（以及其很多客户端）都没有实现自动进行主备切换，而redis-sentinel本身是独立运行的进程，可以部署在其他的与redis集群可通讯的机器中监控redis集群。</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">有了主从复制的实现之后，我们如果想从服务器进行监控，那么在redis2.6以后提供了有个“哨兵”机制，并在2.8版本以后功能稳定起来。</span><br><span class="line">哨兵：故名司仪，就是监控Redis系统的运行状况。</span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200728220027757.png" class="" title="image-20200728220027757">

<p>哨兵模式的特点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、不时地监控redis是否按照预期良好地运行；</span><br><span class="line">2、如果发现某个redis 节点运行出现状况，能够通知另外一个进程（例如它的客户端）；</span><br><span class="line">3、能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master，其他的slave节点会将它所追随的master地址改为被提升为master的salve的新地址。</span><br><span class="line">4、哨兵为客户端提供服务发现，客户端连接哨兵，哨兵提供当前master的地址然后提供服务，如果出现切换，也就是master挂了，哨兵会提供客户端一个新地址。</span><br></pre></td></tr></table></figure>

<h5 id="20-3-基本概述"><a href="#20-3-基本概述" class="headerlink" title="20.3 基本概述"></a>20.3 基本概述</h5><p><strong>高可用</strong></p>
<p>“高可用性（High Availability）”通常用来描述一个系统经过专门的设计，从而减少停工时间，而保证器服务的高可用性。（一直都能用）</p>
<p>高可用：6个99.9999% 全年停机不超过32秒。</p>
<p><strong>高并发</strong></p>
<p><strong>高并发</strong> （High Concurrentcy）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计在保证系统能够同时并行处理的很多请求。</p>
<p>高并发相关商用的一些指标有如下：</p>
<ul>
<li>响应时间（Response Time）</li>
<li>吞吐量（Throughput）</li>
<li>每秒查询率QPS（Query Pre Second），并发用户数等。</li>
</ul>
<p><strong>响应时间</strong>：系统对请求做出响应的时间，例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p>
<p><strong>吞吐量</strong>：单位时间内处理的请求数量。</p>
<p><strong>QPS</strong> ：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有那么明显。</p>
<p>并发用户：同时承载正常使用系统功能的用户数量。例如一个即使通讯系统，同时在线量一定程度上代表</p>
<h5 id="20-4-主从复制的主要作用包括"><a href="#20-4-主从复制的主要作用包括" class="headerlink" title="20.4 主从复制的主要作用包括"></a>20.4 主从复制的主要作用包括</h5><p><strong>1、数据冗余</strong>：主从复制实现了数据热备份，是持久化之外的一种数据冗余的方式。</p>
<p><strong>2、故障恢复</strong>：当主节点出现 问题时，可以由从节点提供服务，实现快速的故障恢复；世界上是以一种服务的冗余。</p>
<p><strong>3、负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由节点提供写的服务，由从节点提供提供读服务（即写redis数据时应用及连接主节点，读redis数据时应该用从节点），人丹服务器的负载；尤其在写少读多的场景下，通过多个从节点分担读负载，可以大大提高redis服务器的并发量。</p>
<p><strong>4、高可用的基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是redis高可用的基础。</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200809172058925.png" class="" title="image-20200809172058925">

<h5 id="20-5-主从复制的原理"><a href="#20-5-主从复制的原理" class="headerlink" title="20.5 主从复制的原理"></a>20.5 主从复制的原理</h5><p>Slave 启动成功连接到master后会发送一个sync命令</p>
<p>Master接收到名，启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕后，master将传送的数据文件到slave，并完成一次完全同步</p>
<p>全量复制：而slave服务在接受到数据库文件数据后，将其存盘并加载内存中。</p>
<p>增量文件：Master继续将新的所有收集的修改命令一次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制）将别自动执行。</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200809175246937.png" class="" title="image-20200809175246937">



<h4 id="二十一、Redis-Cluster集群"><a href="#二十一、Redis-Cluster集群" class="headerlink" title="二十一、Redis Cluster集群"></a>二十一、Redis Cluster集群</h4><p><strong>简介</strong></p>
<h5 id="21-1-集群模式是实际使用最多的模式。"><a href="#21-1-集群模式是实际使用最多的模式。" class="headerlink" title="21.1 集群模式是实际使用最多的模式。"></a>21.1 集群模式是实际使用最多的模式。</h5><p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的的负载均衡的目的。</p>
<p><strong>为什么使用redis-cluster？</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">为了在大流量访问下提供稳定的业务，集群化时存储的必然形态</span><br><span class="line">未来的发展趋势可定是云计算和大数据的紧密结合</span><br><span class="line">只有分布式架构能满足需求</span><br></pre></td></tr></table></figure>

<h5 id="21-2-集群描述"><a href="#21-2-集群描述" class="headerlink" title="21.2 集群描述"></a>21.2 集群描述</h5><p>Redis集群搭建方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">(1)、Twitter开发的twemproxy</span><br><span class="line">(2)、豌豆荚开发的codis</span><br><span class="line">(3)、redis观法的redis-cluster</span><br></pre></td></tr></table></figure>

<p>Redis集群搭建的方式有很多种，但从redis 3.0 之后变动表呢支持redis-cluster集群，志超需要3（master）+3（Slave）才能简历集群。Redis——Cluster采用无中心结构，没个节点保存数据和整个集群状态，每个节点都和其他所有 节点连接。其redis-cluster架构图如下所示：</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200728224937533.png" class="" title="image-20200728224937533">

<p>Redis Cluster集群几点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<p><strong>Redis Cluster集群特点</strong></p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200728225228777.png" class="" title="image-20200728225228777">

<p>1、所有的redis节点彼此互联（PING-PONG)，内部使用二进制协议优化传输速度和带宽。</p>
<p>2、节点的fail是通过集群中超过半数的节点检测失效时才生效。</p>
<p>3、客户端与redis节点直连，不需要中间proxy层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p>
<p>4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配），cluster负责维护</p>
<p>5、redis集群预先分好16384个哈希槽，当需要在redis集群中放置一个key-value时，redis先对key使用crc16算法算出一个结果，然后把结果对16384求余数，这样对每个key都会对应一个编号在0-16383之间的哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。</p>
<h5 id="21-3-Redis-Cluster集群搭建"><a href="#21-3-Redis-Cluster集群搭建" class="headerlink" title="21.3 Redis Cluster集群搭建"></a>21.3 Redis Cluster集群搭建</h5><p>集群搭建参考官网：<a href="https://redis.io/topic/cluster-tutorial">https://redis.io/topic/cluster-tutorial</a></p>
<pre><code>redis集群需要至少三个master节点，我们这里搭建三个master节点，并且给每个master在搭建一个slave节点，总共6个节点，这里用一台机器（可以多台机器部署，修改一下ip地址就可以了）部署6个redis实例，三主三从。搭建集群的步骤如下：
</code></pre>
<ol>
<li><p>创建Redis节点安装目录</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mkdir /root/apps/redis_cluster ：指定目录下  创建 redis_cluster</span><br></pre></td></tr></table></figure></li>
<li><p>在redis_cluster目录，创建7000-7005   6个文件夹下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mkdir 70000 70001 70002 70003 70004 70005</span><br></pre></td></tr></table></figure></li>
<li><p>并将redis-conf分别拷贝到70000-70005文件夹下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cp /opt/redis-5.0.8/redis.conf   ./70000</span><br></pre></td></tr></table></figure></li>
<li><p>修改Redis配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/root/apps/redis_cluster/<span class="number">70000</span></span><br><span class="line"># 关闭保护模式 用于公网访问</span><br><span class="line">    <span class="keyword">protected</span>-mode  no</span><br><span class="line">    port  <span class="number">70000</span></span><br><span class="line"># 开启集群模式</span><br><span class="line">    cluster-enabled  yes</span><br><span class="line">    cluster-config-file nodes-<span class="number">70000.</span>config</span><br><span class="line">    cluster-node-timeout  <span class="number">5000</span></span><br><span class="line"># 后台启动</span><br><span class="line">    daemonize  yes</span><br><span class="line">    pidfile  /<span class="keyword">var</span>/run/redis_70000.pid</span><br><span class="line">    logfile  <span class="string">&quot;70000.log&quot;</span></span><br><span class="line"># dir /redis/data</span><br><span class="line"># 此处绑定ip,可以是阿里内网ip和本地ip也可以直接注释掉该项</span><br><span class="line"># bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"># 用于连接主节点密码</span><br><span class="line">    masterauth redis</span><br><span class="line">#设置redis密码 各个几点请保持密码一致</span><br><span class="line">    requirepass  redis</span><br></pre></td></tr></table></figure></li>
<li><p>依次复制并修改6个redis.conf</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cp ./70000/redis.conf ./70001   :依次进行复制</span><br><span class="line">vim ./70001/redis.conf  : 执行 %s/old/new/g 全部替换 ：wq 保存并退出  即可</span><br></pre></td></tr></table></figure></li>
</ol>
<p>6、依次启动6个节点</p>
<p>将安装的redis目录下的src复制到cluster下，方便启动服务端</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cd /opt/redis-5.0.8  :进入redis安装目录</span><br><span class="line">cp -r  ./src/  /usr/local/redis_cluster/   :将src文件复制到redis——cluster目录中</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./src/redis-server   ./7000/redis.conf</span><br><span class="line">./src/redis-server   ./7001/redis.conf</span><br><span class="line">./src/redis-server   ./7002/redis.conf</span><br><span class="line">./src/redis-server   ./7003/redis.conf</span><br><span class="line">./src/redis-server   ./7004/redis.conf</span><br><span class="line">./src/redis-server   ./7005/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动后，可以用PS查看进程：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ps -ef | grep -i redis</span><br></pre></td></tr></table></figure>

<ol start="7">
<li> 创建集群 </li>
</ol>
<p>   Redis 5版本后 通过redis-cli 客户端命令来创建集群。</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">./src/redis-cli --cluster  create  -a redis 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002  127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

   <img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200802173440118.png" class="" title="image-20200802173440118">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Performing hash slots allocation on 6 nodes</span><br><span class="line"></span><br><span class="line">Trying to optimize slaves allocation for anti-affinity</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200802174653654.png" class="" title="image-20200802174653654">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>Redis Cluster集群验证</p>
<p>在某台机器上（或）连接集群的7001端口的几点：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis-cli</span>  <span class="string">-h 127.0.0.1  -c -p 7000 -a redis   :加参数 -c 可以连接到集群</span></span><br></pre></td></tr></table></figure>

<p>redis cluster在设计的时候，就考虑了去中心化，去中间件，也就是说集群中的每个节点都是平等的关系，都是对等的，每个几点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p>
<p>基本命令</p>
<p><strong>info replication</strong> 通过Cluster Nodes 命令和Cluster Info命令来看看集群的效果</p>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">7000&gt; info replication</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="attr">role</span>:<span class="string">master</span></span><br><span class="line"><span class="attr">connected_slaves</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">slave0</span>:<span class="string">ip=127.0.0.1,port=7004,state=online,offset=1026,lag=1</span></span><br><span class="line"><span class="attr">master_replid</span>:<span class="string">2c2851db4bea0ea2f9d93d60a065e868112c47d7</span></span><br><span class="line"><span class="attr">master_replid2</span>:<span class="string">0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="attr">master_repl_offset</span>:<span class="string">1026</span></span><br><span class="line"><span class="attr">second_repl_offset</span>:<span class="string">-1</span></span><br><span class="line"><span class="attr">repl_backlog_active</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">repl_backlog_size</span>:<span class="string">1048576</span></span><br><span class="line"><span class="attr">repl_backlog_first_byte_offset</span>:<span class="string">1</span></span><br><span class="line"><span class="attr">repl_backlog_histlen</span>:<span class="string">1026</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">7000&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>输入命令cluster nodes</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">7000&gt; cluster nodes</span></span><br><span class="line"><span class="attr">c58e7d40e34251897af3bee6bc6edd7a500f9fa6</span> <span class="string">127.0.0.1:7005@17005 slave 3a7ac96a39a41b395d5459eeac1f17d1f6fd96d7 0 1596391181092 6 connected</span></span><br><span class="line"><span class="attr">71e898b018d1775214a431bd22b3408b055dbb62</span> <span class="string">127.0.0.1:7003@17003 slave 5a191a63e8c2f5dbe945451bca0552426d6e9260 0 1596391182096 4 connected</span></span><br><span class="line"><span class="attr">60335b82c5348215c0dbbbac5b65c769f6668e4e</span> <span class="string">127.0.0.1:7000@17000 myself,master - 0 1596391181000 1 connected 0-5460</span></span><br><span class="line"><span class="attr">5a191a63e8c2f5dbe945451bca0552426d6e9260</span> <span class="string">127.0.0.1:7002@17002 master - 0 1596391183102 3 connected 10923-16383</span></span><br><span class="line"><span class="attr">9cae9ebf31a03c09a82281dcb629aac418e22831</span> <span class="string">127.0.0.1:7004@17004 slave 60335b82c5348215c0dbbbac5b65c769f6668e4e 0 1596391182000 5 connected</span></span><br><span class="line"><span class="attr">3a7ac96a39a41b395d5459eeac1f17d1f6fd96d7</span> <span class="string">127.0.0.1:7001@17001 master - 0 1596391182598 2 connected 5461-10922</span></span><br></pre></td></tr></table></figure>

<p>每个Redis的节点都有一个ID值，此ID将被此特定redis实例永久使用，以便实例在集群上下文中具有唯一的名称。每个节点都都会记住使用此ID的每个其他节点，而不是通过IP或端口号。IP地址和端口可能会发生变化，但唯一的节点标识符在节点的整个生命周期内都不会改变。我们简单称这个标识符为节点ID。</p>
<h5 id="21-4-Redis总结"><a href="#21-4-Redis总结" class="headerlink" title="21.4 Redis总结"></a>21.4 Redis总结</h5><p><strong>简介：</strong></p>
<pre><code> redis cluster 为了保证数据的高可用性，加入了主从模式，一个节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉去数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。
</code></pre>
<p> 集群有ABC三个主节点，如果这3个几点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。</p>
<p>所以我们集群建立的时候，一定腰围每个主节点都添加一个从节点，比如像这样，集群包含主节点A,B,C 以及从节点A1,B1,C1，那么及时B挂掉系统也可以继续正确工作。</p>
<p>B1节点代替了B节点，所有Redis集群将会选择B1节点作为新的主节点，集群将会继续正确的提供服务。当B重新开启后，它就变成B1的从节点。</p>
<p>不过需要注意，如果几点B和B1同时挂掉，Redis集群就无法继续正确的提供服务了。</p>
<h5 id="21-5-关闭集群"><a href="#21-5-关闭集群" class="headerlink" title="21.5 关闭集群"></a>21.5 关闭集群</h5><p>在/root/apps/redis_cluster 目录下编写脚本文件 ： vim shutdowm.sh</p>
<p>内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-cli</span> <span class="string">-c -h 127.0.0.1 -p 7000 -a redis shutdown</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-cli</span> <span class="string">-c -h 127.0.0.1 -p 7001 -a redis shutdown</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-cli</span> <span class="string">-c -h 127.0.0.1 -p 7002 -a redis shutdown</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-cli</span> <span class="string">-c -h 127.0.0.1 -p 7003 -a redis shutdown</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-cli</span> <span class="string">-c -h 127.0.0.1 -p 7004 -a redis shutdown</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-cli</span> <span class="string">-c -h 127.0.0.1 -p 7005 -a redis shutdown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">chmod</span> <span class="string">u+x shutdown.sh   :然后执行将shutdown.sh变成可执行文件</span></span><br><span class="line"><span class="meta">./shutdown.sh</span>   :<span class="string">在当前目录下启动</span></span><br><span class="line"><span class="meta">查看：</span> <span class="string">ps aux | grep redis</span></span><br><span class="line"><span class="meta">官方：/usr/local/redis_cluster/redis-cli</span> <span class="string">-a xxx -c -h 192.168.5.100 -p 8001</span></span><br><span class="line"><span class="meta">提示：-a</span> <span class="string">：访问服务端密码  ， -c 表示集群模式  ， -h指定ip地址  ，-p指定端口号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-service</span> <span class="string">./70000/redis.conf</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-service</span> <span class="string">./70001/redis.conf</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-service</span> <span class="string">./70002/redis.conf</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-service</span> <span class="string">./70003/redis.conf</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-service</span> <span class="string">./70004/redis.conf</span></span><br><span class="line"><span class="meta">/root/apps/redis_cluster/src/redis-service</span> <span class="string">./70005/redis.conf</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">chmod u+x redisinstall.sh   :然后执行将redisinstall.sh变成可执行文件</span><br><span class="line">./redisinstall.sh</span><br></pre></td></tr></table></figure>

<h4 id="二十二、Redis中的拓展"><a href="#二十二、Redis中的拓展" class="headerlink" title="二十二、Redis中的拓展"></a>二十二、Redis中的拓展</h4><h5 id="22-1-Redis为什么单线程还这么快"><a href="#22-1-Redis为什么单线程还这么快" class="headerlink" title="22.1 Redis为什么单线程还这么快"></a>22.1 Redis为什么单线程还这么快</h5><p>1、误区1：高性能的服务器一定是多线程的？</p>
<p>2、误区2：多线程（CUP上下文会切换！）一定比单线程效率高！</p>
<p>先去CPU&gt;内存&gt;硬盘的速度要有所了解！</p>
<p>核心：redis是将所有的数据全部放在内存中的，所以说使用单线程去炒作效率就是最高的。</p>
<p>多线称（CUP上下文切换：耗时！！！），对于内存来说，如果没有上下文切换效率就是最高的。对此读写就是在CUP上所以Redis 的速度是非常 快的。</p>
<h4 id="二十三、重新配置RedisTemplate"><a href="#二十三、重新配置RedisTemplate" class="headerlink" title="二十三、重新配置RedisTemplate"></a>二十三、重新配置RedisTemplate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yux.redisdemo.redis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment"> * redis配置类</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YUX</span></span><br><span class="line"><span class="comment">17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>   2018年6月6日</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line"> </span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"> </span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"> </span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line"> </span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"> </span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"> </span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line"> </span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line"> </span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line"> </span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"> </span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二十四、重新编写RedisUtils"><a href="#二十四、重新编写RedisUtils" class="headerlink" title="二十四、重新编写RedisUtils"></a>二十四、重新编写RedisUtils</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yux.redisdemo.redis;</span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit; </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate; </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component; </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">14</span></span><br><span class="line"><span class="comment"> * Redis工具类</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YUX</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>   2018年6月7日</span></span><br><span class="line"><span class="comment">17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 26</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * 27</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     *             28</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     *             29</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 44</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * 45</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     *            46</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     * 47</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 53</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * 54</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            55</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     * 56</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 67</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * 68</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     *            69</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123; </span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 83</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * 84</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            85</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     * 86</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 92</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * 93</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              94</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              95</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     * 96</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 109</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * 110</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              111</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              112</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     *              113</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     * 114</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 130</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * 131</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              132</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     *              133</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 134</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 143</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * 144</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              145</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     *              146</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 147</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 157</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * 158</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     *             159</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     *             160</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     * 161</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 167</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * 168</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            169</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     * 170</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 176</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * 177</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            178</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     *            179</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     * 180</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 192</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * 193</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     *             194</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     *             195</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     *             196</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     * 197</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map); </span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                expire(key, time); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 212</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * 213</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              214</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     *              215</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              216</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     * 217</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 229</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * 230</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              231</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     *              232</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              233</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     *              234</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     * 235</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value); </span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">           e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 250</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     * 251</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     *             252</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     *             253</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123; </span><br><span class="line">        redisTemplate.opsForHash().delete(key, item); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 259</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     * 260</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     *             261</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     *             262</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     * 263</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 269</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     * 270</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     *             271</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     *             272</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     *             273</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 274</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 280</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     * 281</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     *             282</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     *             283</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     *             284</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 285</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 292</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * 293</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            294</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 295</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 306</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     * 307</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              308</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              309</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     * 310</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 321</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     * 322</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     *               323</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     *               324</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     * 325</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 336</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     * 337</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     *               338</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     *               339</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     *               340</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     * 341</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">              expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 355</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     * 356</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            357</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 358</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 369</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     * 370</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     *               371</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     *               372</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     * 373</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 386</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     * 387</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              388</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     *              389</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     *              390</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 391</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">try</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 402</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     * 403</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     *            404</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 405</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 416</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     * 417</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              418</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     *              419</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 420</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 431</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * 432</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              433</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              434</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     *              435</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 436</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 467</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * 468</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              469</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              470</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     *              471</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 472</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 484</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * 485</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 486</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              487</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              488</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     *              489</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 490</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 504</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     * 505</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              506</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     *              507</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              508</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 509</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 521</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     * 522</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     *              523</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     *              524</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *              525</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     * 526</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二十五、哨兵模式"><a href="#二十五、哨兵模式" class="headerlink" title="二十五、哨兵模式"></a>二十五、哨兵模式</h4><h5 id="25-1-自动选举master的模式"><a href="#25-1-自动选举master的模式" class="headerlink" title="25.1 自动选举master的模式"></a>25.1 自动选举master的模式</h5><p>主从切换的技术方式是：当主机宕机之后，需要手动把一台服务器切换为主机服务器，这就需要人工干预，费时费力，还会造成一段时间内服务器不可用，这是一种不推荐的方式，更多的时候，我们在考虑使用哨兵模式。redis中2.8之后提供了哨兵模式来解决这个问题。</p>
<p>哨兵模式是一种特殊的模式，首先redis提供哨兵命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵同过发送命令，等待redis 服务器响应，从而监控运行的多个redis实例。</strong></p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200809181028449.png" class="" title="image-20200809181028449">

<p>这里的哨兵有两个作用：</p>
<ul>
<li>通过发送命令，让redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵检测到master宕机，会自动将slave切换成为master，然后通过发布订阅模式通知其他的服务器，修改配置文件，让她们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<img src="/2022/02/13/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200809181628868.png" class="" title="image-20200809181628868">

<p>假设主服务宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主管的认为服务器不可用，这个现象称为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一侧投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让哥哥哨兵把自己监控的服务器实现切换主机，这个过程称为可观下线。</p>
<p>我们目前的装填是一主二从！</p>
<p>1、配置哨兵配置文件sentinel.conf</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># sentinel monitor  被监控的名称host port <span class="number">1</span></span><br><span class="line">sentinel monitor  myredis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>候命的这个数字1，代表主机挂了，slave投票看让谁阶梯称为主机，票数最多的，就会称为主机！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel  bin/sentinel.conf</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级买手动到自动，更加健壮！</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>redis不好在线扩容，集群容量一旦达到上限，在向扩容就十分麻烦！</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</li>
</ul>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1GT4y1A756?spm_id_from=333.788.b_636f6d6d656e74.19">原视频地址</a></p>
<p><a href="https://gitee.com/yooome/golang">原文章地址</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
        <tag>[object Object]</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes相关知识</title>
    <url>/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr>
<span id="more"></span>

<h2 id="Kubernetes详细教程"><a href="#Kubernetes详细教程" class="headerlink" title="Kubernetes详细教程"></a>Kubernetes详细教程</h2><h3 id="1-Kubernetes介绍"><a href="#1-Kubernetes介绍" class="headerlink" title="1. Kubernetes介绍"></a>1. Kubernetes介绍</h3><h4 id="1-1-应用部署方式演变"><a href="#1-1-应用部署方式演变" class="headerlink" title="1.1 应用部署方式演变"></a>1.1 应用部署方式演变</h4><p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200505183738289.png" class="" title="image-20200505183738289">

<p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li><strong>Swarm</strong>：Docker自己的容器编排工具</li>
<li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200524150339551.png" class="" title="image-20200524150339551">

<h4 id="1-2-kubernetes简介"><a href="#1-2-kubernetes简介" class="headerlink" title="1.2 kubernetes简介"></a>1.2 kubernetes简介</h4><img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200406232838722.png" class="" title="image-20200406232838722">

<p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p>
<p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<h4 id="1-3-kubernetes组件"><a href="#1-3-kubernetes组件" class="headerlink" title="1.3 kubernetes组件"></a>1.3 kubernetes组件</h4><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p>
<blockquote>
<p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p>
<blockquote>
<p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
<p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</blockquote>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200406184656917.png" class="" title="image-20200406184656917">

<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
</li>
</ol>
<p>这样，外界用户就可以访问集群中的nginx服务了</p>
<h4 id="1-4-kubernetes概念"><a href="#1-4-kubernetes概念" class="headerlink" title="1.4 kubernetes概念"></a>1.4 kubernetes概念</h4><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>
<h3 id="2-kubernetes集群环境搭建"><a href="#2-kubernetes集群环境搭建" class="headerlink" title="2. kubernetes集群环境搭建"></a>2. kubernetes集群环境搭建</h3><h4 id="2-1-前置知识点"><a href="#2-1-前置知识点" class="headerlink" title="2.1 前置知识点"></a>2.1 前置知识点</h4><p>目前生产部署Kubernetes 集群主要有两种方式：</p>
<p><strong>kubeadm</strong></p>
<p>Kubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。</p>
<p>官方地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
<p><strong>二进制包</strong></p>
<p>从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。</p>
<p>Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200404094800622.png" class="" title="image-20200404094800622">

<h4 id="2-2-kubeadm-部署方式介绍"><a href="#2-2-kubeadm-部署方式介绍" class="headerlink" title="2.2 kubeadm 部署方式介绍"></a>2.2 kubeadm 部署方式介绍</h4><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p>
<ul>
<li>创建一个Master 节点kubeadm init</li>
<li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li>
</ul>
<h4 id="2-3-安装要求"><a href="#2-3-安装要求" class="headerlink" title="2.3 安装要求"></a>2.3 安装要求</h4><p>在开始之前，部署Kubernetes 集群机器需要满足以下几个条件：</p>
<ul>
<li>一台或多台机器，操作系统CentOS7.x-86_x64</li>
<li>硬件配置：2GB 或更多RAM，2 个CPU 或更多CPU，硬盘30GB 或更多</li>
<li>集群中所有机器之间网络互通</li>
<li>可以访问外网，需要拉取镜像</li>
<li>禁止swap 分区</li>
</ul>
<h4 id="2-4-最终目标"><a href="#2-4-最终目标" class="headerlink" title="2.4 最终目标"></a>2.4 最终目标</h4><ul>
<li>在所有节点上安装Docker 和kubeadm</li>
<li>部署Kubernetes Master</li>
<li>部署容器网络插件</li>
<li>部署Kubernetes Node，将节点加入Kubernetes 集群中</li>
<li>部署Dashboard Web 页面，可视化查看Kubernetes 资源</li>
</ul>
<h4 id="2-5-准备环境"><a href="#2-5-准备环境" class="headerlink" title="2.5 准备环境"></a>2.5 准备环境</h4><img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20210609000002940.png" class="" title="image-20210609000002940">

<table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">IP地址</th>
<th align="left">组件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">master01</td>
<td align="left">192.168.5.3</td>
<td align="left">docker，kubectl，kubeadm，kubelet</td>
</tr>
<tr>
<td align="left">node01</td>
<td align="left">192.168.5.4</td>
<td align="left">docker，kubectl，kubeadm，kubelet</td>
</tr>
<tr>
<td align="left">node02</td>
<td align="left">192.168.5.5</td>
<td align="left">docker，kubectl，kubeadm，kubelet</td>
</tr>
</tbody></table>
<h4 id="2-6-环境初始化"><a href="#2-6-环境初始化" class="headerlink" title="2.6 环境初始化"></a>2.6 环境初始化</h4><h5 id="2-6-1-检查操作系统的版本"><a href="#2-6-1-检查操作系统的版本" class="headerlink" title="2.6.1 检查操作系统的版本"></a>2.6.1 检查操作系统的版本</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方式下安装kubernetes集群要求Centos版本要在7.5或之上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">Centos Linux <span class="number">7.5</span>.<span class="number">1804</span> (Core)</span><br></pre></td></tr></table></figure>

<h5 id="2-6-2-主机名解析"><a href="#2-6-2-主机名解析" class="headerlink" title="2.6.2 主机名解析"></a>2.6.2 主机名解析</h5><p>为了方便集群节点间的直接调用，在这个配置一下主机名解析，企业中推荐使用内部DNS服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机名成解析 编辑三台服务器的/etc/hosts文件，添加下面内容</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">90.100</span> master</span><br><span class="line"><span class="number">192.168</span>.<span class="number">90.106</span> node1</span><br><span class="line"><span class="number">192.168</span>.<span class="number">90.107</span> node2</span><br></pre></td></tr></table></figure>

<h5 id="2-6-3-时间同步"><a href="#2-6-3-时间同步" class="headerlink" title="2.6.3 时间同步"></a>2.6.3 时间同步</h5><p>kubernetes要求集群中的节点时间必须精确一直，这里使用chronyd服务从网络同步时间</p>
<p>企业中建议配置内部的会见同步服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动chronyd服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl start chronyd</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable chronyd</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># date</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-4-禁用iptable和firewalld服务"><a href="#2-6-4-禁用iptable和firewalld服务" class="headerlink" title="2.6.4  禁用iptable和firewalld服务"></a>2.6.4  禁用iptable和firewalld服务</h5><p>kubernetes和docker 在运行的中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 关闭firewalld服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># 2 关闭iptables服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop iptables</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable iptables</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-5-禁用selinux"><a href="#2-6-5-禁用selinux" class="headerlink" title="2.6.5 禁用selinux"></a>2.6.5 禁用selinux</h5><p>selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 /etc/selinux/config 文件，修改SELINUX的值为disable</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<h5 id="2-6-6-禁用swap分区"><a href="#2-6-6-禁用swap分区" class="headerlink" title="2.6.6 禁用swap分区"></a>2.6.6 禁用swap分区</h5><p>swap分区指的是虚拟内存分区，它的作用是物理内存使用完，之后将磁盘空间虚拟成内存来使用，启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备，但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑分区配置文件/etc/fstab，注释掉swap分区一行</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">注释掉 /dev/mapper/centos<span class="literal">-swap</span> swap</span><br><span class="line"><span class="comment"># /dev/mapper/centos-swap swap</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-7-修改linux的内核参数"><a href="#2-6-7-修改linux的内核参数" class="headerlink" title="2.6.7 修改linux的内核参数"></a>2.6.7 修改linux的内核参数</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改linux的内核采纳数，添加网桥过滤和地址转发功能</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置：</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf</span><span class="literal">-call</span><span class="literal">-ip6tables</span> = <span class="number">1</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf</span><span class="literal">-call</span><span class="literal">-iptables</span> = <span class="number">1</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sysctl -p</span></span><br><span class="line"><span class="comment"># 加载网桥过滤模块</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># modprobe br_netfilter</span></span><br><span class="line"><span class="comment"># 查看网桥过滤模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep br_netfilter</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-8-配置ipvs功能"><a href="#2-6-8-配置ipvs功能" class="headerlink" title="2.6.8 配置ipvs功能"></a>2.6.8 配置ipvs功能</h5><p>在Kubernetes中Service有两种带来模型，一种是基于iptables的，一种是基于ipvs的两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动载入ipvs模块</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.安装ipset和ipvsadm</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install ipset ipvsadmin -y</span></span><br><span class="line"><span class="comment"># 2.添加需要加载的模块写入脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF&gt; /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 3.为脚本添加执行权限</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># chmod +x /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment"># 4.执行脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># /bin/bash /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment"># 5.查看对应的模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-9-安装docker"><a href="#2-6-9-安装docker" class="headerlink" title="2.6.9 安装docker"></a>2.6.9 安装docker</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、切换镜像源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、查看当前镜像源中支持的docker版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum list docker-ce --showduplicates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、安装特定版本的docker-ce</span></span><br><span class="line"><span class="comment"># 必须制定--setopt=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、添加一个配置文件</span></span><br><span class="line"><span class="comment">#Docker 在默认情况下使用Vgroup Driver为cgroupfs，而Kubernetes推荐使用systemd来替代cgroupfs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /etc/docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF&gt; /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、启动dokcer</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable docker</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-10-安装Kubernetes组件"><a href="#2-6-10-安装Kubernetes组件" class="headerlink" title="2.6.10 安装Kubernetes组件"></a>2.6.10 安装Kubernetes组件</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、由于kubernetes的镜像在国外，速度比较慢，这里切换成国内的镜像源</span></span><br><span class="line"><span class="comment"># 2、编辑/etc/yum.repos.d/kubernetes.repo,添加下面的配置</span></span><br><span class="line">[<span class="type">kubernetes</span>]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes<span class="literal">-el7</span><span class="literal">-x86_64</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgchech=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum<span class="literal">-key</span>.gpg</span><br><span class="line">			http://mirrors.aliyun.com/kubernetes/yum/doc/rpm<span class="literal">-package</span><span class="literal">-key</span>.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、安装kubeadm、kubelet和kubectl</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、配置kubelet的cgroup</span></span><br><span class="line"><span class="comment">#编辑/etc/sysconfig/kubelet, 添加下面的配置</span></span><br><span class="line">KUBELET_CGROUP_ARGS=<span class="string">&quot;--cgroup-driver=systemd&quot;</span></span><br><span class="line">KUBE_PROXY_MODE=<span class="string">&quot;ipvs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、设置kubelet开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable kubelet</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-11-准备集群镜像"><a href="#2-6-11-准备集群镜像" class="headerlink" title="2.6.11 准备集群镜像"></a>2.6.11 准备集群镜像</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm config images list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line"><span class="comment"># 此镜像kubernetes的仓库中，由于网络原因，无法连接，下面提供了一种替换方案</span></span><br><span class="line">images=(</span><br><span class="line">	kube<span class="literal">-apiserver</span>:v1.<span class="number">17.4</span></span><br><span class="line">	kube<span class="literal">-controller</span><span class="literal">-manager</span>:v1.<span class="number">17.4</span></span><br><span class="line">	kube<span class="literal">-scheduler</span>:v1.<span class="number">17.4</span></span><br><span class="line">	kube<span class="literal">-proxy</span>:v1.<span class="number">17.4</span></span><br><span class="line">	pause:<span class="number">3.1</span></span><br><span class="line">	etcd:<span class="number">3.4</span>.<span class="number">3</span><span class="literal">-0</span></span><br><span class="line">	coredns:<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$</span>&#123;images[<span class="selector-tag">@</span>]&#125;;<span class="keyword">do</span></span><br><span class="line">	docker pull registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">	docker tag registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">	docker rmi registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> </span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-6-11-集群初始化"><a href="#2-6-11-集群初始化" class="headerlink" title="2.6.11 集群初始化"></a>2.6.11 集群初始化</h5><blockquote>
<p>下面的操作只需要在master节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm init \</span></span><br><span class="line">	-<span class="literal">-apiserver</span><span class="literal">-advertise</span><span class="literal">-address</span>=<span class="number">192.168</span>.<span class="number">90.100</span> \</span><br><span class="line">	-<span class="literal">-image</span><span class="literal">-repository</span> registry.aliyuncs.com/google_containers \</span><br><span class="line">	-<span class="literal">-kubernetes</span><span class="literal">-version</span>=v1.<span class="number">17.4</span> \</span><br><span class="line">	-<span class="literal">-service</span><span class="literal">-cidr</span>=<span class="number">10.96</span>.<span class="number">0.0</span>/<span class="number">12</span> \</span><br><span class="line">	-<span class="literal">-pod</span><span class="literal">-network</span><span class="literal">-cidr</span>=<span class="number">10.244</span>.<span class="number">0.0</span>/<span class="number">16</span></span><br><span class="line"><span class="comment"># 创建必要文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir -p $HOME/.kube</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面的操作只需要在node节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubeadm join <span class="number">192.168</span>.<span class="number">0.100</span>:<span class="number">6443</span> -<span class="literal">-token</span> awk15p.t6bamck54w69u4s8 \</span><br><span class="line">    -<span class="literal">-discovery</span><span class="literal">-token</span><span class="literal">-ca</span><span class="literal">-cert</span><span class="literal">-hash</span> sha256:a94fa09562466d32d29523ab6cff122186f1127599fa4dcd5fa0152694f17117 </span><br></pre></td></tr></table></figure>

<p>在master上查看节点信息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME    STATUS   ROLES     AGE   VERSION</span><br><span class="line">master  NotReady  master   <span class="number">6</span>m    v1.<span class="number">17.4</span></span><br><span class="line">node1   NotReady   &lt;none&gt;  <span class="number">22</span>s   v1.<span class="number">17.4</span></span><br><span class="line">node2   NotReady   &lt;none&gt;  <span class="number">19</span>s   v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure>

<h5 id="2-6-13-安装网络插件，只在master节点操作即可"><a href="#2-6-13-安装网络插件，只在master节点操作即可" class="headerlink" title="2.6.13 安装网络插件，只在master节点操作即可"></a>2.6.13 安装网络插件，只在master节点操作即可</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube<span class="literal">-flannel</span>.yml</span><br></pre></td></tr></table></figure>

<p>由于外网不好访问，如果出现无法访问的情况，可以直接用下面的 记得文件名是kube-flannel.yml，位置：/root/kube-flannel.yml内容：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">https://github.com/flannel<span class="literal">-io</span>/flannel/tree/master/Documentation/kube<span class="literal">-flannel</span>.yml</span><br></pre></td></tr></table></figure>



<h5 id="2-6-14-使用kubeadm-reset重置集群"><a href="#2-6-14-使用kubeadm-reset重置集群" class="headerlink" title="2.6.14 使用kubeadm reset重置集群"></a>2.6.14 使用kubeadm reset重置集群</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在master节点之外的节点进行操作</span><br><span class="line">kubeadm reset</span><br><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">rm -rf /var/lib/cni/</span><br><span class="line">rm -rf /var/lib/kubelet/*</span><br><span class="line">rm -rf /etc/cni/</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">##重启kubelet</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">##重启docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h5 id="2-6-15-重启kubelet和docker"><a href="#2-6-15-重启kubelet和docker" class="headerlink" title="2.6.15 重启kubelet和docker"></a>2.6.15 重启kubelet和docker</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启kubelet</span></span><br><span class="line">systemctl restart kubelet</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>使用配置文件启动fannel</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl apply <span class="operator">-f</span> kube<span class="literal">-flannel</span>.yml</span><br></pre></td></tr></table></figure>

<p>等待它安装完毕 发现已经是 集群的状态已经是Ready</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/2232696-20210621233106024-1676033717.png" class="" title="img">

<h5 id="2-6-16-kubeadm中的命令"><a href="#2-6-16-kubeadm中的命令" class="headerlink" title="2.6.16 kubeadm中的命令"></a>2.6.16 kubeadm中的命令</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 新的token</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm token create --print-join-command</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-集群测试"><a href="#2-7-集群测试" class="headerlink" title="2.7 集群测试"></a>2.7 集群测试</h4><h5 id="2-7-1-创建一个nginx服务"><a href="#2-7-1-创建一个nginx服务" class="headerlink" title="2.7.1 创建一个nginx服务"></a>2.7.1 创建一个nginx服务</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx  -<span class="literal">-image</span>=nginx:<span class="number">1.14</span><span class="literal">-alpine</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7-2-暴露端口"><a href="#2-7-2-暴露端口" class="headerlink" title="2.7.2 暴露端口"></a>2.7.2 暴露端口</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl expose deploy nginx  -<span class="literal">-port</span>=<span class="number">80</span> -<span class="literal">-target</span><span class="literal">-port</span>=<span class="number">80</span>  -<span class="literal">-type</span>=NodePort</span><br></pre></td></tr></table></figure>

<h5 id="2-7-3-查看服务"><a href="#2-7-3-查看服务" class="headerlink" title="2.7.3 查看服务"></a>2.7.3 查看服务</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl get pod,svc</span><br></pre></td></tr></table></figure>

<h5 id="2-7-4-查看pod"><a href="#2-7-4-查看pod" class="headerlink" title="2.7.4 查看pod"></a>2.7.4 查看pod</h5><img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/2232696-20210621233130477-111035427.png" class="" title="img">

<p>浏览器测试结果：</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/2232696-20210621233157075-1117518703.png" class="" title="img">

<h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h3><h4 id="3-1-资源管理介绍"><a href="#3-1-资源管理介绍" class="headerlink" title="3.1 资源管理介绍"></a>3.1 资源管理介绍</h4><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p>
<blockquote>
<p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p>
<p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>Pod</code>中，而kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。</p>
<p>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了<code>Service</code>资源实现这个功能。</p>
<p>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种<code>存储</code>系统。</p>
</blockquote>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200406225334627.png" class="" title="image-20200406225334627">

<blockquote>
<p>学习kubernetes的核心，就是学习如何对集群上的<code>Pod、Pod控制器、Service、存储</code>等各种资源进行操作</p>
</blockquote>
<h4 id="3-2-YAML语言介绍"><a href="#3-2-YAML语言介绍" class="headerlink" title="3.2 YAML语言介绍"></a>3.2 YAML语言介绍</h4><p>YAML是一个类似 XML、JSON 的标记性语言。它强调以<strong>数据</strong>为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称”一种人性化的数据格式语言”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;heima&gt;</span><br><span class="line">    &lt;age&gt;15&lt;/age&gt;</span><br><span class="line">    &lt;address&gt;Beijing&lt;/address&gt;</span><br><span class="line">&lt;/heima&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heima:</span><br><span class="line">  age: 15</span><br><span class="line">  address: Beijing</span><br></pre></td></tr></table></figure>

<p>YAML的语法比较简单，主要有下面几个：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格( 低版本限制 )</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
<p>YAML支持以下几种数据类型：</p>
<ul>
<li>纯量：单个的、不可再分的值</li>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期</span></span><br><span class="line"><span class="comment"># 1 布尔类型</span></span><br><span class="line"><span class="attr">c1:</span> <span class="literal">true</span> <span class="string">(或者True)</span></span><br><span class="line"><span class="comment"># 2 整型</span></span><br><span class="line"><span class="attr">c2:</span> <span class="number">234</span></span><br><span class="line"><span class="comment"># 3 浮点型</span></span><br><span class="line"><span class="attr">c3:</span> <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 4 null类型 </span></span><br><span class="line"><span class="attr">c4:</span> <span class="string">~</span>  <span class="comment"># 使用~表示null</span></span><br><span class="line"><span class="comment"># 5 日期类型</span></span><br><span class="line"><span class="attr">c5:</span> <span class="number">2018-02-17</span>    <span class="comment"># 日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="comment"># 6 时间类型</span></span><br><span class="line"><span class="attr">c6:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment"># 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"><span class="comment"># 7 字符串类型</span></span><br><span class="line"><span class="attr">c7:</span> <span class="string">heima</span>     <span class="comment"># 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 </span></span><br><span class="line"><span class="attr">c8:</span> <span class="string">line1</span></span><br><span class="line">    <span class="string">line2</span>     <span class="comment"># 字符串过多的情况可以拆成多行，每一行会被转化成一个空格</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">heima:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Beijing</span></span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">heima:</span> &#123;<span class="attr">age:</span> <span class="number">15</span>,<span class="attr">address:</span> <span class="string">Beijing</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">顺义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">昌平</span>  </span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">顺义</span>,<span class="string">昌平</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小提示：</p>
<p>1 书写yaml切记<code>:</code> 后面要加一个空格</p>
<p>2 如果需要将多段yaml配置放在一个文件中，中间要使用<code>---</code>分隔</p>
<p>3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确</p>
<p><a href="https://www.json2yaml.com/convert-yaml-to-json">https://www.json2yaml.com/convert-yaml-to-json</a></p>
</blockquote>
<h4 id="3-3-资源管理方式"><a href="#3-3-资源管理方式" class="headerlink" title="3.3 资源管理方式"></a>3.3 资源管理方式</h4><ul>
<li><p>命令式对象管理：直接使用命令去操作kubernetes资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl run nginx<span class="literal">-pod</span> -<span class="literal">-image</span>=nginx:<span class="number">1.17</span>.<span class="number">1</span> -<span class="literal">-port</span>=<span class="number">80</span></span><br></pre></td></tr></table></figure></li>
<li><p>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl create/patch <span class="operator">-f</span> nginx<span class="literal">-pod</span>.yaml</span><br></pre></td></tr></table></figure></li>
<li><p>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl apply <span class="operator">-f</span> nginx<span class="literal">-pod</span>.yaml</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">操作对象</th>
<th align="left">适用环境</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">命令式对象管理</td>
<td align="left">对象</td>
<td align="left">测试</td>
<td align="left">简单</td>
<td align="left">只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td align="left">命令式对象配置</td>
<td align="left">文件</td>
<td align="left">开发</td>
<td align="left">可以审计、跟踪</td>
<td align="left">项目大时，配置文件多，操作麻烦</td>
</tr>
<tr>
<td align="left">声明式对象配置</td>
<td align="left">目录</td>
<td align="left">开发</td>
<td align="left">支持目录操作</td>
<td align="left">意外情况下难以调试</td>
</tr>
</tbody></table>
<h5 id="3-3-1-命令式对象管理"><a href="#3-3-1-命令式对象管理" class="headerlink" title="3.3.1 命令式对象管理"></a>3.3.1 命令式对象管理</h5><p><strong>kubectl命令</strong></p>
<p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl [command] [type] [name] [flags]</span><br></pre></td></tr></table></figure>

<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete</p>
<p><strong>type</strong>：指定资源类型，比如deployment、pod、service</p>
<p><strong>name</strong>：指定资源的名称，名称大小写敏感</p>
<p><strong>flags</strong>：指定额外的可选参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有pod</span></span><br><span class="line">kubectl get pod </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个pod</span></span><br><span class="line">kubectl get pod pod_name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个pod,以yaml格式展示结果</span></span><br><span class="line">kubectl get pod pod_name -o yaml</span><br></pre></td></tr></table></figure>

<p><strong>资源类型</strong></p>
<p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure>

<p>经常使用的资源有下面这些：</p>
<table>
<thead>
<tr>
<th align="left">资源分类</th>
<th align="left">资源名称</th>
<th align="left">缩写</th>
<th align="left">资源作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">集群级别资源</td>
<td align="left">nodes</td>
<td align="left">no</td>
<td align="left">集群组成部分</td>
</tr>
<tr>
<td align="left">namespaces</td>
<td align="left">ns</td>
<td align="left">隔离Pod</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">pod资源</td>
<td align="left">pods</td>
<td align="left">po</td>
<td align="left">装载容器</td>
</tr>
<tr>
<td align="left">pod资源控制器</td>
<td align="left">replicationcontrollers</td>
<td align="left">rc</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">replicasets</td>
<td align="left">rs</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">deployments</td>
<td align="left">deploy</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">daemonsets</td>
<td align="left">ds</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">jobs</td>
<td align="left"></td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">cronjobs</td>
<td align="left">cj</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">horizontalpodautoscalers</td>
<td align="left">hpa</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">statefulsets</td>
<td align="left">sts</td>
<td align="left">控制pod资源</td>
</tr>
<tr>
<td align="left">服务发现资源</td>
<td align="left">services</td>
<td align="left">svc</td>
<td align="left">统一pod对外接口</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">ingress</td>
<td align="left">ing</td>
<td align="left">统一pod对外接口</td>
</tr>
<tr>
<td align="left">存储资源</td>
<td align="left">volumeattachments</td>
<td align="left"></td>
<td align="left">存储</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">persistentvolumes</td>
<td align="left">pv</td>
<td align="left">存储</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">persistentvolumeclaims</td>
<td align="left">pvc</td>
<td align="left">存储</td>
</tr>
<tr>
<td align="left">配置资源</td>
<td align="left">configmaps</td>
<td align="left">cm</td>
<td align="left">配置</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">secrets</td>
<td align="left"></td>
<td align="left">配置</td>
</tr>
</tbody></table>
<p><strong>操作</strong></p>
<p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl --help</span><br></pre></td></tr></table></figure>

<p>经常使用的操作有下面这些：</p>
<table>
<thead>
<tr>
<th align="left">命令分类</th>
<th align="left">命令</th>
<th align="left">翻译</th>
<th align="left">命令作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本命令</td>
<td align="left">create</td>
<td align="left">创建</td>
<td align="left">创建一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">edit</td>
<td align="left">编辑</td>
<td align="left">编辑一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">get</td>
<td align="left">获取</td>
<td align="left">获取一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">patch</td>
<td align="left">更新</td>
<td align="left">更新一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">delete</td>
<td align="left">删除</td>
<td align="left">删除一个资源</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">explain</td>
<td align="left">解释</td>
<td align="left">展示资源文档</td>
</tr>
<tr>
<td align="left">运行和调试</td>
<td align="left">run</td>
<td align="left">运行</td>
<td align="left">在集群中运行一个指定的镜像</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">expose</td>
<td align="left">暴露</td>
<td align="left">暴露资源为Service</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">describe</td>
<td align="left">描述</td>
<td align="left">显示资源内部信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">logs</td>
<td align="left">日志输出容器在 pod 中的日志</td>
<td align="left">输出容器在 pod 中的日志</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">attach</td>
<td align="left">缠绕进入运行中的容器</td>
<td align="left">进入运行中的容器</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">exec</td>
<td align="left">执行容器中的一个命令</td>
<td align="left">执行容器中的一个命令</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">cp</td>
<td align="left">复制</td>
<td align="left">在Pod内外复制文件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">rollout</td>
<td align="left">首次展示</td>
<td align="left">管理资源的发布</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">scale</td>
<td align="left">规模</td>
<td align="left">扩(缩)容Pod的数量</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">autoscale</td>
<td align="left">自动调整</td>
<td align="left">自动调整Pod的数量</td>
</tr>
<tr>
<td align="left">高级命令</td>
<td align="left">apply</td>
<td align="left">rc</td>
<td align="left">通过文件对资源进行配置</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">label</td>
<td align="left">标签</td>
<td align="left">更新资源上的标签</td>
</tr>
<tr>
<td align="left">其他命令</td>
<td align="left">cluster-info</td>
<td align="left">集群信息</td>
<td align="left">显示集群信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">version</td>
<td align="left">版本</td>
<td align="left">显示当前Server和Client的版本</td>
</tr>
</tbody></table>
<p>下面以一个namespace / pod的创建和删除简单演示下命令的使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个namespace</span></span><br><span class="line">[root@master ~]# kubectl create namespace dev</span><br><span class="line">namespace/dev created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取namespace</span></span><br><span class="line">[root@master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   21h</span><br><span class="line">dev               Active   21s</span><br><span class="line">kube-node-lease   Active   21h</span><br><span class="line">kube-public       Active   21h</span><br><span class="line">kube-system       Active   21h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在此namespace下创建并运行一个nginx的Pod</span></span><br><span class="line">[root@master ~]# kubectl run pod --image=nginx:latest -n dev</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/pod created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看新创建的pod</span></span><br><span class="line">[root@master ~]# kubectl get pod -n dev</span><br><span class="line">NAME  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod   1/1     Running   0          21s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的pod</span></span><br><span class="line">[root@master ~]# kubectl delete pod pod-864f9875b9-pcw7x</span><br><span class="line">pod &quot;pod&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的namespace</span></span><br><span class="line">[root@master ~]# kubectl delete ns dev</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-命令式对象配置"><a href="#3-3-2-命令式对象配置" class="headerlink" title="3.3.2 命令式对象配置"></a>3.3.2 命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p>
<p>1） 创建一个nginxpod.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br></pre></td></tr></table></figure>

<p>2）执行create命令，创建资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f nginxpod.yaml</span></span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br></pre></td></tr></table></figure>

<p>此时发现创建了两个资源对象，分别是namespace和pod</p>
<p>3）执行get命令，查看资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]#  kubectl get -f nginxpod.yaml</span><br><span class="line">NAME            STATUS   AGE</span><br><span class="line">namespace/dev   Active   18s</span><br><span class="line"></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginxpod    1/1     Running   0          17s</span><br></pre></td></tr></table></figure>

<p>这样就显示了两个资源对象的信息</p>
<p>4）执行delete命令，删除资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl delete -f nginxpod.yaml</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br><span class="line">pod &quot;nginxpod&quot; deleted</span><br></pre></td></tr></table></figure>

<p>此时发现两个资源对象被删除了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line">    命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-声明式对象配置"><a href="#3-3-3-声明式对象配置" class="headerlink" title="3.3.3 声明式对象配置"></a>3.3.3 声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先执行一次kubectl apply -f yaml文件，发现创建了资源</span></span><br><span class="line">[root@master ~]#  kubectl apply -f nginxpod.yaml</span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动</span></span><br><span class="line">[root@master ~]#  kubectl apply -f nginxpod.yaml</span><br><span class="line">namespace/dev unchanged</span><br><span class="line">pod/nginxpod unchanged</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line">    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）</span><br><span class="line">    使用apply操作资源：</span><br><span class="line">        如果资源不存在，就创建，相当于 kubectl create</span><br><span class="line">        如果资源已存在，就更新，相当于 kubectl patch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：kubectl可以在node节点上运行吗 ?</p>
</blockquote>
<p>kubectl的运行是需要进行配置的，它的配置文件是$HOME/.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp  -r  HOME/.kube   node1: HOME/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用推荐: 三种方式应该怎么用 ?</p>
</blockquote>
<p>创建/更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml</p>
<p>删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml</p>
<p>查询资源 使用命令式对象管理 kubectl get(describe) 资源名称</p>
<h3 id="4-实战入门"><a href="#4-实战入门" class="headerlink" title="4. 实战入门"></a>4. 实战入门</h3><p>本章节将介绍如何在kubernetes集群中部署一个nginx服务，并且能够对其进行访问。</p>
<h4 id="4-1-Namespace"><a href="#4-1-Namespace" class="headerlink" title="4.1 Namespace"></a>4.1 Namespace</h4><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p>
<p>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。</p>
<p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200407100850484.png" class="" title="image-20200407100850484">

<p>kubernetes在集群启动之后，会默认创建几个namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl  get namespace</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   45h     #  所有未指定Namespace的对象都会被分配在default命名空间</span><br><span class="line">kube-node-lease   Active   45h     #  集群节点之间的心跳维护，v1.13开始引入</span><br><span class="line">kube-public       Active   45h     #  此命名空间下的资源可以被所有人访问（包括未认证用户）</span><br><span class="line">kube-system       Active   45h     #  所有由Kubernetes系统创建的资源都处于这个命名空间</span><br></pre></td></tr></table></figure>

<p>下面来看namespace资源的具体操作：</p>
<h5 id="4-1-1-查看"><a href="#4-1-1-查看" class="headerlink" title="4.1.1 查看"></a>4.1.1 <strong>查看</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1 查看所有的ns  命令：kubectl get ns</span></span><br><span class="line">[root@master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   45h</span><br><span class="line">kube-node-lease   Active   45h</span><br><span class="line">kube-public       Active   45h     </span><br><span class="line">kube-system       Active   45h     </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 查看指定的ns   命令：kubectl get ns ns名称</span></span><br><span class="line">[root@master ~]# kubectl get ns default</span><br><span class="line">NAME      STATUS   AGE</span><br><span class="line">default   Active   45h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span></span><br><span class="line">[root@master ~]# kubectl get ns default -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2021-05-08T04:44:16Z&quot;</span><br><span class="line">  name: default</span><br><span class="line">  resourceVersion: &quot;151&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default</span><br><span class="line">  uid: 7405f73a-e486-43d4-9db6-145f1409f090</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 查看ns详情  命令：kubectl describe ns ns名称</span></span><br><span class="line">[root@master ~]# kubectl describe ns default</span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active  # Active 命名空间正在使用中  Terminating 正在删除命名空间</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ResourceQuota 针对namespace做的资源限制</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LimitRange针对namespace中的每个组件做的资源限制</span></span><br><span class="line">No resource quota.</span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure>

<h5 id="4-1-2-创建"><a href="#4-1-2-创建" class="headerlink" title="4.1.2 创建"></a>4.1.2 <strong>创建</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建namespace</span></span><br><span class="line">[root@master ~]# kubectl create ns dev</span><br><span class="line">namespace/dev created</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-删除"><a href="#4-1-3-删除" class="headerlink" title="4.1.3 删除"></a>4.1.3 <strong>删除</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除namespace</span></span><br><span class="line">[root@master ~]# kubectl delete ns dev</span><br><span class="line">namespace &quot;dev&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-配置方式"><a href="#4-1-4-配置方式" class="headerlink" title="4.1.4 配置方式"></a>4.1.4 <strong>配置方式</strong></h5><p>首先准备一个yaml文件：ns-dev.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f ns-dev.yaml</p>
<p>删除：kubectl delete -f ns-dev.yaml</p>
<h4 id="4-2-Pod"><a href="#4-2-Pod" class="headerlink" title="4.2 Pod"></a>4.2 Pod</h4><p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</p>
<p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200407121501907.png" class="" title="image-20200407121501907">

<p>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get pod -n kube-system</span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-6955765f44-68g6v         1/1     Running   0          2d1h</span><br><span class="line">kube-system   coredns-6955765f44-cs5r8         1/1     Running   0          2d1h</span><br><span class="line">kube-system   etcd-master                      1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-apiserver-master            1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-controller-manager-master   1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-flannel-ds-amd64-47r25      1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-flannel-ds-amd64-ls5lh      1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-proxy-685tk                 1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-proxy-87spt                 1/1     Running   0          2d1h</span><br><span class="line">kube-system   kube-scheduler-master            1/1     Running   0          2d1h</span><br></pre></td></tr></table></figure>

<h5 id="4-2-1-创建并运行"><a href="#4-2-1-创建并运行" class="headerlink" title="4.2.1 创建并运行"></a>4.2.1 创建并运行</h5><p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令格式： kubectl run (pod控制器名称) [参数]</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> --image  指定Pod的镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --port   指定端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --namespace  指定namespace</span></span><br><span class="line">[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev </span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-查看pod信息"><a href="#4-2-2-查看pod信息" class="headerlink" title="4.2.2 查看pod信息"></a>4.2.2 查看pod信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod基本信息</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          43s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod的详细信息</span></span><br><span class="line">[root@master ~]# kubectl describe pod nginx -n dev</span><br><span class="line">Name:         nginx</span><br><span class="line">Namespace:    dev</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         node1/192.168.5.4</span><br><span class="line">Start Time:   Wed, 08 May 2021 09:29:24 +0800</span><br><span class="line">Labels:       pod-template-hash=5ff7956ff6</span><br><span class="line">              run=nginx</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.244.1.23</span><br><span class="line">IPs:</span><br><span class="line">  IP:           10.244.1.23</span><br><span class="line">Controlled By:  ReplicaSet/nginx</span><br><span class="line">Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    Container ID:   docker://4c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c</span><br><span class="line">    Image:          nginx:latest</span><br><span class="line">    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7</span><br><span class="line">    Port:           80/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Wed, 08 May 2021 09:30:01 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-hwvvw (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  default-token-hwvvw:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-hwvvw</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From               Message</span><br><span class="line">  ----    ------     ----       ----               -------</span><br><span class="line">  Normal  Scheduled  &lt;unknown&gt;  default-scheduler  Successfully assigned dev/nginx-5ff7956ff6-fg2db to node1</span><br><span class="line">  Normal  Pulling    4m11s      kubelet, node1     Pulling image &quot;nginx:latest&quot;</span><br><span class="line">  Normal  Pulled     3m36s      kubelet, node1     Successfully pulled image &quot;nginx:latest&quot;</span><br><span class="line">  Normal  Created    3m36s      kubelet, node1     Created container nginx</span><br><span class="line">  Normal  Started    3m36s      kubelet, node1     Started container nginx</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-访问Pod"><a href="#4-2-3-访问Pod" class="headerlink" title="4.2.3 访问Pod"></a>4.2.3 访问Pod</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取podIP</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP             NODE    ... </span><br><span class="line">nginx   1/1     Running   0          190s   10.244.1.23   node1   ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">访问POD</span></span><br><span class="line">[root@master ~]# curl http://10.244.1.23:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-删除指定Pod"><a href="#4-2-4-删除指定Pod" class="headerlink" title="4.2.4 删除指定Pod"></a>4.2.4 删除指定Pod</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除指定Pod</span></span><br><span class="line">[root@master ~]# kubectl delete pod nginx -n dev</span><br><span class="line">pod &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时，显示删除Pod成功，但是再查询，发现又新产生了一个</span> </span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          21s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时要想删除Pod，必须删除Pod控制器</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先来查询一下当前namespace下的Pod控制器</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n  dev</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           9m7s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，删除此PodPod控制器</span></span><br><span class="line">[root@master ~]# kubectl delete deploy nginx -n dev</span><br><span class="line">deployment.apps &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 稍等片刻，再查询Pod，发现Pod被删除了</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">No resources found in dev namespace.</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-配置操作"><a href="#4-2-5-配置操作" class="headerlink" title="4.2.5 配置操作"></a>4.2.5 配置操作</h5><p>创建一个pod-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f pod-nginx.yaml</p>
<p>删除：kubectl delete -f pod-nginx.yaml</p>
<h4 id="4-3-Label"><a href="#4-3-Label" class="headerlink" title="4.3 Label"></a>4.3 Label</h4><p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p>
<p>Label的特点：</p>
<ul>
<li>一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li>
<li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li>
<li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li>
</ul>
<p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p>
<blockquote>
<p>一些常用的Label 示例如下：</p>
<ul>
<li>版本标签：”version”:”release”, “version”:”stable”……</li>
<li>环境标签：”environment”:”dev”，”environment”:”test”，”environment”:”pro”</li>
<li>架构标签：”tier”:”frontend”，”tier”:”backend”</li>
</ul>
</blockquote>
<p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p>
<p>Label用于给某个资源对象定义标识</p>
<p>Label Selector用于查询和筛选拥有某些标签的资源对象</p>
<p>当前有两种Label Selector：</p>
<ul>
<li><p>基于等式的Label Selector</p>
<p>name = slave: 选择所有包含Label中key=”name”且value=”slave”的对象</p>
<p>env != production: 选择所有包括Label中的key=”env”且value不等于”production”的对象</p>
</li>
<li><p>基于集合的Label Selector</p>
<p>name in (master, slave): 选择所有包含Label中的key=”name”且value=”master”或”slave”的对象</p>
<p>name not in (frontend): 选择所有包含Label中的key=”name”且value不等于”frontend”的对象</p>
</li>
</ul>
<p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如：</p>
<p>name=slave，env!=production</p>
<p>name not in (frontend)，env!=production</p>
<h5 id="4-3-1-命令方式"><a href="#4-3-1-命令方式" class="headerlink" title="4.3.1 命令方式"></a>4.3.1 命令方式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为pod资源打标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx-pod version=1.0 -n dev</span><br><span class="line">pod/nginx-pod labeled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为pod资源更新标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx-pod version=2.0 -n dev --overwrite</span><br><span class="line">pod/nginx-pod labeled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看标签</span></span><br><span class="line">[root@master ~]# kubectl get pod nginx-pod  -n dev --show-labels</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx-pod   1/1     Running   0          10m   version=2.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 筛选标签</span></span><br><span class="line">[root@master ~]# kubectl get pod -n dev -l version=2.0  --show-labels</span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx-pod   1/1     Running   0          17m   version=2.0</span><br><span class="line">[root@master ~]# kubectl get pod -n dev -l version!=2.0 --show-labels</span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除标签</span></span><br><span class="line">[root@master ~]# kubectl label pod nginx-pod version- -n dev</span><br><span class="line">pod/nginx-pod labeled</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-配置方式"><a href="#4-3-2-配置方式" class="headerlink" title="4.3.2 配置方式"></a>4.3.2 配置方式</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span> </span><br><span class="line">    <span class="attr">env:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的更新命令了：kubectl apply -f pod-nginx.yaml</p>
<h4 id="4-4-Deployment"><a href="#4-4-Deployment" class="headerlink" title="4.4 Deployment"></a>4.4 Deployment</h4><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p>
<p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200408193950807.png" class="" title="image-20200408193950807">

<h5 id="4-4-1-命令操作"><a href="#4-4-1-命令操作" class="headerlink" title="4.4.1 命令操作"></a>4.4.1 命令操作</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令格式: kubectl create deployment 名称  [参数]</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> --image  指定pod的镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --port   指定端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --replicas  指定创建pod数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --namespace  指定namespace</span></span><br><span class="line">[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --replicas=3 -n dev</span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的Pod</span></span><br><span class="line">[root@master ~]# kubectl get pods -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-5ff7956ff6-6k8cb   1/1     Running   0          19s</span><br><span class="line">nginx-5ff7956ff6-jxfjt   1/1     Running   0          19s</span><br><span class="line">nginx-5ff7956ff6-v6jqw   1/1     Running   0          19s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deployment的信息</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   3/3     3            3           2m42s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UP-TO-DATE：成功升级的副本数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AVAILABLE：可用副本的数量</span></span><br><span class="line">[root@master ~]# kubectl get deploy -n dev -o wide</span><br><span class="line">NAME    READY UP-TO-DATE  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR</span><br><span class="line">nginx   3/3     3         3           2m51s   nginx        nginx:latest        run=nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deployment的详细信息</span></span><br><span class="line">[root@master ~]# kubectl describe deploy nginx -n dev</span><br><span class="line">Name:                   nginx</span><br><span class="line">Namespace:              dev</span><br><span class="line">CreationTimestamp:      Wed, 08 May 2021 11:14:14 +0800</span><br><span class="line">Labels:                 run=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               run=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:latest</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-5ff7956ff6 (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age    From                   Message</span><br><span class="line">  ----    ------             ----   ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  5m43s  deployment-controller  Scaled up replicaset nginx-5ff7956ff6 to 3</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除</span> </span><br><span class="line">[root@master ~]# kubectl delete deploy nginx -n dev</span><br><span class="line">deployment.apps &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="4-4-2-配置操作"><a href="#4-4-2-配置操作" class="headerlink" title="4.4.2 配置操作"></a>4.4.2 配置操作</h5><p>创建一个deploy-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f deploy-nginx.yaml</p>
<p>删除：kubectl delete -f deploy-nginx.yaml</p>
<h4 id="4-5-Service"><a href="#4-5-Service" class="headerlink" title="4.5 Service"></a>4.5 Service</h4><p>通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。</p>
<p>虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p>
<ul>
<li>Pod IP 会随着Pod的重建产生变化</li>
<li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li>
</ul>
<p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p>
<p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200408194716912.png" class="" title="image-20200408194716912">

<h5 id="4-5-1-创建集群内部可访问的Service"><a href="#4-5-1-创建集群内部可访问的Service" class="headerlink" title="4.5.1 创建集群内部可访问的Service"></a>4.5.1 创建集群内部可访问的Service</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暴露Service</span></span><br><span class="line">[root@master ~]# kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev</span><br><span class="line">service/svc-nginx1 exposed</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看service</span></span><br><span class="line">[root@master ~]# kubectl get svc svc-nginx1 -n dev -o wide</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class="line">svc-nginx1   ClusterIP   10.109.179.231   &lt;none&gt;        80/TCP    3m51s   run=nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过这个IP访问当前service对应的POD</span></span><br><span class="line">[root@master ~]# curl 10.109.179.231:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-5-2-创建集群外部也可访问的Service"><a href="#4-5-2-创建集群外部也可访问的Service" class="headerlink" title="4.5.2 创建集群外部也可访问的Service"></a>4.5.2 创建集群外部也可访问的Service</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上面创建的Service的<span class="built_in">type</span>类型为ClusterIP，这个ip地址只用集群内部可访问</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要创建外部也可以访问的Service，需要修改<span class="built_in">type</span>为NodePort</span></span><br><span class="line">[root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev</span><br><span class="line">service/svc-nginx2 exposed</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）</span></span><br><span class="line">[root@master ~]# kubectl get svc  svc-nginx2  -n dev -o wide</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE    SELECTOR</span><br><span class="line">svc-nginx2    NodePort    10.100.94.0      &lt;none&gt;        80:31928/TCP   9s     run=nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如在的电脑主机上通过浏览器访问下面的地址</span></span><br><span class="line">http://192.168.90.100:31928/</span><br></pre></td></tr></table></figure>

<h5 id="4-5-3-删除Service"><a href="#4-5-3-删除Service" class="headerlink" title="4.5.3 删除Service"></a>4.5.3 删除Service</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl delete svc svc-nginx-1 -n dev </span><br><span class="line">service &quot;svc-nginx-1&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="4-5-4-配置方式"><a href="#4-5-4-配置方式" class="headerlink" title="4.5.4 配置方式"></a>4.5.4 配置方式</h5><p>创建一个svc-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.109</span><span class="number">.179</span><span class="number">.231</span> <span class="comment">#固定svc的内网ip</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：kubectl create -f svc-nginx.yaml</p>
<p>删除：kubectl delete -f svc-nginx.yaml</p>
<blockquote>
<p><strong>小结</strong></p>
<p>至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。</p>
</blockquote>
<h3 id="5-Pod详解"><a href="#5-Pod详解" class="headerlink" title="5. Pod详解"></a>5. Pod详解</h3><h4 id="5-1-Pod介绍"><a href="#5-1-Pod介绍" class="headerlink" title="5.1 Pod介绍"></a>5.1 Pod介绍</h4><h5 id="5-1-1-Pod结构"><a href="#5-1-1-Pod结构" class="headerlink" title="5.1.1 Pod结构"></a>5.1.1 Pod结构</h5><img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200407121501907-1626781151898.png" class="" title="image-20200407121501907">

<p>每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：</p>
<ul>
<li><p>用户程序所在的容器，数量可多可少</p>
</li>
<li><p>Pause容器，这是每个Pod都会有的一个<strong>根容器</strong>，它的作用有两个：</p>
<ul>
<li><p>可以以它为依据，评估整个Pod的健康状态</p>
</li>
<li><p>可以在根容器上设置Ip地址，其它容器都此Ip（Pod IP），以实现Pod内部的网路通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="5-1-2-Pod定义"><a href="#5-1-2-Pod定义" class="headerlink" title="5.1.2 Pod定义"></a>5.1.2 Pod定义</h5><p>下面是Pod的资源清单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1     #必选，版本号，例如v1</span><br><span class="line">kind: Pod       　 #必选，资源类型，例如 Pod</span><br><span class="line">metadata:       　 #必选，元数据</span><br><span class="line">  name: string     #必选，Pod名称</span><br><span class="line">  namespace: string  #Pod所属的命名空间,默认为&quot;default&quot;</span><br><span class="line">  labels:       　　  #自定义标签列表</span><br><span class="line">    - name: string      　          </span><br><span class="line">spec:  #必选，Pod中容器的详细定义</span><br><span class="line">  containers:  #必选，Pod中容器列表</span><br><span class="line">  - name: string   #必选，容器名称</span><br><span class="line">    image: string  #必选，容器的镜像名称</span><br><span class="line">    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略 </span><br><span class="line">    command: [string]   #容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]      #容器的启动命令参数列表</span><br><span class="line">    workingDir: string  #容器的工作目录</span><br><span class="line">    volumeMounts:       #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string      #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean #是否为只读模式</span><br><span class="line">    ports: #需要暴露的端口库号列表</span><br><span class="line">    - name: string        #端口的名称</span><br><span class="line">      containerPort: int  #容器需要监听的端口号</span><br><span class="line">      hostPort: int       #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string    #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:   #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string  #环境变量名称</span><br><span class="line">      value: string #环境变量的值</span><br><span class="line">    resources: #资源限制和请求的设置</span><br><span class="line">      limits:  #资源限制的设置</span><br><span class="line">        cpu: string     #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string  #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span><br><span class="line">      requests: #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string #内存请求,容器启动的初始可用数量</span><br><span class="line">    lifecycle: #生命周期钩子</span><br><span class="line">        postStart: #容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span><br><span class="line">        preStop: #容器终止前执行此钩子,无论结果如何,容器都会终止</span><br><span class="line">    livenessProbe:  #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span><br><span class="line">      exec:       　 #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged: false</span><br><span class="line">  restartPolicy: [Always | Never | OnFailure]  #Pod的重启策略</span><br><span class="line">  nodeName: &lt;string&gt; #设置NodeName表示将该Pod调度到指定到名称的node节点上</span><br><span class="line">  nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上</span><br><span class="line">  imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">  - name: string</span><br><span class="line">  hostNetwork: false   #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br><span class="line">  volumes:   #在该pod上定义共享存储卷列表</span><br><span class="line">  - name: string    #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">    emptyDir: &#123;&#125;       #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">    hostPath: string   #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">      path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">    secret:       　　　#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span><br><span class="line">      scretname: string  </span><br><span class="line">      items:     </span><br><span class="line">      - key: string</span><br><span class="line">        path: string</span><br><span class="line">    configMap:         #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">      name: string</span><br><span class="line">      items:</span><br><span class="line">      - key: string</span><br><span class="line">        path: string</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">小提示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   在这里，可通过一个命令来查看每种资源的可配置项</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   kubectl explain 资源类型         查看某种资源可以配置的一级属性</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   kubectl explain 资源类型.属性     查看属性的子属性</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl explain pod</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion   &lt;string&gt;</span><br><span class="line">   kind &lt;string&gt;</span><br><span class="line">   metadata     &lt;Object&gt;</span><br><span class="line">   spec &lt;Object&gt;</span><br><span class="line">   status       &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl explain pod.metadata</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: metadata &lt;Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   annotations  &lt;map[string]string&gt;</span><br><span class="line">   clusterName  &lt;string&gt;</span><br><span class="line">   creationTimestamp    &lt;string&gt;</span><br><span class="line">   deletionGracePeriodSeconds   &lt;integer&gt;</span><br><span class="line">   deletionTimestamp    &lt;string&gt;</span><br><span class="line">   finalizers   &lt;[]string&gt;</span><br><span class="line">   generateName &lt;string&gt;</span><br><span class="line">   generation   &lt;integer&gt;</span><br><span class="line">   labels       &lt;map[string]string&gt;</span><br><span class="line">   managedFields        &lt;[]Object&gt;</span><br><span class="line">   name &lt;string&gt;</span><br><span class="line">   namespace    &lt;string&gt;</span><br><span class="line">   ownerReferences      &lt;[]Object&gt;</span><br><span class="line">   resourceVersion      &lt;string&gt;</span><br><span class="line">   selfLink     &lt;string&gt;</span><br><span class="line">   uid  &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li>apiVersion <string> 版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</li>
<li>kind <string> 类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</li>
<li>metadata <Object> 元数据，主要是资源标识和说明，常用的有name、namespace、labels等</li>
<li>spec <Object> 描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
<li>status <Object> 状态信息，里面的内容不需要定义，由kubernetes自动生成</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息</li>
<li>nodeName <String> 根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork <boolean> 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</li>
<li>restartPolicy <string> 重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<h4 id="5-2-Pod配置"><a href="#5-2-Pod配置" class="headerlink" title="5.2 Pod配置"></a>5.2 Pod配置</h4><p>本小节主要来研究<code>pod.spec.containers</code>属性，这也是pod配置中最为关键的一项配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.containers</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器</span><br><span class="line">FIELDS:</span><br><span class="line">   name  &lt;string&gt;     # 容器名称</span><br><span class="line">   image &lt;string&gt;     # 容器需要的镜像地址</span><br><span class="line">   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 </span><br><span class="line">   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表</span><br><span class="line">   env      &lt;[]Object&gt; # 容器环境变量的配置</span><br><span class="line">   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表</span><br><span class="line">   resources &lt;Object&gt;      # 资源限制和资源请求的设置</span><br></pre></td></tr></table></figure>

<h5 id="5-2-1-基本配置"><a href="#5-2-1-基本配置" class="headerlink" title="5.2.1 基本配置"></a>5.2.1 基本配置</h5><p>创建pod-base.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-base</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">heima</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20210617223823675-1626781695411.png" class="" title="image-20210617223823675">

<p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li>
<li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl apply -f pod-base.yaml</span><br><span class="line">pod/pod-base created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod状况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl get pod -n dev</span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-base   1/2     Running   4          95s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过describe查看内部的详情</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经运行起来了一个基本的Pod，虽然它暂时有问题</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl describe pod pod-base -n dev</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-镜像拉取"><a href="#5-2-2-镜像拉取" class="headerlink" title="5.2.2 镜像拉取"></a>5.2.2 镜像拉取</h5><p>创建pod-imagepullpolicy.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-imagepullpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Never</span> <span class="comment"># 用于设置镜像拉取策略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20210617223923659.png" class="" title="image-20210617223923659">

<p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）</li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没远程下载）</li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li>
</ul>
<blockquote>
<p>默认值说明：</p>
<p>如果镜像tag为具体版本号， 默认策略是：IfNotPresent</p>
<p>如果镜像tag为：latest（最终版本） ，默认策略是always</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl create -f pod-imagepullpolicy.yaml</span><br><span class="line">pod/pod-imagepullpolicy created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod详情</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时明显可以看到nginx镜像有一步Pulling image <span class="string">&quot;nginx:1.17.1&quot;</span>的过程</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age               From               Message</span><br><span class="line">  ----     ------     ----              ----               -------</span><br><span class="line">  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-imagePullPolicy to node1</span><br><span class="line">  Normal   Pulling    32s               kubelet, node1     Pulling image &quot;nginx:1.17.1&quot;</span><br><span class="line">  Normal   Pulled     26s               kubelet, node1     Successfully pulled image &quot;nginx:1.17.1&quot;</span><br><span class="line">  Normal   Created    26s               kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    25s               kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Pulled     7s (x3 over 25s)  kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine</span><br><span class="line">  Normal   Created    7s (x3 over 25s)  kubelet, node1     Created container busybox</span><br><span class="line">  Normal   Started    7s (x3 over 25s)  kubelet, node1     Started container busybox</span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-启动命令"><a href="#5-2-3-启动命令" class="headerlink" title="5.2.3 启动命令"></a>5.2.3 启动命令</h5><p>在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p>
<p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p>
<p>创建pod-command.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-command</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]</span><br></pre></td></tr></table></figure>

<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20210617224457945.png" class="" title="image-20210617224457945">

<p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p>
<blockquote>
<p>稍微解释下上面命令的意思：</p>
<p>“/bin/sh”,”-c”, 使用sh执行命令</p>
<p>touch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件</p>
<p>while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl create  -f pod-command.yaml</span><br><span class="line">pod/pod-command created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时发现两个pod都正常运行了</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl get pods pod-command -n dev</span><br><span class="line">NAME          READY   STATUS   RESTARTS   AGE</span><br><span class="line">pod-command   2/2     Runing   0          2s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入pod中的busybox容器，查看文件内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补充一个命令: kubectl <span class="built_in">exec</span>  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如，可以查看txt文件的内容</span></span><br><span class="line">[root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh</span><br><span class="line">/ # tail -f /tmp/hello.txt</span><br><span class="line">14:44:19</span><br><span class="line">14:44:22</span><br><span class="line">14:44:25</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特别说明：</span><br><span class="line">    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。</span><br><span class="line"> 1 如果command和args均没有写，那么用Dockerfile的配置。</span><br><span class="line"> 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command</span><br><span class="line"> 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数</span><br><span class="line"> 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</span><br></pre></td></tr></table></figure>

<h5 id="5-2-4-环境变量"><a href="#5-2-4-环境变量" class="headerlink" title="5.2.4 环境变量"></a>5.2.4 环境变量</h5><p>创建pod-env.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;</span>]</span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>env，环境变量，用于在pod中的容器设置环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-env.yaml</span><br><span class="line">pod/pod-env created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器，输出环境变量</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh</span><br><span class="line">/ # echo $username</span><br><span class="line">admin</span><br><span class="line">/ # echo $password</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p>
<h5 id="5-2-5-端口设置"><a href="#5-2-5-端口设置" class="headerlink" title="5.2.5 端口设置"></a>5.2.5 端口设置</h5><p>本小节来介绍容器的端口设置，也就是containers的ports选项。</p>
<p>首先看下ports支持的子选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.containers.ports</span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: ports &lt;[]Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的		</span><br><span class="line">   containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)</span><br><span class="line">   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) </span><br><span class="line">   hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)</span><br><span class="line">   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</span><br></pre></td></tr></table></figure>

<p>接下来，编写一个测试案例，创建pod-ports.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-ports</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 设置容器暴露的端口列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-ports.yaml</span><br><span class="line">pod/pod-ports created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在下面可以明显看到配置信息</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-ports -n dev -o yaml</span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:1.17.1</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      name: nginx-port</span><br><span class="line">      protocol: TCP</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>访问容器中的程序需要使用的是<code>Podip:containerPort</code></p>
<h5 id="5-2-6-资源配额"><a href="#5-2-6-资源配额" class="headerlink" title="5.2.6 资源配额"></a>5.2.6 资源配额</h5><p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p>
<ul>
<li>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</li>
<li>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</li>
</ul>
<p>可以通过上面两个选项设置资源的上下限。</p>
<p>接下来，编写一个测试案例，创建pod-resources.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-resources</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span> <span class="comment"># 内存限制</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span>  <span class="comment"># 内存限制</span></span><br></pre></td></tr></table></figure>

<p>在这对cpu和memory的单位做一个说明：</p>
<ul>
<li>cpu：core数，可以为整数或小数</li>
<li>memory： 内存大小，可以使用Gi、Mi、G、M等形式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml</span><br><span class="line">pod/pod-resources created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看发现pod运行正常</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE  </span><br><span class="line">pod-resources   1/1     Running   0          39s   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，停止Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete  -f pod-resources.yaml</span><br><span class="line">pod &quot;pod-resources&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑pod，修改resources.requests.memory的值为10Gi</span></span><br><span class="line">[root@k8s-master01 ~]# vim pod-resources.yaml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次启动pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml</span><br><span class="line">pod/pod-resources created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod状态，发现Pod启动失败</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-resources -n dev -o wide</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE          </span><br><span class="line">pod-resources   0/1     Pending   0          20s    </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod详情会发现，如下提示</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod pod-resources -n dev</span><br><span class="line">......</span><br><span class="line">Warning  FailedScheduling  35s   default-scheduler  0/3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn&#x27;t tolerate, 2 Insufficient memory.(内存不足)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Pod生命周期"><a href="#5-3-Pod生命周期" class="headerlink" title="5.3 Pod生命周期"></a>5.3 Pod生命周期</h4><p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li>pod创建过程</li>
<li>运行初始化容器（init container）过程</li>
<li>运行主容器（main container）<ul>
<li>容器启动后钩子（post start）、容器终止前钩子（pre stop）</li>
<li>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</li>
</ul>
</li>
<li>pod终止过程</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200412111402706-1626782188724.png" class="" title="image-20200412111402706">

<p>在整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p>
<ul>
<li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ul>
<h5 id="5-3-1-创建和终止"><a href="#5-3-1-创建和终止" class="headerlink" title="5.3.1 创建和终止"></a>5.3.1 创建和终止</h5><p><strong>pod的创建过程</strong></p>
<ol>
<li><p>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</p>
</li>
<li><p>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p>
</li>
<li><p>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</p>
</li>
<li><p>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</p>
</li>
<li><p>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</p>
</li>
<li><p>apiServer将接收到的pod状态信息存入etcd中</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200406184656917-1626782168787.png" class="" title="image-20200406184656917"></li>
</ol>
<p><strong>pod的终止过程</strong></p>
<ol>
<li>用户向apiServer发送删除pod对象的命令</li>
<li>apiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li>
<li>将pod标记为terminating状态</li>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li>
<li>pod对象中的容器进程收到停止信号</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li>
<li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li>
</ol>
<h5 id="5-3-2-初始化容器"><a href="#5-3-2-初始化容器" class="headerlink" title="5.3.2 初始化容器"></a>5.3.2 初始化容器</h5><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p>
<ol>
<li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li>
<li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li>
</ol>
<p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p>
<ul>
<li>提供主容器镜像中不具备的工具程序或自定义代码</li>
<li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li>
</ul>
<p>接下来做一个案例，模拟下面这个需求：</p>
<p>假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p>
<p>为了简化测试，事先规定好mysql<code>(192.168.90.14)</code>和redis<code>(192.168.90.15)</code>服务器的地址</p>
<p>创建pod-initcontainer.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-initcontainer</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.90.14 -c 1 ; do echo waiting for mysql...; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.90.15 -c 1 ; do echo waiting for reids...; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-initcontainer.yaml</span><br><span class="line">pod/pod-initcontainer created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行</span></span><br><span class="line">root@k8s-master01 ~]# kubectl describe pod  pod-initcontainer -n dev</span><br><span class="line">........</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  49s   default-scheduler  Successfully assigned dev/pod-initcontainer to node1</span><br><span class="line">  Normal  Pulled     48s   kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine</span><br><span class="line">  Normal  Created    48s   kubelet, node1     Created container test-mysql</span><br><span class="line">  Normal  Started    48s   kubelet, node1     Started container test-mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 动态查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-initcontainer -n dev -w</span><br><span class="line">NAME                             READY   STATUS     RESTARTS   AGE</span><br><span class="line">pod-initcontainer                0/1     Init:0/2   0          15s</span><br><span class="line">pod-initcontainer                0/1     Init:1/2   0          52s</span><br><span class="line">pod-initcontainer                0/1     Init:1/2   0          53s</span><br><span class="line">pod-initcontainer                0/1     PodInitializing   0          89s</span><br><span class="line">pod-initcontainer                1/1     Running           0          90s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化</span></span><br><span class="line">[root@k8s-master01 ~]# ifconfig ens33:1 192.168.90.14 netmask 255.255.255.0 up</span><br><span class="line">[root@k8s-master01 ~]# ifconfig ens33:2 192.168.90.15 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-钩子函数"><a href="#5-3-3-钩子函数" class="headerlink" title="5.3.3 钩子函数"></a>5.3.3 钩子函数</h5><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败了会重启容器</li>
<li>pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li>
</ul>
<p>钩子处理器支持使用下面三种方式定义动作：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span> </span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCPSocket：在当前容器尝试访问指定的socket</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTTPGet：在当前容器中向某url发起http请求</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.3</span> <span class="comment">#主机地址</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-hook-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span> </span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器停止之前停止nginx服务</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-hook-exec.yaml</span><br><span class="line">pod/pod-hook-exec created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods  pod-hook-exec -n dev -o wide</span><br><span class="line">NAME           READY   STATUS     RESTARTS   AGE    IP            NODE    </span><br><span class="line">pod-hook-exec  1/1     Running    0          29s    10.244.2.48   node2   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问pod</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.2.48</span><br><span class="line">postStart...</span><br></pre></td></tr></table></figure>

<h5 id="5-3-4-容器探测"><a href="#5-3-4-容器探测" class="headerlink" title="5.3.4 容器探测"></a>5.3.4 容器探测</h5><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</li>
<li>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</li>
</ul>
<blockquote>
<p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p>
</blockquote>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">tcpSocket:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面以liveness probes为例，做几个演示：</p>
<p><strong>方式一：Exec</strong></p>
<p>创建pod-liveness-exec.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/cat&quot;</span>,<span class="string">&quot;/tmp/hello.txt&quot;</span>] <span class="comment"># 执行一个查看文件的命令</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-liveness-exec.yaml</span><br><span class="line">pod/pod-liveness-exec created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-liveness-exec -n dev</span><br><span class="line">......</span><br><span class="line">  Normal   Created    20s (x2 over 50s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    20s (x2 over 50s)  kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Killing    20s                kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line">  Warning  Unhealthy  0s (x5 over 40s)   kubelet, node1     Liveness probe failed: cat: can&#x27;t open &#x27;/tmp/hello11.txt&#x27;: No such file or directory</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察上面的信息就会发现nginx容器启动之后就进行了健康检查</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查失败之后，容器被<span class="built_in">kill</span>掉，然后尝试进行重启（这是重启策略的作用，后面讲解）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-liveness-exec -n dev</span><br><span class="line">NAME                READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod-liveness-exec   0/1     CrashLoopBackOff   2          3m19s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二：TCPSocket</strong></p>
<p>创建pod-liveness-tcpsocket.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-tcpsocket</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 尝试访问8080端口</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-liveness-tcpsocket.yaml</span><br><span class="line">pod/pod-liveness-tcpsocket created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-liveness-tcpsocket -n dev</span><br><span class="line">......</span><br><span class="line">  Normal   Scheduled  31s                            default-scheduler  Successfully assigned dev/pod-liveness-tcpsocket to node2</span><br><span class="line">  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image &quot;nginx:1.17.1&quot; already present on machine</span><br><span class="line">  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx</span><br><span class="line">  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx</span><br><span class="line">  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp 10.244.2.44:8080: connect: connection refused</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察上面的信息，发现尝试访问8080端口,但是失败了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-liveness-tcpsocket  -n dev</span><br><span class="line">NAME                     READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod-liveness-tcpsocket   0/1     CrashLoopBackOff   2          3m19s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：HTTPGet</strong></p>
<p>创建pod-liveness-httpget.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span>  <span class="comment"># 其实就是访问http://127.0.0.1:80/hello  </span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span> <span class="comment">#URI地址</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-liveness-httpget.yaml</span><br><span class="line">pod/pod-liveness-httpget created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod pod-liveness-httpget -n dev</span><br><span class="line">.......</span><br><span class="line">  Normal   Pulled     6s (x3 over 64s)  kubelet, node1     Container image &quot;nginx:1.17.1&quot; already present on machine</span><br><span class="line">  Normal   Created    6s (x3 over 64s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    6s (x3 over 63s)  kubelet, node1     Started container nginx</span><br><span class="line">  Warning  Unhealthy  6s (x6 over 56s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404</span><br><span class="line">  Normal   Killing    6s (x2 over 36s)  kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察上面信息，尝试访问路径，但是未找到,出现404错误</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-liveness-httpget -n dev</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-liveness-httpget   1/1     Running   5          3m17s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p>至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.containers.livenessProbe</span><br><span class="line">FIELDS:</span><br><span class="line">   exec &lt;Object&gt;  </span><br><span class="line">   tcpSocket    &lt;Object&gt;</span><br><span class="line">   httpGet      &lt;Object&gt;</span><br><span class="line">   initialDelaySeconds  &lt;integer&gt;  # 容器启动后等待多少秒执行第一次探测</span><br><span class="line">   timeoutSeconds       &lt;integer&gt;  # 探测超时时间。默认1秒，最小1秒</span><br><span class="line">   periodSeconds        &lt;integer&gt;  # 执行探测的频率。默认是10秒，最小1秒</span><br><span class="line">   failureThreshold     &lt;integer&gt;  # 连续探测失败多少次才被认定为失败。默认是3。最小值是1</span><br><span class="line">   successThreshold     &lt;integer&gt;  # 连续探测成功多少次才被认定为成功。默认是1</span><br></pre></td></tr></table></figure>

<p>下面稍微配置两个，演示下效果即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># more pod-liveness-httpget.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 容器启动后30s开始探测</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 探测超时时间为5s</span></span><br></pre></td></tr></table></figure>

<h5 id="5-3-5-重启策略"><a href="#5-3-5-重启策略" class="headerlink" title="5.3.5 重启策略"></a>5.3.5 重启策略</h5><p>在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p>
<ul>
<li>Always ：容器失效时，自动重启该容器，这也是默认值。</li>
<li>OnFailure ： 容器终止运行且退出码不为0时重启</li>
<li>Never ： 不论状态为何，都不重启该容器</li>
</ul>
<p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
<p>创建pod-restartpolicy.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-restartpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 设置重启策略为Never</span></span><br></pre></td></tr></table></figure>

<p>运行Pod测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-restartpolicy.yaml</span><br><span class="line">pod/pod-restartpolicy created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod详情，发现nginx容器失败</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl  describe pods pod-restartpolicy  -n dev</span><br><span class="line">......</span><br><span class="line">  Warning  Unhealthy  15s (x3 over 35s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404</span><br><span class="line">  Normal   Killing    15s                kubelet, node1     Container nginx failed liveness probe</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多等一会，再观察pod的重启次数，发现一直是0，并未重启</span>   </span><br><span class="line">[root@k8s-master01 ~]# kubectl  get pods pod-restartpolicy -n dev</span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-restartpolicy      0/1     Running   0          5min42s</span><br></pre></td></tr></table></figure>

<h4 id="5-4-Pod调度"><a href="#5-4-Pod调度" class="headerlink" title="5.4 Pod调度"></a>5.4 Pod调度</h4><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p>
<ul>
<li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li>
<li>定向调度：NodeName、NodeSelector</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li>
<li>污点（容忍）调度：Taints、Toleration</li>
</ul>
<h5 id="5-4-1-定向调度"><a href="#5-4-1-定向调度" class="headerlink" title="5.4.1 定向调度"></a>5.4.1 定向调度</h5><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p>
<p><strong>NodeName</strong></p>
<p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p>
<p>接下来，实验一下：创建一个pod-nodename.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 指定调度到node1节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml</span><br><span class="line">pod/pod-nodename created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......</span><br><span class="line">pod-nodename   1/1     Running   0          56s   10.244.1.87   node1     ......   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，删除pod，修改nodeName的值为node3（并没有node3节点）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pod-nodename.yaml</span><br><span class="line">pod &quot;pod-nodename&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# vim pod-nodename.yaml</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml</span><br><span class="line">pod/pod-nodename created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......</span><br><span class="line">pod-nodename   0/1     Pending   0          6s    &lt;none&gt;   node3   ......           </span><br></pre></td></tr></table></figure>

<p><strong>NodeSelector</strong></p>
<p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p>
<p>接下来，实验一下：</p>
<p>1 首先分别为node节点添加标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl label nodes node1 nodeenv=pro</span><br><span class="line">node/node2 labeled</span><br><span class="line">[root@k8s-master01 ~]# kubectl label nodes node2 nodeenv=test</span><br><span class="line">node/node2 labeled</span><br></pre></td></tr></table></figure>

<p>2 创建一个pod-nodeselector.yaml文件，并使用它创建Pod</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeselector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> </span><br><span class="line">    <span class="attr">nodeenv:</span> <span class="string">pro</span> <span class="comment"># 指定调度到具有nodeenv=pro标签的节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml</span><br><span class="line">pod/pod-nodeselector created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodeselector -n dev -o wide</span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......</span><br><span class="line">pod-nodeselector   1/1     Running   0          47s   10.244.1.87   node1   ......</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pod-nodeselector.yaml</span><br><span class="line">pod &quot;pod-nodeselector&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# vim pod-nodeselector.yaml</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml</span><br><span class="line">pod/pod-nodeselector created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">再次查看，发现pod无法正常运行,Node的值为none</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP       NODE    </span><br><span class="line">pod-nodeselector   0/1     Pending   0          2m20s   &lt;none&gt;   &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看详情,发现node selector匹配失败的提示</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-nodeselector -n dev</span><br><span class="line">.......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age        From               Message</span><br><span class="line">  ----     ------            ----       ----               -------</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-亲和性调度"><a href="#5-4-2-亲和性调度" class="headerlink" title="5.4.2 亲和性调度"></a>5.4.2 亲和性调度</h5><p>上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p>
<p>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p>
<p>Affinity主要分为三类：</p>
<ul>
<li>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</li>
<li>podAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</li>
<li>podAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</li>
</ul>
<blockquote>
<p>关于亲和性(反亲和性)使用场景的说明：</p>
<p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p>
<p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p>
</blockquote>
<p><strong>NodeAffinity</strong></p>
<p>首先来看一下<code>NodeAffinity</code>的可配置项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.nodeAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制</span><br><span class="line"><span class="code">    nodeSelectorTerms  节点选择列表</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operat or 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)</span></span><br><span class="line"><span class="code">    preference   一个节点选择器项，与相应的权重相关联</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt</span></span><br><span class="line"><span class="code">	weight 倾向权重，在范围1-100。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">关系符的使用说明:</span><br><span class="line"></span><br><span class="line">- matchExpressions:</span><br><span class="line">  - key: nodeenv              # 匹配存在标签的key为nodeenv的节点</span><br><span class="line">    operator: Exists</span><br><span class="line">  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span><br><span class="line">    operator: In</span><br><span class="line">    values: [&quot;xxx&quot;,&quot;yyy&quot;]</span><br><span class="line">  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span><br><span class="line">    operator: Gt</span><br><span class="line">    values: &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>接下来首先演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-required.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml</span><br><span class="line">pod/pod-nodeaffinity-required created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod状态 （运行失败）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... </span><br><span class="line">pod-nodeaffinity-required   0/1     Pending   0          16s   &lt;none&gt;   &lt;none&gt;  ......</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod的详情</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现调度失败，提示node选择失败</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod pod-nodeaffinity-required -n dev</span><br><span class="line">......</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">接下来，停止pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pod-nodeaffinity-required.yaml</span><br><span class="line">pod &quot;pod-nodeaffinity-required&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文件，将values: [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]------&gt; [<span class="string">&quot;pro&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span></span><br><span class="line">[root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次启动</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml</span><br><span class="line">pod/pod-nodeaffinity-required created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时查看，发现调度成功，已经将pod调度到了node1上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... </span><br><span class="line">pod-nodeaffinity-required   1/1     Running   0          11s   10.244.1.89   node1 ......</span><br></pre></td></tr></table></figure>

<p>接下来再演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-preferred.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-preferred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 软限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-preferred.yaml</span><br><span class="line">pod/pod-nodeaffinity-preferred created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod状态 （运行成功）</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-nodeaffinity-preferred -n dev</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-nodeaffinity-preferred   1/1     Running   0          40s</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NodeAffinity规则设置的注意事项：</span><br><span class="line">    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上</span><br><span class="line">    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可</span><br><span class="line">    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功</span><br><span class="line">    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化</span><br></pre></td></tr></table></figure>

<p><strong>PodAffinity</strong></p>
<p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p>
<p>首先来看一下<code>PodAffinity</code>的可配置项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.podAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  硬限制</span><br><span class="line"><span class="code">    namespaces       指定参照pod的namespace</span></span><br><span class="line"><span class="code">    topologyKey      指定调度作用域</span></span><br><span class="line"><span class="code">    labelSelector    标签选择器</span></span><br><span class="line"><span class="code">      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist.</span></span><br><span class="line"><span class="code">      matchLabels    指多个matchExpressions映射的内容</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 软限制</span></span><br><span class="line"><span class="code">    podAffinityTerm  选项</span></span><br><span class="line"><span class="code">      namespaces      </span></span><br><span class="line"><span class="code">      topologyKey</span></span><br><span class="line"><span class="code">      labelSelector</span></span><br><span class="line"><span class="code">        matchExpressions  </span></span><br><span class="line"><span class="code">          key    键</span></span><br><span class="line"><span class="code">          values 值</span></span><br><span class="line"><span class="code">          operator</span></span><br><span class="line"><span class="code">        matchLabels </span></span><br><span class="line"><span class="code">    weight 倾向权重，在范围1-100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">topologyKey用于指定调度时作用域,例如:</span><br><span class="line"><span class="code">    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围</span></span><br><span class="line"><span class="code">	如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</span></span><br></pre></td></tr></table></figure>

<p>接下来，演示下<code>requiredDuringSchedulingIgnoredDuringExecution</code>,</p>
<p>1）首先创建一个参照Pod，pod-podaffinity-target.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-target</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">podenv:</span> <span class="string">pro</span> <span class="comment">#设置标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 将目标pod名确指定到node1上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动目标pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-target.yaml</span><br><span class="line">pod/pod-podaffinity-target created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod状况</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods  pod-podaffinity-target -n dev</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-podaffinity-target   1/1     Running   0          4s</span><br></pre></td></tr></table></figure>

<p>2）创建pod-podaffinity-required.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml</span><br><span class="line">pod/pod-podaffinity-required created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod状态，发现未运行</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-podaffinity-required   0/1     Pending   0          9s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看详细信息</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pods pod-podaffinity-required  -n dev</span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age        From               Message</span><br><span class="line">  ----     ------            ----       ----               -------</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 2 node(s) didn&#x27;t match pod affinity rules, 1 node(s) had taints that the pod didn&#x27;t tolerate.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来修改  values: [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]-----&gt;values:[<span class="string">&quot;pro&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上</span></span><br><span class="line">[root@k8s-master01 ~]# vim pod-podaffinity-required.yaml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后重新创建pod，查看效果</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f  pod-podaffinity-required.yaml</span><br><span class="line">pod &quot;pod-podaffinity-required&quot; de leted</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml</span><br><span class="line">pod/pod-podaffinity-required created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现此时Pod运行正常</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod-podaffinity-required   1/1     Running   0          6s    &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>关于<code>PodAffinity</code>的 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，这里不再演示。</p>
<p><strong>PodAntiAffinity</strong></p>
<p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p>
<p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p>
<p>1）继续使用上个案例中目标pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS</span><br><span class="line">pod-podaffinity-required 1/1     Running   0          3m29s   10.244.1.38   node1   &lt;none&gt;     </span><br><span class="line">pod-podaffinity-target   1/1     Running   0          9m25s   10.244.1.37   node1   podenv=pro</span><br></pre></td></tr></table></figure>

<p>2）创建pod-podantiaffinity-required.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podantiaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配podenv的值在[&quot;pro&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;pro&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=pro的pod不在同一Node上，运行测试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-podantiaffinity-required.yaml</span><br><span class="line">pod/pod-podantiaffinity-required created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现调度到了node2上</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. </span><br><span class="line">pod-podantiaffinity-required   1/1     Running   0          30s   10.244.1.96   node2  ..</span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-污点和容忍"><a href="#5-4-3-污点和容忍" class="headerlink" title="5.4.3 污点和容忍"></a>5.4.3 污点和容忍</h5><p><strong>污点（Taints）</strong></p>
<p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p>
<p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p>
<p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200605021831545.png" class="" title="image-20200605021606508">

<p>使用kubectl设置和去除污点的命令示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置污点</span></span><br><span class="line">kubectl taint nodes node1 key=value:effect</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 去除污点</span></span><br><span class="line">kubectl taint nodes node1 key:effect-</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 去除所有污点</span></span><br><span class="line">kubectl taint nodes node1 key-</span><br></pre></td></tr></table></figure>

<p>接下来，演示下污点的效果：</p>
<ol>
<li>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</li>
<li>为node1节点设置一个污点: <code>tag=heima:PreferNoSchedule</code>；然后创建pod1( pod1 可以 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoSchedule</code>；然后创建pod2( pod1 正常 pod2 失败 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoExecute</code>；然后创建pod3 ( 3个pod都失败 )</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为node1设置污点(PreferNoSchedule)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:PreferNoSchedule</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建pod1</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl run taint1 --image=nginx:1.17.1 -n dev</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE   </span><br><span class="line">taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1    </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为node1设置污点(取消PreferNoSchedule，设置NoSchedule)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag:PreferNoSchedule-</span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoSchedule</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建pod2</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl run taint2 --image=nginx:1.17.1 -n dev</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods taint2 -n dev -o wide</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP            NODE</span><br><span class="line">taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1 </span><br><span class="line">taint2-544694789-6zmlf    0/1     Pending   0          21s     &lt;none&gt;        &lt;none&gt;   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为node1设置污点(取消NoSchedule，设置NoExecute)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag:NoSchedule-</span><br><span class="line">[root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoExecute</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建pod3</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl run taint3 --image=nginx:1.17.1 -n dev</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">taint1-7665f7fd85-htkmp   0/1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;    </span><br><span class="line">taint2-544694789-bn7wb    0/1     Pending   0          35s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br><span class="line">taint3-6d78dbd749-tktkq   0/1     Pending   0          6s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小提示：</span><br><span class="line">    使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.</span><br></pre></td></tr></table></figure>

<p><strong>容忍（Toleration）</strong></p>
<p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200514095913741.png" class="" title="image-20200514095913741">

<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p>
</blockquote>
<p>下面先通过一个案例看下效果：</p>
<ol>
<li>上一小节，已经在node1节点上打上了<code>NoExecute</code>的污点，此时pod是调度不上去的</li>
<li>本小节，可以通过给pod添加容忍，然后将其调度上去</li>
</ol>
<p>创建pod-toleration.yaml,内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-toleration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">tolerations:</span>      <span class="comment"># 添加容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span>        <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;heima&quot;</span>    <span class="comment"># 容忍的污点的value</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span>   <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加容忍之前的pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">pod-toleration   0/1     Pending   0          3s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加容忍之后的pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED</span><br><span class="line">pod-toleration   1/1     Running   0          3s    10.244.1.62   node1   &lt;none&gt;        </span><br></pre></td></tr></table></figure>

<p>下面看一下容忍的详细配置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations</span><br><span class="line">......</span><br><span class="line">FIELDS:</span><br><span class="line">   key       # 对应着要容忍的污点的键，空意味着匹配所有的键</span><br><span class="line">   value     # 对应着要容忍的污点的值</span><br><span class="line">   operator  # key-value的运算符，支持Equal和Exists（默认）</span><br><span class="line">   effect    # 对应污点的effect，空意味着匹配所有影响</span><br><span class="line">   tolerationSeconds   # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span><br></pre></td></tr></table></figure>

<h3 id="6-Pod控制器详解"><a href="#6-Pod控制器详解" class="headerlink" title="6. Pod控制器详解"></a>6. Pod控制器详解</h3><h4 id="6-1-Pod控制器介绍"><a href="#6-1-Pod控制器介绍" class="headerlink" title="6.1 Pod控制器介绍"></a>6.1 Pod控制器介绍</h4><p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p>
<ul>
<li>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</li>
<li>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</li>
</ul>
<blockquote>
<p><strong><code>什么是Pod控制器</code></strong></p>
<p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p>
</blockquote>
<p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p>
<ul>
<li>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代</li>
<li>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</li>
<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li>
<li>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</li>
<li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li>
<li>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</li>
<li>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行</li>
<li>StatefulSet：管理有状态应用</li>
</ul>
<h4 id="6-2-ReplicaSet-RS"><a href="#6-2-ReplicaSet-RS" class="headerlink" title="6.2 ReplicaSet(RS)"></a>6.2 ReplicaSet(RS)</h4><p>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200612005334159.png" class="" title="img">

<p>ReplicaSet的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">rs</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在这里面，需要新了解的配置项就是<code>spec</code>下面几个选项：</p>
<ul>
<li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p>
</li>
<li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制</p>
<p>在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p>
</li>
<li><p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</p>
</li>
</ul>
<p><strong>创建ReplicaSet</strong></p>
<p>创建pc-replicaset.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>   </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-replicaset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建rs</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-replicaset.yaml</span><br><span class="line">replicaset.apps/pc-replicaset created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看rs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DESIRED:期望副本数量</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> CURRENT:当前副本数量</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> READY:已经准备好提供服务的副本数量</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs pc-replicaset -n dev -o wide</span><br><span class="line">NAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR</span><br><span class="line">pc-replicaset 3         3       3     22s   nginx        nginx:1.17.1       app=nginx-pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前控制器创建出来的pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod -n dev</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-6vmvt   1/1     Running   0          54s</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running   0          54s</span><br><span class="line">pc-replicaset-snrk2   1/1     Running   0          54s</span><br></pre></td></tr></table></figure>

<p><strong>扩缩容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑rs的副本数量，修改spec:replicas: 6即可</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev</span><br><span class="line">replicaset.apps/pc-replicaset edited</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-6vmvt   1/1     Running   0          114m</span><br><span class="line">pc-replicaset-cftnp   1/1     Running   0          10s</span><br><span class="line">pc-replicaset-fjlm6   1/1     Running   0          10s</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running   0          114m</span><br><span class="line">pc-replicaset-s2whj   1/1     Running   0          10s</span><br><span class="line">pc-replicaset-snrk2   1/1     Running   0          114m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然也可以直接使用命令实现</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas=2 -n dev</span><br><span class="line">replicaset.apps/pc-replicaset scaled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令运行完毕，立即查看，发现已经有4个开始准备退出了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class="line">pc-replicaset-6vmvt   0/1     Terminating   0          118m</span><br><span class="line">pc-replicaset-cftnp   0/1     Terminating   0          4m17s</span><br><span class="line">pc-replicaset-fjlm6   0/1     Terminating   0          4m17s</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running       0          118m</span><br><span class="line">pc-replicaset-s2whj   0/1     Terminating   0          4m17s</span><br><span class="line">pc-replicaset-snrk2   1/1     Running       0          118m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">稍等片刻，就只剩下2个了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-fmb8f   1/1     Running   0          119m</span><br><span class="line">pc-replicaset-snrk2   1/1     Running   0          119m</span><br></pre></td></tr></table></figure>

<p><strong>镜像升级</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑rs的容器镜像 - image: nginx:1.17.2</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev</span><br><span class="line">replicaset.apps/pc-replicaset edited</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...</span><br><span class="line">pc-replicaset       2        2         2       140m   nginx         nginx:1.17.2  ...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样的道理，也可以使用命令完成这个工作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl <span class="built_in">set</span> image rs rs名称 容器=镜像版本 -n namespace</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.1  -n dev</span><br><span class="line">replicaset.apps/pc-replicaset image updated</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...</span><br><span class="line">pc-replicaset        2        2         2       145m   nginx        nginx:1.17.1 ... </span><br></pre></td></tr></table></figure>

<p><strong>删除ReplicaSet</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用kubectl delete命令会删除此RS以及它管理的Pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev</span><br><span class="line">replicaset.apps &quot;pc-replicaset&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod -n dev -o wide</span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=<span class="literal">false</span>选项（不推荐）。</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade=false</span><br><span class="line">replicaset.apps &quot;pc-replicaset&quot; deleted</span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-replicaset-cl82j   1/1     Running   0          75s</span><br><span class="line">pc-replicaset-dslhb   1/1     Running   0          75s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用yaml直接删除(推荐)</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yaml</span><br><span class="line">replicaset.apps &quot;pc-replicaset&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-3-Deployment-Deploy"><a href="#6-3-Deployment-Deploy" class="headerlink" title="6.3 Deployment(Deploy)"></a>6.3 Deployment(Deploy)</h4><p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200612005524778.png" class="" title="img">

<p>Deployment主要功能有下面几个：</p>
<ul>
<li>支持ReplicaSet的所有功能</li>
<li>支持发布的停止、继续</li>
<li>支持滚动升级和回滚版本</li>
</ul>
<p>Deployment的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">paused:</span> <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 部署超时时间（s），默认是600</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-创建deployment"><a href="#6-3-1-创建deployment" class="headerlink" title="6.3.1 创建deployment"></a>6.3.1 创建deployment</h5><p>创建pc-deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建deployment</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-deployment.yaml --record=true</span><br><span class="line">deployment.apps/pc-deployment created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UP-TO-DATE 最新版本的pod的数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AVAILABLE  当前可用的pod的数量</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev</span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">pc-deployment   3/3     3            3           15s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看rs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc-deployment-6696798b78   3         3         3       23s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6696798b78-d2c8n   1/1     Running   0          107s</span><br><span class="line">pc-deployment-6696798b78-smpvp   1/1     Running   0          107s</span><br><span class="line">pc-deployment-6696798b78-wvjd8   1/1     Running   0          107s</span><br></pre></td></tr></table></figure>

<h5 id="6-3-2-扩缩容"><a href="#6-3-2-扩缩容" class="headerlink" title="6.3.2 扩缩容"></a>6.3.2 扩缩容</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 变更副本数量为5个</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas=5  -n dev</span><br><span class="line">deployment.apps/pc-deployment scaled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看deployment</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev</span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">pc-deployment   5/5     5            5           2m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6696798b78-d2c8n   1/1     Running   0          4m19s</span><br><span class="line">pc-deployment-6696798b78-jxmdq   1/1     Running   0          94s</span><br><span class="line">pc-deployment-6696798b78-mktqv   1/1     Running   0          93s</span><br><span class="line">pc-deployment-6696798b78-smpvp   1/1     Running   0          4m19s</span><br><span class="line">pc-deployment-6696798b78-wvjd8   1/1     Running   0          4m19s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑deployment的副本数量，修改spec:replicas: 4即可</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n dev</span><br><span class="line">deployment.apps/pc-deployment edited</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6696798b78-d2c8n   1/1     Running   0          5m23s</span><br><span class="line">pc-deployment-6696798b78-jxmdq   1/1     Running   0          2m38s</span><br><span class="line">pc-deployment-6696798b78-smpvp   1/1     Running   0          5m23s</span><br><span class="line">pc-deployment-6696798b78-wvjd8   1/1     Running   0          5m23s</span><br></pre></td></tr></table></figure>

<p><strong>镜像更新</strong></p>
<p>deployment支持两种更新策略:<code>重建更新</code>和<code>滚动更新</code>,可以通过<code>strategy</code>指定策略类型,支持两个属性:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：</span><br><span class="line">  type：指定策略类型，支持两种策略</span><br><span class="line"><span class="code">    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod</span></span><br><span class="line"><span class="code">    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod</span></span><br><span class="line"><span class="code">  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：</span></span><br><span class="line"><span class="code">    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。</span></span><br><span class="line"><span class="code">    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span></span><br></pre></td></tr></table></figure>

<p>重建更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span> <span class="comment"># 重建更新</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建deploy进行验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 变更镜像</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev</span><br><span class="line">deployment.apps/pc-deployment image updated</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察升级过程</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get pods -n dev -w</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-5d89bdfbf9-65qcw   1/1     Running   0          31s</span><br><span class="line">pc-deployment-5d89bdfbf9-w5nzv   1/1     Running   0          31s</span><br><span class="line">pc-deployment-5d89bdfbf9-xpt7w   1/1     Running   0          31s</span><br><span class="line"></span><br><span class="line">pc-deployment-5d89bdfbf9-xpt7w   1/1     Terminating   0          41s</span><br><span class="line">pc-deployment-5d89bdfbf9-65qcw   1/1     Terminating   0          41s</span><br><span class="line">pc-deployment-5d89bdfbf9-w5nzv   1/1     Terminating   0          41s</span><br><span class="line"></span><br><span class="line">pc-deployment-675d469f8b-grn8z   0/1     Pending       0          0s</span><br><span class="line">pc-deployment-675d469f8b-hbl4v   0/1     Pending       0          0s</span><br><span class="line">pc-deployment-675d469f8b-67nz2   0/1     Pending       0          0s</span><br><span class="line"></span><br><span class="line">pc-deployment-675d469f8b-grn8z   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-675d469f8b-hbl4v   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-675d469f8b-67nz2   0/1     ContainerCreating   0          0s</span><br><span class="line"></span><br><span class="line">pc-deployment-675d469f8b-grn8z   1/1     Running             0          1s</span><br><span class="line">pc-deployment-675d469f8b-67nz2   1/1     Running             0          1s</span><br><span class="line">pc-deployment-675d469f8b-hbl4v   1/1     Running             0          2s</span><br></pre></td></tr></table></figure>

<p>滚动更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> </span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建deploy进行验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 变更镜像</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev </span><br><span class="line">deployment.apps/pc-deployment image updated</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察升级过程</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-c848d767-8rbzt   1/1     Running   0          31m</span><br><span class="line">pc-deployment-c848d767-h4p68   1/1     Running   0          31m</span><br><span class="line">pc-deployment-c848d767-hlmz4   1/1     Running   0          31m</span><br><span class="line">pc-deployment-c848d767-rrqcn   1/1     Running   0          31m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-226rx   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-226rx   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-226rx   1/1     Running             0          1s</span><br><span class="line">pc-deployment-c848d767-h4p68    0/1     Terminating         0          34m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-cnd44   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-cnd44   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-cnd44   1/1     Running             0          2s</span><br><span class="line">pc-deployment-c848d767-hlmz4    0/1     Terminating         0          34m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-px48p   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-px48p   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-px48p   1/1     Running             0          0s</span><br><span class="line">pc-deployment-c848d767-8rbzt    0/1     Terminating         0          34m</span><br><span class="line"></span><br><span class="line">pc-deployment-966bf7f44-dkmqp   0/1     Pending             0          0s</span><br><span class="line">pc-deployment-966bf7f44-dkmqp   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-deployment-966bf7f44-dkmqp   1/1     Running             0          2s</span><br><span class="line">pc-deployment-c848d767-rrqcn    0/1     Terminating         0          34m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 至此，新版本的pod创建完毕，就版本的pod销毁完毕</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 中间过程是滚动进行的，也就是边销毁边创建</span></span><br></pre></td></tr></table></figure>

<p>滚动更新的过程：</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200416140251491.png" class="" title="img">

<p>镜像更新中rs的变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc-deployment-6696798b78   0         0         0       7m37s</span><br><span class="line">pc-deployment-6696798b11   0         0         0       5m37s</span><br><span class="line">pc-deployment-c848d76789   4         4         4       72s</span><br></pre></td></tr></table></figure>

<h5 id="6-3-3-版本回退"><a href="#6-3-3-版本回退" class="headerlink" title="6.3.3 版本回退"></a>6.3.3 版本回退</h5><p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p>
<p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p>
<ul>
<li>status    显示当前升级状态</li>
<li>history   显示 升级历史记录</li>
<li>pause    暂停版本升级过程</li>
<li>resume   继续已经暂停的版本升级过程</li>
<li>restart    重启版本升级过程</li>
<li>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前升级版本的状态</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev</span><br><span class="line">deployment &quot;pc-deployment&quot; successfully rolled out</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看升级历史记录</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout history deploy pc-deployment -n dev</span><br><span class="line">deployment.apps/pc-deployment</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl create --filename=pc-deployment.yaml --record=true</span><br><span class="line">2         kubectl create --filename=pc-deployment.yaml --record=true</span><br><span class="line">3         kubectl create --filename=pc-deployment.yaml --record=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以发现有三次版本记录，说明完成过两次升级</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 版本回滚</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev</span><br><span class="line">deployment.apps/pc-deployment rolled back</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看发现，通过nginx镜像版本可以发现到了第一版</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get deploy -n dev -o wide</span><br><span class="line">NAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc-deployment   4/4     4            4           74m   nginx        nginx:1.17.1   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc-deployment-6696798b78   4         4         4       78m</span><br><span class="line">pc-deployment-966bf7f44    0         0         0       37m</span><br><span class="line">pc-deployment-c848d767     0         0         0       71m</span><br></pre></td></tr></table></figure>

<h5 id="6-3-4-金丝雀发布"><a href="#6-3-4-金丝雀发布" class="headerlink" title="6.3.4 金丝雀发布"></a>6.3.4 金丝雀发布</h5><p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p>
<p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新deployment的版本，并配置暂停deployment</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev</span><br><span class="line">deployment.apps/pc-deployment image updated</span><br><span class="line">deployment.apps/pc-deployment paused</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">观察更新状态</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev　</span><br><span class="line">Waiting for deployment &quot;pc-deployment&quot; rollout to finish: 2 out of 4 new replicas have been updated...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令</span></span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc-deployment-5d89bdfbf9   3         3         3       19m     nginx        nginx:1.17.1   </span><br><span class="line">pc-deployment-675d469f8b   0         0         0       14m     nginx        nginx:1.17.2   </span><br><span class="line">pc-deployment-6c9f56fcfb   2         2         2       3m16s   nginx        nginx:1.17.4   </span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-5d89bdfbf9-rj8sq   1/1     Running   0          7m33s</span><br><span class="line">pc-deployment-5d89bdfbf9-ttwgg   1/1     Running   0          7m35s</span><br><span class="line">pc-deployment-5d89bdfbf9-v4wvc   1/1     Running   0          7m34s</span><br><span class="line">pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          3m31s</span><br><span class="line">pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          3m31s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保更新的pod没问题了，继续更新</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl rollout resume deploy pc-deployment -n dev</span><br><span class="line">deployment.apps/pc-deployment resumed</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最后的更新情况</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get rs -n dev -o wide</span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc-deployment-5d89bdfbf9   0         0         0       21m     nginx        nginx:1.17.1   </span><br><span class="line">pc-deployment-675d469f8b   0         0         0       16m     nginx        nginx:1.17.2   </span><br><span class="line">pc-deployment-6c9f56fcfb   4         4         4       5m11s   nginx        nginx:1.17.4   </span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-deployment-6c9f56fcfb-7bfwh   1/1     Running   0          37s</span><br><span class="line">pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          5m27s</span><br><span class="line">pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          5m27s</span><br><span class="line">pc-deployment-6c9f56fcfb-rf84v   1/1     Running   0          37s</span><br></pre></td></tr></table></figure>

<p><strong>删除Deployment</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除deployment，其下的rs和pod也将被删除</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-deployment.yaml</span><br><span class="line">deployment.apps &quot;pc-deployment&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-4-Horizontal-Pod-Autoscaler-HPA"><a href="#6-4-Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="6.4 Horizontal Pod Autoscaler(HPA)"></a>6.4 Horizontal Pod Autoscaler(HPA)</h4><p>在前面的课程中，我们已经可以实现通过手工执行<code>kubectl scale</code>命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p>
<p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200608155858271.png" class="" title="img">

<p>接下来，我们来做一个实验</p>
<h5 id="6-4-1-安装metrics-server"><a href="#6-4-1-安装metrics-server" class="headerlink" title="6.4.1 安装metrics-server"></a>6.4.1 安装metrics-server</h5><p>metrics-server可以用来收集集群中的资源使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装git</span></span><br><span class="line">[root@k8s-master01 ~]# yum install git -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取metrics-server, 注意使用的版本</span></span><br><span class="line">[root@k8s-master01 ~]# git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改deployment, 注意修改的是镜像和初始化参数</span></span><br><span class="line">[root@k8s-master01 ~]# cd /root/metrics-server/deploy/1.8+/</span><br><span class="line">[root@k8s-master01 1.8+]# vim metrics-server-deployment.yaml</span><br><span class="line">按图中添加下面选项</span><br><span class="line">hostNetwork: true</span><br><span class="line">image: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6</span><br><span class="line">args:</span><br><span class="line">- --kubelet-insecure-tls</span><br><span class="line">- --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</span><br></pre></td></tr></table></figure>

<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200608163326496.png" class="" title="image-20200608163326496">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装metrics-server</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl apply -f ./</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod运行情况</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl get pod -n kube-system</span><br><span class="line">metrics-server-6b976979db-2xwbj   1/1     Running   0          90s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用kubectl top node 查看资源使用情况</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl top node</span><br><span class="line">NAME           CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">k8s-master01   289m         14%    1582Mi          54%       </span><br><span class="line">k8s-node01     81m          4%     1195Mi          40%       </span><br><span class="line">k8s-node02     72m          3%     1211Mi          41%  </span><br><span class="line">[root@k8s-master01 1.8+]# kubectl top pod -n kube-system</span><br><span class="line">NAME                              CPU(cores)   MEMORY(bytes)</span><br><span class="line">coredns-6955765f44-7ptsb          3m           9Mi</span><br><span class="line">coredns-6955765f44-vcwr5          3m           8Mi</span><br><span class="line">etcd-master                       14m          145Mi</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 至此,metrics-server安装完成</span></span><br></pre></td></tr></table></figure>

<h5 id="6-4-2-准备deployment和servie"><a href="#6-4-2-准备deployment和servie" class="headerlink" title="6.4.2 准备deployment和servie"></a>6.4.2 准备deployment和servie</h5><p>创建pc-hpa-pod.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">          <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">          <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建deployment</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl run nginx --image=nginx:1.17.1 --requests=cpu=100m -n dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建service</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl expose deployment nginx --type=NodePort --port=80 -n dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl get deployment,pod,svc -n dev</span><br><span class="line">NAME                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/nginx   1/1     1            1           47s</span><br><span class="line"></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-7df9756ccc-bh8dr   1/1     Running   0          47s</span><br><span class="line"></span><br><span class="line">NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/nginx   NodePort   10.101.18.29   &lt;none&gt;        80:31830/TCP   35s</span><br></pre></td></tr></table></figure>

<h5 id="6-4-3-部署HPA"><a href="#6-4-3-部署HPA" class="headerlink" title="6.4.3 部署HPA"></a>6.4.3 部署HPA</h5><p>创建pc-hpa.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-hpa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span>  <span class="comment">#最小pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment">#最大pod数量</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">3</span> <span class="comment"># CPU使用率指标</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>   <span class="comment"># 指定要控制的nginx信息</span></span><br><span class="line">    <span class="attr">apiVersion:</span>  <span class="string">/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建hpa</span></span><br><span class="line">[root@k8s-master01 1.8+]# kubectl create -f pc-hpa.yaml</span><br><span class="line">horizontalpodautoscaler.autoscaling/pc-hpa created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看hpa</span></span><br><span class="line">    [root@k8s-master01 1.8+]# kubectl get hpa -n dev</span><br><span class="line">NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">pc-hpa   Deployment/nginx   0%/3%     1         10        1          62s</span><br></pre></td></tr></table></figure>

<h5 id="6-4-4-测试"><a href="#6-4-4-测试" class="headerlink" title="6.4.4 测试"></a>6.4.4 测试</h5><p>使用压测工具对service地址<code>192.168.5.4:31830</code>进行压测，然后通过控制台查看hpa和pod的变化</p>
<p>hpa变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get hpa -n dev -w</span><br><span class="line">NAME   REFERENCE      TARGETS  MINPODS  MAXPODS  REPLICAS  AGE</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     1      4m11s</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     1      5m19s</span><br><span class="line">pc-hpa  Deployment/nginx  22%/3%   1     10     1      6m50s</span><br><span class="line">pc-hpa  Deployment/nginx  22%/3%   1     10     4      7m5s</span><br><span class="line">pc-hpa  Deployment/nginx  22%/3%   1     10     8      7m21s</span><br><span class="line">pc-hpa  Deployment/nginx  6%/3%   1     10     8      7m51s</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     8      9m6s</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     8      13m</span><br><span class="line">pc-hpa  Deployment/nginx  0%/3%   1     10     1      14m</span><br></pre></td></tr></table></figure>

<p>deployment变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get deployment -n dev -w</span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           11m</span><br><span class="line">nginx   1/4     1            1           13m</span><br><span class="line">nginx   1/4     1            1           13m</span><br><span class="line">nginx   1/4     1            1           13m</span><br><span class="line">nginx   1/4     4            1           13m</span><br><span class="line">nginx   1/8     4            1           14m</span><br><span class="line">nginx   1/8     4            1           14m</span><br><span class="line">nginx   1/8     4            1           14m</span><br><span class="line">nginx   1/8     8            1           14m</span><br><span class="line">nginx   2/8     8            2           14m</span><br><span class="line">nginx   3/8     8            3           14m</span><br><span class="line">nginx   4/8     8            4           14m</span><br><span class="line">nginx   5/8     8            5           14m</span><br><span class="line">nginx   6/8     8            6           14m</span><br><span class="line">nginx   7/8     8            7           14m</span><br><span class="line">nginx   8/8     8            8           15m</span><br><span class="line">nginx   8/1     8            8           20m</span><br><span class="line">nginx   8/1     8            8           20m</span><br><span class="line">nginx   1/1     1            1           20m</span><br></pre></td></tr></table></figure>

<p>pod变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-7df9756ccc-bh8dr   1/1     Running   0          11m</span><br><span class="line">nginx-7df9756ccc-cpgrv   0/1     Pending   0          0s</span><br><span class="line">nginx-7df9756ccc-8zhwk   0/1     Pending   0          0s</span><br><span class="line">nginx-7df9756ccc-rr9bn   0/1     Pending   0          0s</span><br><span class="line">nginx-7df9756ccc-cpgrv   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-8zhwk   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-rr9bn   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-m9gsj   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-g56qb   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-sl9c6   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-fgst7   0/1     Pending             0          0s</span><br><span class="line">nginx-7df9756ccc-g56qb   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-m9gsj   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-sl9c6   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-fgst7   0/1     ContainerCreating   0          0s</span><br><span class="line">nginx-7df9756ccc-8zhwk   1/1     Running             0          19s</span><br><span class="line">nginx-7df9756ccc-rr9bn   1/1     Running             0          30s</span><br><span class="line">nginx-7df9756ccc-m9gsj   1/1     Running             0          21s</span><br><span class="line">nginx-7df9756ccc-cpgrv   1/1     Running             0          47s</span><br><span class="line">nginx-7df9756ccc-sl9c6   1/1     Running             0          33s</span><br><span class="line">nginx-7df9756ccc-g56qb   1/1     Running             0          48s</span><br><span class="line">nginx-7df9756ccc-fgst7   1/1     Running             0          66s</span><br><span class="line">nginx-7df9756ccc-fgst7   1/1     Terminating         0          6m50s</span><br><span class="line">nginx-7df9756ccc-8zhwk   1/1     Terminating         0          7m5s</span><br><span class="line">nginx-7df9756ccc-cpgrv   1/1     Terminating         0          7m5s</span><br><span class="line">nginx-7df9756ccc-g56qb   1/1     Terminating         0          6m50s</span><br><span class="line">nginx-7df9756ccc-rr9bn   1/1     Terminating         0          7m5s</span><br><span class="line">nginx-7df9756ccc-m9gsj   1/1     Terminating         0          6m50s</span><br><span class="line">nginx-7df9756ccc-sl9c6   1/1     Terminating         0          6m50s</span><br></pre></td></tr></table></figure>

<h4 id="6-5-DaemonSet-DS"><a href="#6-5-DaemonSet-DS" class="headerlink" title="6.5 DaemonSet(DS)"></a>6.5 DaemonSet(DS)</h4><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200612010223537.png" class="" title="img">

<p>DaemonSet控制器的特点：</p>
<ul>
<li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li>
<li>当节点从集群中移除时，Pod 也就被垃圾回收了</li>
</ul>
<p>下面先来看下DaemonSet的资源清单文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">updateStrategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>创建pc-daemonset.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-daemonset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建daemonset</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f  pc-daemonset.yaml</span><br><span class="line">daemonset.apps/pc-daemonset created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看daemonset</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get ds -n dev -o wide</span><br><span class="line">NAME        DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc-daemonset   2        2        2      2           2        24s   nginx        nginx:1.17.1   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod,发现在每个Node上都运行一个pod</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get pods -n dev -o wide</span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    </span><br><span class="line">pc-daemonset-9bck8   1/1     Running   0          37s   10.244.1.43   node1     </span><br><span class="line">pc-daemonset-k224w   1/1     Running   0          37s   10.244.2.74   node2      </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除daemonset</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-daemonset.yaml</span><br><span class="line">daemonset.apps &quot;pc-daemonset&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-6-Job"><a href="#6-6-Job" class="headerlink" title="6.6 Job"></a>6.6 Job</h4><p>Job，主要用于负责**批量处理(一次要处理指定数量任务)<strong>短暂的</strong>一次性(每个任务仅运行一次就结束)**任务。Job特点如下：</p>
<ul>
<li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li>
<li>当成功结束的pod达到指定的数量时，Job将完成执行</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200618213054113.png" class="" title="img">

<p>Job的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">job</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定job需要成功运行Pods的次数。默认值: 1</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定job失败后进行重试的次数。默认是6</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择pod，默认是false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或者OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">关于重启策略设置的说明：</span><br><span class="line"><span class="code">    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变</span></span><br><span class="line"><span class="code">    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</span></span><br><span class="line"><span class="code">    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</span></span><br></pre></td></tr></table></figure>

<p>创建pc-job.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-job</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-job.yaml</span><br><span class="line">job.batch/pc-job created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get job -n dev -o wide  -w</span><br><span class="line">NAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR</span><br><span class="line">pc-job   0/1           21s        21s   counter      busybox:1.30   app=counter-pod</span><br><span class="line">pc-job   1/1           31s        79s   counter      busybox:1.30   app=counter-pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME           READY   STATUS     RESTARTS      AGE</span><br><span class="line">pc-job-rxg96   1/1     Running     0            29s</span><br><span class="line">pc-job-rxg96   0/1     Completed   0            33s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  completions: 6 <span class="comment"># 指定job需要成功运行Pods的次数为6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  parallelism: 3 <span class="comment"># 指定job并发运行Pods的数量为3</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -w</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc-job-684ft   1/1     Running   0          5s</span><br><span class="line">pc-job-jhj49   1/1     Running   0          5s</span><br><span class="line">pc-job-pfcvh   1/1     Running   0          5s</span><br><span class="line">pc-job-684ft   0/1     Completed   0          11s</span><br><span class="line">pc-job-v7rhr   0/1     Pending     0          0s</span><br><span class="line">pc-job-v7rhr   0/1     Pending     0          0s</span><br><span class="line">pc-job-v7rhr   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-job-jhj49   0/1     Completed           0          11s</span><br><span class="line">pc-job-fhwf7   0/1     Pending             0          0s</span><br><span class="line">pc-job-fhwf7   0/1     Pending             0          0s</span><br><span class="line">pc-job-pfcvh   0/1     Completed           0          11s</span><br><span class="line">pc-job-5vg2j   0/1     Pending             0          0s</span><br><span class="line">pc-job-fhwf7   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-job-5vg2j   0/1     Pending             0          0s</span><br><span class="line">pc-job-5vg2j   0/1     ContainerCreating   0          0s</span><br><span class="line">pc-job-fhwf7   1/1     Running             0          2s</span><br><span class="line">pc-job-v7rhr   1/1     Running             0          2s</span><br><span class="line">pc-job-5vg2j   1/1     Running             0          3s</span><br><span class="line">pc-job-fhwf7   0/1     Completed           0          12s</span><br><span class="line">pc-job-v7rhr   0/1     Completed           0          12s</span><br><span class="line">pc-job-5vg2j   0/1     Completed           0          12s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f pc-job.yaml</span><br><span class="line">job.batch &quot;pc-job&quot; deleted</span><br></pre></td></tr></table></figure>

<h4 id="6-7-CronJob-CJ"><a href="#6-7-CronJob-CJ" class="headerlink" title="6.7 CronJob(CJ)"></a>6.7 CronJob(CJ)</h4><p>CronJob控制器以 Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200618213149531.png" class="" title="img">

<p>CronJob的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span></span><br><span class="line">  <span class="attr">failedJobHistoryLimit:</span> <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  <span class="attr">successfulJobHistoryLimit:</span> <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="comment"># 启动作业错误的超时时长</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">6</span></span><br><span class="line">      <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">matchExpressions:</span> <span class="string">规则</span></span><br><span class="line">          <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> </span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">需要重点解释的几个选项：</span><br><span class="line">schedule: cron表达式，用于指定任务的执行时间</span><br><span class="line"><span class="code">    */1    *      *    *     *</span></span><br><span class="line"><span class="code">    &lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    分钟 值从 0 到 59.</span></span><br><span class="line"><span class="code">    小时 值从 0 到 23.</span></span><br><span class="line"><span class="code">    日 值从 1 到 31.</span></span><br><span class="line"><span class="code">    月 值从 1 到 12.</span></span><br><span class="line"><span class="code">    星期 值从 0 到 6, 0 代表星期日</span></span><br><span class="line"><span class="code">    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每...</span></span><br><span class="line"><span class="code">concurrencyPolicy:</span></span><br><span class="line"><span class="code">    Allow:   允许Jobs并发运行(默认)</span></span><br><span class="line"><span class="code">    Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</span></span><br><span class="line"><span class="code">    Replace: 替换，取消当前正在运行的作业并用新作业替换它</span></span><br></pre></td></tr></table></figure>

<p>创建pc-cronjob.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-cronjob</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建cronjob</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pc-cronjob.yaml</span><br><span class="line">cronjob.batch/pc-cronjob created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cronjob</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get cronjobs -n dev</span><br><span class="line">NAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">pc-cronjob   */1 * * * *   False     0        &lt;none&gt;          6s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看job</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get jobs -n dev</span><br><span class="line">NAME                    COMPLETIONS   DURATION   AGE</span><br><span class="line">pc-cronjob-1592587800   1/1           28s        3m26s</span><br><span class="line">pc-cronjob-1592587860   1/1           28s        2m26s</span><br><span class="line">pc-cronjob-1592587920   1/1           28s        86s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev</span><br><span class="line">pc-cronjob-1592587800-x4tsm   0/1     Completed   0          2m24s</span><br><span class="line">pc-cronjob-1592587860-r5gv4   0/1     Completed   0          84s</span><br><span class="line">pc-cronjob-1592587920-9dxxq   1/1     Running     0          24s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除cronjob</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl  delete -f pc-cronjob.yaml</span><br><span class="line">cronjob.batch &quot;pc-cronjob&quot; deleted</span><br></pre></td></tr></table></figure>

<h3 id="7-Service详解"><a href="#7-Service详解" class="headerlink" title="7. Service详解"></a>7. Service详解</h3><h4 id="7-1-Service介绍"><a href="#7-1-Service介绍" class="headerlink" title="7.1 Service介绍"></a>7.1 Service介绍</h4><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200408194716912-1626783758946.png" class="" title="img">

<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200509121254425.png" class="" title="img">



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 10.97.97.97:80 是service提供的访问入口</span><br><span class="line"># 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span><br><span class="line"># kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span><br><span class="line"># 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span><br><span class="line">[root@node1 ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line">  -&gt; 10.244.1.39:80               Masq    1      0          0</span><br><span class="line">  -&gt; 10.244.1.40:80               Masq    1      0          0</span><br><span class="line">  -&gt; 10.244.2.33:80               Masq    1      0          0</span><br></pre></td></tr></table></figure>

<p>kube-proxy目前支持三种工作模式:</p>
<h5 id="7-1-1-userspace-模式"><a href="#7-1-1-userspace-模式" class="headerlink" title="7.1.1 userspace 模式"></a>7.1.1 userspace 模式</h5><p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。  该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200509151424280.png" class="" title="img">

<h5 id="7-1-2-iptables-模式"><a href="#7-1-2-iptables-模式" class="headerlink" title="7.1.2 iptables 模式"></a>7.1.2 iptables 模式</h5><p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。  该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200509152947714.png" class="" title="img">

<h5 id="7-1-3-ipvs-模式"><a href="#7-1-3-ipvs-模式" class="headerlink" title="7.1.3 ipvs 模式"></a>7.1.3 ipvs 模式</h5><p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200509153731363.png" class="" title="img">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此模式必须安装ipvs内核模块，否则会降级为iptables</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启ipvs</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改mode: <span class="string">&quot;ipvs&quot;</span></span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span><br><span class="line">[root@node1 ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.2.33:80               Masq    1      0          0</span></span><br></pre></td></tr></table></figure>

<h4 id="7-2-Service类型"><a href="#7-2-Service类型" class="headerlink" title="7.2 Service类型"></a>7.2 Service类型</h4><p>Service的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 资源版本</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前service代理哪些pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="comment"># Service类型，指定service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span>  <span class="comment"># 虚拟服务的ip地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">3017</span>  <span class="comment"># service端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5003</span> <span class="comment"># pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31122</span> <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li>
<li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li>
</ul>
<h4 id="7-3-Service使用"><a href="#7-3-Service使用" class="headerlink" title="7.3 Service使用"></a>7.3 Service使用</h4><h5 id="7-3-1-实验环境准备"><a href="#7-3-1-实验环境准备" class="headerlink" title="7.3.1 实验环境准备"></a>7.3.1 实验环境准备</h5><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p>
<p>创建deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubectl create -f deployment.yaml</span><br><span class="line">deployment.apps/pc-deployment created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels</span><br><span class="line">NAME                             READY   STATUS     IP            NODE     LABELS</span><br><span class="line">pc-deployment-66cb59b984-8p84h   1/1     Running    10.244.1.39   node1    app=nginx-pod</span><br><span class="line">pc-deployment-66cb59b984-vx8vx   1/1     Running    10.244.2.33   node2    app=nginx-pod</span><br><span class="line">pc-deployment-66cb59b984-wnncx   1/1     Running    10.244.1.40   node1    app=nginx-pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl <span class="built_in">exec</span> -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;10.244.1.39&quot;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改完毕之后，访问测试</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.1.39</span><br><span class="line">10.244.1.39</span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.2.33</span><br><span class="line">10.244.2.33</span><br><span class="line">[root@k8s-master01 ~]# curl 10.244.1.40</span><br><span class="line">10.244.1.40</span><br></pre></td></tr></table></figure>

<h5 id="7-3-2-ClusterIP类型的Service"><a href="#7-3-2-ClusterIP类型的Service" class="headerlink" title="7.3.2 ClusterIP类型的Service"></a>7.3.2 ClusterIP类型的Service</h5><p>创建service-clusterip.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.97</span><span class="number">.97</span><span class="number">.97</span> <span class="comment"># service的ip地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service端口       </span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># pod端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f service-clusterip.yaml</span><br><span class="line">service/service-clusterip created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc -n dev -o wide</span><br><span class="line">NAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">service-clusterip   ClusterIP   10.97.97.97   &lt;none&gt;        80/TCP    13s   app=nginx-pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看service的详细信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe svc service-clusterip -n dev</span><br><span class="line">Name:              service-clusterip</span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx-pod</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.97.97.97</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ipvs的映射规则</span></span><br><span class="line">[root@k8s-master01 ~]# ipvsadm -Ln</span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.2.33:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问10.97.97.97:80观察效果</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.97.97.97:80</span><br><span class="line">10.244.2.33</span><br></pre></td></tr></table></figure>

<h5 id="7-3-3-Endpoint"><a href="#7-3-3-Endpoint" class="headerlink" title="7.3.3 Endpoint"></a>7.3.3 Endpoint</h5><p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p>
<p>一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong>。换句话说，service和pod之间的联系是通过endpoints实现的。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200509191917069.png" class="" title="image-20200509191917069">

<p><strong>负载分发策略</strong></p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li><p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p>
</li>
<li><p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上</p>
<p>此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看ipvs的映射规则【rr 轮询】</span></span><br><span class="line">[root@k8s-master01 ~]# ipvsadm -Ln</span><br><span class="line">TCP  10.97.97.97:80 rr</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.2.33:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环访问测试</span></span><br><span class="line">[root@k8s-master01 ~]# while true;do curl 10.97.97.97:80; sleep 5; done;</span><br><span class="line">10.244.1.40</span><br><span class="line">10.244.1.39</span><br><span class="line">10.244.2.33</span><br><span class="line">10.244.1.40</span><br><span class="line">10.244.1.39</span><br><span class="line">10.244.2.33</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改分发策略----sessionAffinity:ClientIP</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ipvs规则【persistent 代表持久】</span></span><br><span class="line">[root@k8s-master01 ~]# ipvsadm -Ln</span><br><span class="line">TCP  10.97.97.97:80 rr persistent 10800</span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.39:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.1.40:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta">  -&gt;</span><span class="bash"> 10.244.2.33:80               Masq    1      0          0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环访问测试</span></span><br><span class="line">[root@k8s-master01 ~]# while true;do curl 10.97.97.97; sleep 5; done;</span><br><span class="line">10.244.2.33</span><br><span class="line">10.244.2.33</span><br><span class="line">10.244.2.33</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl delete -f service-clusterip.yaml</span><br><span class="line">service &quot;service-clusterip&quot; deleted</span><br></pre></td></tr></table></figure>

<h5 id="7-3-4-HeadLiness类型的Service"><a href="#7-3-4-HeadLiness类型的Service" class="headerlink" title="7.3.4 HeadLiness类型的Service"></a>7.3.4 HeadLiness类型的Service</h5><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p>
<p>创建service-headliness.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>    </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f service-headliness.yaml</span><br><span class="line">service/service-headliness created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取service， 发现CLUSTER-IP未分配</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc service-headliness -n dev -o wide</span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">service-headliness   ClusterIP   None         &lt;none&gt;        80/TCP    11s   app=nginx-pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看service详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe svc service-headliness  -n dev</span><br><span class="line">Name:              service-headliness</span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx-pod</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                None</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看域名的解析情况</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span><br><span class="line">/ # cat /etc/resolv.conf</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search dev.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# dig @10.96.0.10 service-headliness.dev.svc.cluster.local</span><br><span class="line">service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.40</span><br><span class="line">service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.39</span><br><span class="line">service-headliness.dev.svc.cluster.local. 30 IN A 10.244.2.33</span><br></pre></td></tr></table></figure>

<h5 id="7-3-5-NodePort类型的Service"><a href="#7-3-5-NodePort类型的Service" class="headerlink" title="7.3.5 NodePort类型的Service"></a>7.3.5 NodePort类型的Service</h5><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200620175731338.png" class="" title="img">

<p>创建service-nodeport.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f service-nodeport.yaml</span><br><span class="line">service/service-nodeport created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc -n dev -o wide</span><br><span class="line">NAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)       SELECTOR</span><br><span class="line">service-nodeport   NodePort   10.105.64.191   &lt;none&gt;        80:30002/TCP  app=nginx-pod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</span></span><br></pre></td></tr></table></figure>

<h5 id="7-3-6-LoadBalancer类型的Service"><a href="#7-3-6-LoadBalancer类型的Service" class="headerlink" title="7.3.6 LoadBalancer类型的Service"></a>7.3.6 LoadBalancer类型的Service</h5><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200510103945494.png" class="" title="img">

<h5 id="7-3-7-ExternalName类型的Service"><a href="#7-3-7-ExternalName类型的Service" class="headerlink" title="7.3.7 ExternalName类型的Service"></a>7.3.7 ExternalName类型的Service</h5><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200510113311209.png" class="" title="img">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: service-externalname</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName # service类型</span><br><span class="line">  externalName: www.baidu.com  #改成ip地址也可以</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建service</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl  create -f service-externalname.yaml</span><br><span class="line">service/service-externalname created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 域名解析</span></span><br><span class="line">[root@k8s-master01 ~]# dig @10.96.0.10 service-externalname.dev.svc.cluster.local</span><br><span class="line">service-externalname.dev.svc.cluster.local. 30 IN CNAME www.baidu.com.</span><br><span class="line">www.baidu.com.          30      IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       30      IN      A       39.156.66.18</span><br><span class="line">www.a.shifen.com.       30      IN      A       39.156.66.14</span><br></pre></td></tr></table></figure>

<h4 id="7-4-Ingress介绍"><a href="#7-4-Ingress介绍" class="headerlink" title="7.4 Ingress介绍"></a>7.4 Ingress介绍</h4><p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li>
<li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li>
</ul>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200623092808049.png" class="" title="img">

<p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p>
<ul>
<li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li>
<li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li>
</ul>
<p>Ingress（以Nginx为例）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li>
</ol>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200516112704764.png" class="" title="img">

<h4 id="7-5-Ingress使用"><a href="#7-5-Ingress使用" class="headerlink" title="7.5 Ingress使用"></a>7.5 Ingress使用</h4><h5 id="7-5-1-环境准备-搭建ingress环境"><a href="#7-5-1-环境准备-搭建ingress环境" class="headerlink" title="7.5.1 环境准备 搭建ingress环境"></a>7.5.1 环境准备 搭建ingress环境</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># mkdir ingress-controller</span></span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># cd ingress-controller/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ingress-nginx，本次案例使用的是0.30版本</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mandatory.yaml文件中的仓库</span></span><br><span class="line"><span class="comment"># 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 创建ingress-nginx</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-nginx</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># kubectl get pod -n ingress-nginx</span></span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx-ingress-controller-fbf967dd5-4qpbp   1/1     Running   0          12h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[root@k8s-master01 ingress-controller]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx   NodePort   10.98.75.163   &lt;none&gt;        80:32240/TCP,443:31335/TCP   11h</span><br></pre></td></tr></table></figure>

<h5 id="7-5-2-准备service和pod"><a href="#7-5-2-准备service和pod" class="headerlink" title="7.5.2 准备service和pod"></a>7.5.2 准备service和pod</h5><p>为了后面的实验比较方便，创建如下图所示的模型</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200516102419998.png" class="" title="img">

<p>创建tomcat-nginx.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat:8.5-jre10-slim</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f tomcat-nginx.yaml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get svc -n dev</span><br><span class="line">NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nginx-service    ClusterIP   None         &lt;none&gt;        80/TCP     48s</span><br><span class="line">tomcat-service   ClusterIP   None         &lt;none&gt;        8080/TCP   48s</span><br></pre></td></tr></table></figure>

<h5 id="7-5-3-Http代理"><a href="#7-5-3-Http代理" class="headerlink" title="7.5.3 Http代理"></a>7.5.3 Http代理</h5><p>创建ingress-http.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-http</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f ingress-http.yaml</span><br><span class="line">ingress.extensions/ingress-http created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get ing ingress-http -n dev</span><br><span class="line">NAME           HOSTS                                  ADDRESS   PORTS   AGE</span><br><span class="line">ingress-http   nginx.itheima.com,tomcat.itheima.com             80      22s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe ing ingress-http  -n dev</span><br><span class="line">...</span><br><span class="line">Rules:</span><br><span class="line">Host                Path  Backends</span><br><span class="line">----                ----  --------</span><br><span class="line">nginx.itheima.com   / nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80)</span><br><span class="line">tomcat.itheima.com  / tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080)</span><br><span class="line">...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了</span></span><br></pre></td></tr></table></figure>

<h5 id="7-5-4-Https代理"><a href="#7-5-4-Https代理" class="headerlink" title="7.5.4 Https代理"></a>7.5.4 Https代理</h5><p>创建证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成证书</span></span><br><span class="line">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建密钥</span></span><br><span class="line">kubectl create secret tls tls-secret --key tls.key --cert tls.crt</span><br></pre></td></tr></table></figure>

<p>创建ingress-https.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-https</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 指定秘钥</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f ingress-https.yaml</span><br><span class="line">ingress.extensions/ingress-https created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get ing ingress-https -n dev</span><br><span class="line">NAME            HOSTS                                  ADDRESS         PORTS     AGE</span><br><span class="line">ingress-https   nginx.itheima.com,tomcat.itheima.com   10.104.184.38   80, 443   2m42s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe ing ingress-https -n dev</span><br><span class="line">...</span><br><span class="line">TLS:</span><br><span class="line">  tls-secret terminates nginx.itheima.com,tomcat.itheima.com</span><br><span class="line">Rules:</span><br><span class="line">Host              Path Backends</span><br><span class="line">----              ---- --------</span><br><span class="line">nginx.itheima.com  /  nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80)</span><br><span class="line">tomcat.itheima.com /  tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080)</span><br><span class="line">...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了</span></span><br></pre></td></tr></table></figure>

<h3 id="8-数据存储"><a href="#8-数据存储" class="headerlink" title="8. 数据存储"></a>8. 数据存储</h3><p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h4 id="8-1-基本存储"><a href="#8-1-基本存储" class="headerlink" title="8.1 基本存储"></a>8.1 基本存储</h4><h5 id="8-1-1-EmptyDir"><a href="#8-1-1-EmptyDir" class="headerlink" title="8.1.1 EmptyDir"></a>8.1.1 EmptyDir</h5><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p>
<p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p>
<ul>
<li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li>
<li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li>
</ul>
<p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p>
<p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200413174713773.png" class="" title="img">

<p>创建一个volume-emptydir.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-emptydir</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件中内容</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume， name为logs-volume，类型为emptyDir</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f volume-emptydir.yaml</span><br><span class="line">pod/volume-emptydir created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods volume-emptydir -n dev -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE      IP       NODE   ...... </span><br><span class="line">volume-emptydir       2/2     Running   0          97s   10.42.2.9   node1  ......</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过podIp访问nginx</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.42.2.9</span><br><span class="line">......</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过kubectl logs命令查看指定容器的标准输出</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox</span><br><span class="line">10.42.1.0 - - [27/Jun/2021:15:08:54 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure>

<h5 id="8-1-2-HostPath"><a href="#8-1-2-HostPath" class="headerlink" title="8.1.2 HostPath"></a>8.1.2 HostPath</h5><p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200413214031331.png" class="" title="img">

<p>创建一个volume-hostpath.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-hostpath</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/logs</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span>  <span class="comment"># 目录存在就使用，不存在就先创建后使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于type的值的一点说明：</span><br><span class="line">    DirectoryOrCreate 目录存在就使用，不存在就先创建后使用</span><br><span class="line">    Directory   目录必须存在</span><br><span class="line">    FileOrCreate  文件存在就使用，不存在就先创建后使用</span><br><span class="line">    File 文件必须存在 </span><br><span class="line">    Socket  unix套接字必须存在</span><br><span class="line">    CharDevice  字符设备必须存在</span><br><span class="line">    BlockDevice 块设备必须存在</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f volume-hostpath.yaml</span><br><span class="line">pod/volume-hostpath created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods volume-hostpath -n dev -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......</span><br><span class="line">pod-volume-hostpath   2/2     Running   0          16s   10.42.2.10     node1  ......</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">访问nginx</span></span><br><span class="line">[root@k8s-master01 ~]# curl 10.42.2.10</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来就可以去host的/root/logs目录下查看存储的文件了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）</span></span></span><br><span class="line">[root@node1 ~]# ls /root/logs/</span><br><span class="line">access.log  error.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的</span></span><br></pre></td></tr></table></figure>

<h5 id="8-1-3-NFS"><a href="#8-1-3-NFS" class="headerlink" title="8.1.3 NFS"></a>8.1.3 NFS</h5><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p>
<p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200413215133559.png" class="" title="img">

<p>1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在nfs上安装nfs服务</span></span><br><span class="line">[root@nfs ~]# yum install nfs-utils -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 准备一个共享目录</span></span><br><span class="line">[root@nfs ~]# mkdir /root/data/nfs -pv</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将共享目录以读写权限暴露给192.168.5.0/24网段中的所有主机</span></span><br><span class="line">[root@nfs ~]# vim /etc/exports</span><br><span class="line">[root@nfs ~]# more /etc/exports</span><br><span class="line">/root/data/nfs     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nfs服务</span></span><br><span class="line">[root@nfs ~]# systemctl restart nfs</span><br></pre></td></tr></table></figure>

<p>2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在node上安装nfs服务，注意不需要启动</span></span><br><span class="line">[root@k8s-master01 ~]# yum install nfs-utils -y</span><br></pre></td></tr></table></figure>

<p>3）接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-nfs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] </span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span>  <span class="comment">#nfs服务器地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/data/nfs</span> <span class="comment">#共享文件路径</span></span><br></pre></td></tr></table></figure>

<p>4）最后，运行下pod，观察结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f volume-nfs.yaml</span><br><span class="line">pod/volume-nfs created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods volume-nfs -n dev</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">volume-nfs        2/2     Running   0          2m9s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nfs服务器上的共享目录，发现已经有文件了</span></span><br><span class="line">[root@k8s-master01 ~]# ls /root/data/</span><br><span class="line">access.log  error.log</span><br></pre></td></tr></table></figure>

<h4 id="8-2-高级存储"><a href="#8-2-高级存储" class="headerlink" title="8.2 高级存储"></a>8.2 高级存储</h4><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p>
<ul>
<li><p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p>
</li>
<li><p>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</p>
</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200514194111567.png" class="" title="img">

<p>使用了PV和PVC之后，工作可以得到进一步的细分：</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV： kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h5 id="8-2-1-PV"><a href="#8-2-1-PV" class="headerlink" title="8.2.1 PV"></a>8.2.1 PV</h5><p>PV是存储资源的抽象，下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型，与底层真正存储对应</span></span><br><span class="line">  <span class="attr">capacity:</span>  <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span>  <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>

<p>PV 的关键配置参数说明：</p>
<ul>
<li><p><strong>存储类型</strong></p>
<p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p>
</li>
<li><p><strong>存储能力（capacity）</strong></p>
</li>
</ul>
<p>目前只支持存储空间的设置( storage=1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p>
<ul>
<li><p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p>
</li>
<li><p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p>
<p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p>
<ul>
<li>Retain （保留） 保留数据，需要管理员手工清理数据</li>
<li>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*</li>
<li>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的回收策略不同</code></p>
</li>
<li><p><strong>存储类别</strong></p>
<p>PV可以通过storageClassName参数指定一个存储类别</p>
<ul>
<li>具有特定类别的PV只能与请求了该类别的PVC进行绑定</li>
<li>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li>
</ul>
</li>
<li><p><strong>状态（status）</strong></p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>Available（可用）： 表示可用状态，还未被任何 PVC 绑定</li>
<li>Bound（已绑定）： 表示 PV 已经被 PVC 绑定</li>
<li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）： 表示该 PV 的自动回收失败</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p>
<ol>
<li>准备NFS环境</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">[root@nfs ~]# mkdir /root/data/&#123;pv1,pv2,pv3&#125; -pv</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暴露服务</span></span><br><span class="line">[root@nfs ~]# more /etc/exports</span><br><span class="line">/root/data/pv1     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line">/root/data/pv2     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line">/root/data/pv3     192.168.5.0/24(rw,no_root_squash)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">[root@nfs ~]#  systemctl restart nfs</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建pv.yaml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv1</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv2</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv3</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pv.yaml</span><br><span class="line">persistentvolume/pv1 created</span><br><span class="line">persistentvolume/pv2 created</span><br><span class="line">persistentvolume/pv3 created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pv -o wide</span><br><span class="line">NAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODE</span><br><span class="line">pv1    1Gi        RWX            Retain        Available    10s   Filesystem</span><br><span class="line">pv2    2Gi        RWX            Retain        Available    10s   Filesystem</span><br><span class="line">pv3    3Gi        RWX            Retain        Available    9s    Filesystem</span><br></pre></td></tr></table></figure>

<h5 id="8-2-2-PVC"><a href="#8-2-2-PVC" class="headerlink" title="8.2.2 PVC"></a>8.2.2 PVC</h5><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>

<p>PVC 的关键配置参数说明：</p>
<ul>
<li><strong>访问模式（accessModes）</strong></li>
</ul>
<p>用于描述用户应用对存储资源的访问权限</p>
<ul>
<li><p><strong>选择条件（selector）</strong></p>
<p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p>
</li>
<li><p><strong>存储类别（storageClassName）</strong></p>
<p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p>
</li>
<li><p><strong>资源请求（Resources ）</strong></p>
<p>描述对存储资源的请求</p>
</li>
</ul>
<p><strong>实验</strong></p>
<ol>
<li>创建pvc.yaml，申请pv</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pvc</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pvc.yaml</span><br><span class="line">persistentvolumeclaim/pvc1 created</span><br><span class="line">persistentvolumeclaim/pvc2 created</span><br><span class="line">persistentvolumeclaim/pvc3 created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pvc</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pvc  -n dev -o wide</span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      1Gi        RWX                           15s   Filesystem</span><br><span class="line">pvc2   Bound    pv2      2Gi        RWX                           15s   Filesystem</span><br><span class="line">pvc3   Bound    pv3      3Gi        RWX                           15s   Filesystem</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pv -o wide</span><br><span class="line">NAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    1Gi        RWx        Retain          Bound    dev/pvc1    3h37m    Filesystem</span><br><span class="line">pv2    2Gi        RWX        Retain          Bound    dev/pvc2    3h37m    Filesystem</span><br><span class="line">pv3    3Gi        RWX        Retain          Bound    dev/pvc3    3h37m    Filesystem   </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建pods.yaml, 使用pv</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc1</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc2</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pods.yaml</span><br><span class="line">pod/pod1 created</span><br><span class="line">pod/pod2 created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide</span><br><span class="line">NAME   READY   STATUS    RESTARTS   AGE   IP            NODE   </span><br><span class="line">pod1   1/1     Running   0          14s   10.244.1.69   node1   </span><br><span class="line">pod2   1/1     Running   0          14s   10.244.1.70   node1  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pvc</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pvc -n dev -o wide</span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      1Gi        RWX               94m   Filesystem</span><br><span class="line">pvc2   Bound    pv2      2Gi        RWX               94m   Filesystem</span><br><span class="line">pvc3   Bound    pv3      3Gi        RWX               94m   Filesystem</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pv</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pv -n dev -o wide</span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    1Gi        RWX            Retain           Bound    dev/pvc1    5h11m   Filesystem</span><br><span class="line">pv2    2Gi        RWX            Retain           Bound    dev/pvc2    5h11m   Filesystem</span><br><span class="line">pv3    3Gi        RWX            Retain           Bound    dev/pvc3    5h11m   Filesystem</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nfs中的文件存储</span></span><br><span class="line">[root@nfs ~]# more /root/data/pv1/out.txt</span><br><span class="line">node1</span><br><span class="line">node1</span><br><span class="line">[root@nfs ~]# more /root/data/pv2/out.txt</span><br><span class="line">node2</span><br><span class="line">node2</span><br></pre></td></tr></table></figure>

<h5 id="8-2-3-生命周期"><a href="#8-2-3-生命周期" class="headerlink" title="8.2.3 生命周期"></a>8.2.3 生命周期</h5><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p>
<ul>
<li><p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p>
</li>
<li><p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定</p>
<p>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p>
<ul>
<li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li>
<li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</li>
</ul>
<p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p>
</li>
<li><p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p>
<p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p>
</li>
<li><p><strong>资源释放</strong>：用户删除pvc来释放pv</p>
<p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p>
</li>
<li><p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p>
<p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p>
</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200515002806726.png" class="" title="img">

<h4 id="8-3-配置存储"><a href="#8-3-配置存储" class="headerlink" title="8.3 配置存储"></a>8.3 配置存储</h4><h5 id="8-3-1-ConfigMap"><a href="#8-3-1-ConfigMap" class="headerlink" title="8.3.1 ConfigMap"></a>8.3.1 ConfigMap</h5><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p>
<p>创建configmap.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    username:admin</span></span><br><span class="line"><span class="string">    password:123456</span></span><br></pre></td></tr></table></figure>

<p>接下来，使用此配置文件创建configmap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建configmap</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f configmap.yaml</span><br><span class="line">configmap/configmap created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看configmap详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe cm configmap -n dev</span><br><span class="line">Name:         configmap</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">info:</span><br><span class="line">----</span><br><span class="line">username:admin</span><br><span class="line">password:123456</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将configmap挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/configmap/config</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 引用configmap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">configmap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-configmap.yaml</span><br><span class="line">pod/pod-configmap created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-configmap -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-configmap   1/1     Running   0          6s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec -it pod-configmap -n dev /bin/sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /configmap/config/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">info</span><br><span class="line"><span class="meta">#</span><span class="bash"> more info</span></span><br><span class="line">username:admin</span><br><span class="line">password:123456</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到映射已经成功，每个configmap都映射成了一个目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> key---&gt;文件     value----&gt;文件中的内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时如果更新configmap的内容, 容器中的值也会动态更新</span></span><br></pre></td></tr></table></figure>

<h5 id="8-3-2-Secret"><a href="#8-3-2-Secret" class="headerlink" title="8.3.2 Secret"></a>8.3.2 Secret</h5><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>
<ol>
<li>首先使用base64对数据进行编码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 ~]# echo -n &#x27;admin&#x27; | base64 #准备username</span><br><span class="line">YWRtaW4=</span><br><span class="line">[root@k8s-master01 ~]# echo -n &#x27;123456&#x27; | base64 #准备password</span><br><span class="line">MTIzNDU2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接下来编写secret.yaml，并创建Secret</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建secret</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f secret.yaml</span><br><span class="line">secret/secret created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看secret详情</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe secret secret -n dev</span><br><span class="line">Name:         secret</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Type:  Opaque</span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">password:  6 bytes</span><br><span class="line">username:  5 bytes</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建pod-secret.yaml，将上面创建的secret挂载进去：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将secret挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/secret/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f pod-secret.yaml</span><br><span class="line">pod/pod-secret created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod pod-secret -n dev</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod-secret      1/1     Running   0          2m28s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器，查看secret信息，发现已经自动解码了</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl exec -it pod-secret /bin/sh -n dev</span><br><span class="line">/ # ls /secret/config/</span><br><span class="line">password  username</span><br><span class="line">/ # more /secret/config/username</span><br><span class="line">admin</span><br><span class="line">/ # more /secret/config/password</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>至此，已经实现了利用secret实现了信息的编码。</p>
<h3 id="9-安全认证"><a href="#9-安全认证" class="headerlink" title="9. 安全认证"></a>9. 安全认证</h3><h4 id="9-1-访问控制概述"><a href="#9-1-访问控制概述" class="headerlink" title="9.1 访问控制概述"></a>9.1 访问控制概述</h4><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种<strong>客户端</strong>进行<strong>认证和鉴权</strong>操作。</p>
<p><strong>客户端</strong></p>
<p>在Kubernetes集群中，客户端通常有两类：</p>
<ul>
<li><strong>User Account</strong>：一般是独立于kubernetes之外的其他服务管理的用户账号。</li>
<li><strong>Service Account</strong>：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520102949189.png" class="" title="img">

<p><strong>认证、授权与准入控制</strong></p>
<p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p>
<ul>
<li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li>
<li>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作</li>
<li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520103942580.png" class="" title="img">

<h4 id="9-2-认证管理"><a href="#9-2-认证管理" class="headerlink" title="9.2 认证管理"></a>9.2 认证管理</h4><p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p>
<ul>
<li><p>HTTP Base认证：通过用户名+密码的方式认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</span><br></pre></td></tr></table></figure></li>
<li><p>HTTP Token认证：通过一个Token来识别合法用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</span><br></pre></td></tr></table></figure></li>
<li><p>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200518211037434.png" class="" title="img">

<p><strong>HTTPS认证大体分为3个过程：</strong></p>
<ol>
<li><p>证书申请和下发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者</span><br></pre></td></tr></table></figure></li>
<li><p>客户端和服务端的双向认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端，</span><br><span class="line">   客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，</span><br><span class="line">   客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器</span><br><span class="line">2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，</span><br><span class="line">   在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</span><br></pre></td></tr></table></figure></li>
<li><p>服务器端和客户端进行通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。</span><br><span class="line">服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p>
</blockquote>
<h4 id="9-3-授权管理"><a href="#9-3-授权管理" class="headerlink" title="9.3 授权管理"></a>9.3 授权管理</h4><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p>
<p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p>
<p>API Server目前支持以下几种授权策略：</p>
<ul>
<li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li>
<li>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li>
<li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部REST服务对用户进行授权</li>
<li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</li>
<li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li>
</ul>
<p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：<strong>给哪些对象授予了哪些权限</strong></p>
<p>其中涉及到了下面几个概念：</p>
<ul>
<li>对象：User、Groups、ServiceAccount</li>
<li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li>
<li>绑定：将定义好的角色跟用户绑定在一起</li>
</ul>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200519181209566.png" class="" title="img">

<p>RBAC引入了4个顶级资源对象：</p>
<ul>
<li>Role、ClusterRole：角色，用于指定一组权限</li>
<li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li>
</ul>
<p><strong>Role、ClusterRole</strong></p>
<p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Role只能对命名空间内的资源进行授权，需要指定nameapce</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]  <span class="comment"># 支持的API组列表,&quot;&quot; 空字符串，表示核心API群</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>] <span class="comment"># 允许的对资源对象的操作方法列表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>需要详细说明的是，rules中的参数：</p>
<ul>
<li><p>apiGroups: 支持的API组列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>,<span class="string">&quot;apps&quot;</span>, <span class="string">&quot;autoscaling&quot;</span>, <span class="string">&quot;batch&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>resources：支持的资源对象列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;services&quot;</span>, <span class="string">&quot;endpoints&quot;</span>, <span class="string">&quot;pods&quot;</span>,<span class="string">&quot;secrets&quot;</span>,<span class="string">&quot;configmaps&quot;</span>,<span class="string">&quot;crontabs&quot;</span>,<span class="string">&quot;deployments&quot;</span>,<span class="string">&quot;jobs&quot;</span>,</span><br><span class="line"><span class="string">&quot;nodes&quot;</span>,<span class="string">&quot;rolebindings&quot;</span>,<span class="string">&quot;clusterroles&quot;</span>,<span class="string">&quot;daemonsets&quot;</span>,<span class="string">&quot;replicasets&quot;</span>,<span class="string">&quot;statefulsets&quot;</span>,</span><br><span class="line"><span class="string">&quot;horizontalpodautoscalers&quot;</span>,<span class="string">&quot;replicationcontrollers&quot;</span>,<span class="string">&quot;cronjobs&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>verbs：对资源对象的操作方法列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;exec&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>RoleBinding、ClusterRoleBinding</strong></p>
<p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>RoleBinding引用ClusterRole进行授权</strong></p>
<p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding</span></span><br><span class="line"><span class="comment"># 所以heima只能读取dev命名空间中的资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding-ns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>实战：创建一个只能管理dev空间下Pods资源的账号</strong></p>
<ol>
<li>创建账号</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1) 创建证书</span></span><br><span class="line">[root@k8s-master01 pki]# cd /etc/kubernetes/pki/</span><br><span class="line">[root@k8s-master01 pki]# (umask 077;openssl genrsa -out devman.key 2048)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) 用apiserver的证书去签署</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2-1) 签名申请，申请的用户是devman,组是devgroup</span></span><br><span class="line">[root@k8s-master01 pki]# openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2-2) 签署证书</span></span><br><span class="line">[root@k8s-master01 pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3) 设置集群、用户、上下文信息</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.109.100:6443</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 pki]# kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 pki]# kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换账户到devman</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes</span><br><span class="line">Switched to context &quot;devman@kubernetes&quot;.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看dev下pod，发现没有权限</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl get pods -n dev</span><br><span class="line">Error from server (Forbidden): pods is forbidden: User &quot;devman&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;dev&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到admin账户</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes</span><br><span class="line">Switched to context &quot;kubernetes-admin@kubernetes&quot;.</span><br></pre></td></tr></table></figure>

<p>2） 创建Role和RoleBinding，为devman用户授权</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">devman</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-master01 pki]# kubectl create -f dev-role.yaml</span><br><span class="line">role.rbac.authorization.k8s.io/dev-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/authorization-role-binding created</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>切换账户，再次验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换账户到devman</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context devman@kubernetes</span><br><span class="line">Switched to context &quot;devman@kubernetes&quot;.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl get pods -n dev</span><br><span class="line">NAME                                 READY   STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment-66cb59b984-8wp2k    1/1     Running            0          4d1h</span><br><span class="line">nginx-deployment-66cb59b984-dc46j    1/1     Running            0          4d1h</span><br><span class="line">nginx-deployment-66cb59b984-thfck    1/1     Running            0          4d1h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了不影响后面的学习,切回admin账户</span></span><br><span class="line">[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes</span><br><span class="line">Switched to context &quot;kubernetes-admin@kubernetes&quot;.</span><br></pre></td></tr></table></figure>

<h4 id="9-4-准入控制"><a href="#9-4-准入控制" class="headerlink" title="9.4 准入控制"></a>9.4 准入控制</h4><p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p>
<p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,</span><br><span class="line">                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</span><br></pre></td></tr></table></figure>

<p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p>
<p>当前可配置的Admission Control准入控制如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，一般用于测试</li>
<li>AlwaysPullImages：在启动容器之前总去下载镜像</li>
<li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li>
<li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li>
<li>Service Account：实现ServiceAccount实现了自动化</li>
<li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li>
<li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li>
<li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li>
<li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li>
<li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li>
<li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li>
<li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li>
<li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li>
</ul>
<h3 id="10-DashBoard"><a href="#10-DashBoard" class="headerlink" title="10. DashBoard"></a>10. DashBoard</h3><p>之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。</p>
<h4 id="10-1-部署Dashboard"><a href="#10-1-部署Dashboard" class="headerlink" title="10.1 部署Dashboard"></a>10.1 部署Dashboard</h4><ol>
<li>下载yaml，并运行Dashboard</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载yaml</span></span><br><span class="line">[root@k8s-master01 ~]# wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改kubernetes-dashboard的Service类型</span></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort  # 新增</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30009  # 新增</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f recommended.yaml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看namespace下的kubernetes-dashboard下的资源</span></span><br><span class="line">[root@k8s-master01 ~]# kubectl get pod,svc -n kubernetes-dashboard</span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-c79c65bb7-zwfvw   1/1     Running   0          111s</span><br><span class="line">pod/kubernetes-dashboard-56484d4c5-z95z5        1/1     Running   0          111s</span><br><span class="line"></span><br><span class="line">NAME                               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)         AGE</span><br><span class="line">service/dashboard-metrics-scraper  ClusterIP  10.96.89.218    &lt;none&gt;       8000/TCP        111s</span><br><span class="line">service/kubernetes-dashboard       NodePort   10.104.178.171  &lt;none&gt;       443:30009/TCP   111s</span><br></pre></td></tr></table></figure>

<p>2）创建访问账户，获取token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建账号</span></span><br><span class="line">[root@k8s-master01-1 ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权</span></span><br><span class="line">[root@k8s-master01-1 ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取账号token</span></span><br><span class="line">[root@k8s-master01 ~]#  kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin</span><br><span class="line">dashboard-admin-token-xbqhh        kubernetes.io/service-account-token   3      2m35s</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboard</span><br><span class="line">Name:         dashboard-admin-token-xbqhh</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: dashboard-admin</span><br><span class="line">              kubernetes.io/service-account.uid: 95d84d80-be7a-4d10-a2e0-68f90222d039</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLw</span><br><span class="line">ca.crt:     1025 bytes</span><br></pre></td></tr></table></figure>

<p>3）通过浏览器访问Dashboard的UI</p>
<p>在登录页面上输入上面的token</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520144548997.png" class="" title="image-20200520144548997">

<p>出现下面的页面代表成功</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520144959353.png" class="" title="image-20200520144959353">

<h4 id="10-2-使用DashBoard"><a href="#10-2-使用DashBoard" class="headerlink" title="10.2 使用DashBoard"></a>10.2 使用DashBoard</h4><p>本章节以Deployment为例演示DashBoard的使用</p>
<p><strong>查看</strong></p>
<p>选择指定的命名空间<code>dev</code>，然后点击<code>Deployments</code>，查看dev空间下的所有deployment</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520154628679.png" class="" title="img">

<p><strong>扩缩容</strong></p>
<p>在<code>Deployment</code>上点击<code>规模</code>，然后指定<code>目标副本数量</code>，点击确定</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520162605102.png" class="" title="img">

<p><strong>编辑</strong></p>
<p>在<code>Deployment</code>上点击<code>编辑</code>，然后修改<code>yaml文件</code>，点击确定</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520163253644.png" class="" title="image-20200520163253644">

<p><strong>查看Pod</strong></p>
<p>点击<code>Pods</code>, 查看pods列表</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520163552110.png" class="" title="img">

<p><strong>操作Pod</strong></p>
<p>选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作</p>
<img src="/2022/02/12/kubernetes%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20200520163832827.png" class="" title="img">

<blockquote>
<p>Dashboard提供了kubectl的绝大部分功能，这里不再一一演示</p>
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1GT4y1A756?spm_id_from=333.788.b_636f6d6d656e74.19">原视频地址</a></p>
<p><a href="https://gitee.com/yooome/golang">原文章地址</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>redis相关知识</title>
    <url>/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h5 id="1、NoSQL数据库简介"><a href="#1、NoSQL数据库简介" class="headerlink" title="1、NoSQL数据库简介"></a><a href="#1%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B">1、NoSQL数据库简介</a></h5><h5 id="2、Redis6概述和安装"><a href="#2、Redis6概述和安装" class="headerlink" title="2、Redis6概述和安装"></a><a href="2%E3%80%81Redis6%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85">2、Redis6概述和安装</a></h5><h5 id="3、常用五大数据类型"><a href="#3、常用五大数据类型" class="headerlink" title="3、常用五大数据类型"></a><a href="3%E3%80%81%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">3、常用五大数据类型</a></h5><h5 id="4、Redis6配置文件详解"><a href="#4、Redis6配置文件详解" class="headerlink" title="4、Redis6配置文件详解"></a><a href="4%E3%80%81Redis6%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">4、Redis6配置文件详解</a></h5><h5 id="5、Redis6的发布和订阅"><a href="#5、Redis6的发布和订阅" class="headerlink" title="5、Redis6的发布和订阅"></a><a href="5%E3%80%81Redis6%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85">5、Redis6的发布和订阅</a></h5><h5 id="6、Redis6新数据类型"><a href="#6、Redis6新数据类型" class="headerlink" title="6、Redis6新数据类型"></a><a href="6%E3%80%81Redis6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">6、Redis6新数据类型</a></h5><h5 id="7、Jedis操作Redis6"><a href="#7、Jedis操作Redis6" class="headerlink" title="7、Jedis操作Redis6"></a><a href="7%E3%80%81Jedis%E6%93%8D%E4%BD%9CRedis6">7、Jedis操作Redis6</a></h5><h5 id="8、Redis6与SpringBoot整合"><a href="#8、Redis6与SpringBoot整合" class="headerlink" title="8、Redis6与SpringBoot整合"></a><a href="8%E3%80%81Redis6%E4%B8%8ESpringBoot%E6%95%B4%E5%90%88">8、Redis6与SpringBoot整合</a></h5><h5 id="9、Redis6的事务操作"><a href="#9、Redis6的事务操作" class="headerlink" title="9、Redis6的事务操作"></a><a href="9%E3%80%81Redis6%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C">9、Redis6的事务操作</a></h5><h5 id="10、Redis6持久化之RDB"><a href="#10、Redis6持久化之RDB" class="headerlink" title="10、Redis6持久化之RDB"></a><a href="10%E3%80%81Redis6%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB">10、Redis6持久化之RDB</a></h5><h5 id="11、Redis6持久化之AOF"><a href="#11、Redis6持久化之AOF" class="headerlink" title="11、Redis6持久化之AOF"></a><a href="11%E3%80%81Redis6%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF">11、Redis6持久化之AOF</a></h5><h5 id="12、Redis6的主从复制"><a href="#12、Redis6的主从复制" class="headerlink" title="12、Redis6的主从复制"></a><a href="12%E3%80%81Redis6%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">12、Redis6的主从复制</a></h5><h5 id="13、Redis6集群"><a href="#13、Redis6集群" class="headerlink" title="13、Redis6集群"></a><a href="13%E3%80%81Redis6%E9%9B%86%E7%BE%A4">13、Redis6集群</a></h5><h5 id="14、Redis6应用问题解决"><a href="#14、Redis6应用问题解决" class="headerlink" title="14、Redis6应用问题解决"></a><a href="14%E3%80%81Redis6%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">14、Redis6应用问题解决</a></h5><h5 id="15、Redis6新功能"><a href="#15、Redis6新功能" class="headerlink" title="15、Redis6新功能"></a><a href="15%E3%80%81Redis6%E6%96%B0%E5%8A%9F%E8%83%BD">15、Redis6新功能</a></h5><hr>
<span id="more"></span>

<h4 id="一、NoSQL数据库简介"><a href="#一、NoSQL数据库简介" class="headerlink" title="一、NoSQL数据库简介"></a>一、NoSQL数据库简介</h4><h5 id="1-1-技术发展"><a href="#1-1-技术发展" class="headerlink" title="1.1 技术发展"></a>1.1 技术发展</h5><p>技术的分类</p>
<p>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p>
<p>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p>
<p>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>
<h6 id="1-1-1-Web1-0时代"><a href="#1-1-1-Web1-0时代" class="headerlink" title="1.1.1 Web1.0时代"></a>1.1.1 Web1.0时代</h6><p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20211106223642396.png" class="" title="image-20211106223642396">

<h6 id="1-1-2-Web2-0时代"><a href="#1-1-2-Web2-0时代" class="headerlink" title="1.1.2 Web2.0时代"></a>1.1.2 Web2.0时代</h6><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20211106175858853.png" class="" title="image-20211106175858853"> 

<h6 id="1-1-3-解决CPU及内存压力"><a href="#1-1-3-解决CPU及内存压力" class="headerlink" title="1.1.3 解决CPU及内存压力"></a>1.1.3 解决CPU及内存压力</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsnBGq2y.png" class="" title="img"> 

<h6 id="1-1-4-解决IO压力"><a href="#1-1-4-解决IO压力" class="headerlink" title="1.1.4 解决IO压力"></a>1.1.4 解决IO压力</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpse2F612.png" class="" title="img"> 

<h5 id="1-2-NoSQL数据库"><a href="#1-2-NoSQL数据库" class="headerlink" title="1.2 NoSQL数据库"></a>1.2 NoSQL数据库</h5><h6 id="1-2-1-NoSQL数据库概述"><a href="#1-2-1-NoSQL数据库概述" class="headerlink" title="1.2.1 NoSQL数据库概述"></a>1.2.1 NoSQL数据库概述</h6><p>NoSQL(NoSQL = <strong>Not Only SQL</strong>)，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 </p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li><p>不遵循SQL标准。</p>
</li>
<li><p>不支持ACID。</p>
</li>
<li><p>远超于SQL的性能。</p>
</li>
</ul>
<h6 id="1-2-2-NoSQL适用场景"><a href="#1-2-2-NoSQL适用场景" class="headerlink" title="1.2.2 NoSQL适用场景"></a>1.2.2 NoSQL适用场景</h6><ul>
<li><p>对数据高并发的读写</p>
</li>
<li><p>海量数据的读写</p>
</li>
<li><p>对数据高可扩展性的</p>
</li>
</ul>
<h6 id="1-2-3-NoSQL不适用场景"><a href="#1-2-3-NoSQL不适用场景" class="headerlink" title="1.2.3 NoSQL不适用场景"></a>1.2.3 NoSQL不适用场景</h6><ul>
<li><p>需要事务支持</p>
</li>
<li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
</li>
<li><p>用不着sql的和用了sql也不行的情况，请考虑用NoSql）</p>
</li>
</ul>
<h6 id="1-2-4-Memcache"><a href="#1-2-4-Memcache" class="headerlink" title="1.2.4 Memcache"></a>1.2.4 Memcache</h6><table>
<thead>
<tr>
<th><img src="redis相关知识/wpsC3MRJ1.png" alt="img" style="zoom:75%;" /></th>
<th>ü 很早出现的NoSql数据库ü 数据都在内存中，一般不持久化ü 支持简单的key-value模式，支持类型单一ü 一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="1-2-5-Redis"><a href="#1-2-5-Redis" class="headerlink" title="1.2.5 Redis"></a>1.2.5 Redis</h6><table>
<thead>
<tr>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsxexKeP.png" class="" title="img"></th>
<th>几乎覆盖了Memcached的绝大部分功能数据都在内存中，支持持久化，主要用作备份恢复除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="1-2-6-MongoDB"><a href="#1-2-6-MongoDB" class="headerlink" title="1.2.6 MongoDB"></a>1.2.6 MongoDB</h6><table>
<thead>
<tr>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps9uGosP.png" class="" title="img"></th>
<th>ü 高性能、开源、模式自由(schema  free)的文档型数据库ü 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘ü 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能ü 支持二进制数据及大型对象ü 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="1-3-行式存储数据库（大数据时代）"><a href="#1-3-行式存储数据库（大数据时代）" class="headerlink" title="1.3 行式存储数据库（大数据时代）"></a>1.3 行式存储数据库（大数据时代）</h5><h6 id="1-3-2-行式数据库"><a href="#1-3-2-行式数据库" class="headerlink" title="1.3.2 行式数据库"></a>1.3.2 行式数据库</h6><img src="redis相关知识/wpsP36kKk.png" alt="img" style="zoom:75%;" /> 

<h6 id="1-3-3-列式数据库"><a href="#1-3-3-列式数据库" class="headerlink" title="1.3.3 列式数据库"></a>1.3.3 列式数据库</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsxy3fnz.png" class="" title="img"> 

<p>Hbase</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsQHkGeH.png" class="" title="img"> 

<p>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</p>
<p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表。</p>
<p>Cassandra[kəˈsændrə]</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsaK86nQ.png" class="" title="img"> 

<p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<blockquote>
<p>计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>
<p>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。</p>
<p>字节 byte：8个二进制位为一个字节(B)，最常用的单位。</p>
<p>1KB (Kilobyte 千字节)=1024B，</p>
<p>1MB (Megabyte 兆字节 简称“兆”)=1024KB，</p>
<p>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，</p>
<p>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，</p>
<p>1PB（Petabyte 千万亿字节 拍字节）=1024TB，</p>
<p>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，</p>
<p>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,</p>
<p>1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,</p>
<p>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p>
<p>注：“兆”为百万级数量单位。</p>
</blockquote>
<h5 id="1-4-图关系型数据库"><a href="#1-4-图关系型数据库" class="headerlink" title="1.4 图关系型数据库"></a>1.4 图关系型数据库</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsIkF7t0.png" class="" title="img"> 

<p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsFBhaQX.png" class="" title="img"> 

<h5 id="1-5-DB-Engines-数据库排名"><a href="#1-5-DB-Engines-数据库排名" class="headerlink" title="1.5 DB-Engines 数据库排名"></a>1.5 DB-Engines 数据库排名</h5><p><a href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsb5t8zl.jpg" class="" title="img"> 

<h4 id="二、Redis概述安装"><a href="#二、Redis概述安装" class="headerlink" title="二、Redis概述安装"></a>二、Redis概述安装</h4><p>Ø Redis是一个开源的key-value存储系统。</p>
<p>Ø 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</p>
<p>Ø 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>Ø 在此基础上，Redis支持各种不同方式的排序。</p>
<p>Ø 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>Ø 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>Ø 并且在此基础上实现了master-slave(主从)同步。</p>
<h5 id="2-1-应用场景"><a href="#2-1-应用场景" class="headerlink" title="2.1 应用场景"></a>2.1 应用场景</h5><h6 id="2-1-1-配合关系型数据库做高速缓存"><a href="#2-1-1-配合关系型数据库做高速缓存" class="headerlink" title="2.1.1 配合关系型数据库做高速缓存"></a>2.1.1 配合关系型数据库做高速缓存</h6><p>Ø 高频次，热门访问的数据，降低数据库IO</p>
<p>Ø 分布式架构，做session共享</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsDF5ASI.png" class="" title="img"> 

<h6 id="2-1-2-多样的数据结构存储持久化数据"><a href="#2-1-2-多样的数据结构存储持久化数据" class="headerlink" title="2.1.2 多样的数据结构存储持久化数据"></a>2.1.2 多样的数据结构存储持久化数据</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsIRdcFW.png" class="" title="img"> 

<h5 id="2-2-Redis安装"><a href="#2-2-Redis安装" class="headerlink" title="2.2 Redis安装"></a>2.2 Redis安装</h5><table>
<thead>
<tr>
<th>Redis官方网站</th>
<th>Redis中文官方网站</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://redis.io/">http://redis.io</a></td>
<td><a href="http://redis.cn/">http://redis.cn/</a></td>
</tr>
</tbody></table>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsmUsI3S.jpg" class="" title="img"> 

<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsCvIJto.jpg" class="" title="img"> 

<h6 id="2-2-1-安装版本"><a href="#2-2-1-安装版本" class="headerlink" title="2.2.1 安装版本"></a>2.2.1 安装版本</h6><p>Ø 6.2.1 for Linux（redis-6.2.1.tar.gz）</p>
<p>Ø 不用考虑在windows环境下对Redis的支持</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpswAbLaj.png" class="" title="img"> 

<h6 id="2-2-2-安装步骤"><a href="#2-2-2-安装步骤" class="headerlink" title="2.2.2 安装步骤"></a>2.2.2 安装步骤</h6><p>准备工作：下载安装最新版的gcc编译器</p>
<h6 id="2-2-3-安装C-语言的编译环境"><a href="#2-2-3-安装C-语言的编译环境" class="headerlink" title="2.2.3 安装C 语言的编译环境"></a>2.2.3 安装C 语言的编译环境</h6><ul>
<li><p>yum install centos-release-scl scl-utils-build</p>
</li>
<li><p>yum install -y devtoolset-8-toolchain</p>
</li>
<li><p>scl enable devtoolset-8 bash</p>
</li>
</ul>
<p>测试 gcc版本 </p>
<ul>
<li>gcc –version</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsfo4FjS.jpg" class="" title="img"> 

<ul>
<li><p>下载redis-6.2.1.tar.gz放/opt目录</p>
</li>
<li><p>解压命令：tar -zxvf redis-6.2.1.tar.gz</p>
</li>
<li><p>解压完成后进入目录：cd redis-6.2.1</p>
</li>
<li><p>在redis-6.2.1目录下再次执行make命令（只是编译好）</p>
</li>
<li><p>如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件</p>
</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpstuXSqk.png" class="" title="img"> 

<ul>
<li>解决方案：运行make distclean</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsrmmhyP.png" class="" title="img"> 

<ul>
<li>在redis-6.2.1目录下再次执行make命令（只是编译好）</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps6pB91g.png" class="" title="img"> 

<ul>
<li>跳过make test 继续执行: make install</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpskxuaN8.png" class="" title="img"> 

<h6 id="2-2-4-安装目录：-usr-local-bin"><a href="#2-2-4-安装目录：-usr-local-bin" class="headerlink" title="2.2.4 安装目录：/usr/local/bin"></a>2.2.4 安装目录：/usr/local/bin</h6><pre><code>查看默认安装目录：

redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何

redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲

redis-check-dump：修复有问题的dump.rdb文件

redis-sentinel：Redis集群使用

redis-server：Redis服务器启动命令

redis-cli：客户端，操作入口
</code></pre>
<h6 id="2-2-5-前台启动（不推荐）"><a href="#2-2-5-前台启动（不推荐）" class="headerlink" title="2.2.5 前台启动（不推荐）"></a>2.2.5 前台启动（不推荐）</h6><p>前台启动，命令行窗口不能关闭，否则服务器停止</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsaBCDxO.png" class="" title="img"> 

<h6 id="2-2-6-后台启动（推荐）"><a href="#2-2-6-后台启动（推荐）" class="headerlink" title="2.2.6 后台启动（推荐）"></a>2.2.6 后台启动（推荐）</h6><ol>
<li><p><strong>备份redis.conf</strong></p>
<p>拷贝一份redis.conf到其他目录</p>
<p>cp  /opt/redis-3.2.5/redis.conf  /myredis</p>
</li>
<li><p><strong>后台启动设置daemonize no改成yes</strong></p>
<p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p>
</li>
<li><p><strong>Redis启动</strong></p>
<p>redis-server/myredis/redis.conf</p>
</li>
</ol>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpssZK7Oq.png" class="" title="img"> 

<ol start="4">
<li>用客户端访问：redis-cli</li>
</ol>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsWTcXm7.png" class="" title="img"> 

<ol start="5">
<li><p>多个端口可以：redis-cli -p6379</p>
</li>
<li><p>测试验证： ping</p>
</li>
</ol>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps7UBIz5.png" class="" title="img"> 

<ol start="7">
<li><p>Redis关闭</p>
<p>单实例关闭：redis-cli shutdown</p>
</li>
</ol>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsg5dXyO.png" class="" title="img"> 

<p>也可以进入终端后再关闭</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsoRIYTV.png" class="" title="img"> 

<p>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown</p>
<h6 id="2-2-7-Redis介绍相关知识"><a href="#2-2-7-Redis介绍相关知识" class="headerlink" title="2.2.7 Redis介绍相关知识"></a>2.2.7 Redis介绍相关知识</h6><table>
<thead>
<tr>
<th>端口6379从何而来Alessia  Merz<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsI3kNRH.png" class="" title="img"></th>
<th>默认16个数据库，类似数组下标从0开始，初始默认使用0号库使用命令 select  <dbid>来切换数据库。如: select 8 统一密码管理，所有库同样密码。dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Redis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)</p>
<p>（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）  </p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsMOQK0A.png" class="" title="img"> 

<h4 id="三、常用五大数据类型"><a href="#三、常用五大数据类型" class="headerlink" title="三、常用五大数据类型"></a>三、常用五大数据类型</h4><p>哪里去获得redis常见数据类型操作命令<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h5 id="3-1-Redis键-key"><a href="#3-1-Redis键-key" class="headerlink" title="3.1 Redis键(key)"></a>3.1 Redis键(key)</h5><p>**keys *** 查看当前库所有key   (匹配：keys *1)</p>
<p><strong>exists key:</strong>    判断某个key是否存在</p>
<p><strong>type key :</strong>    查看你的key是什么类型</p>
<p><strong>del key :</strong>   删除指定的key数据</p>
<p><strong>unlink key:</strong>  根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p><strong>expire key 10:</strong>  10秒钟：为给定的key设置过期时间</p>
<p><strong>ttl key:</strong>     查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><strong>select:</strong>    命令切换数据库</p>
<p><strong>dbsize:</strong>    查看当前数据库的key的数量</p>
<p><strong>flushdb:</strong>    清空当前库</p>
<p><strong>flushall:</strong>    通杀全部库</p>
<h5 id="3-2-Redis字符串-String"><a href="#3-2-Redis字符串-String" class="headerlink" title="3.2 Redis字符串(String)"></a>3.2 Redis字符串(String)</h5><h6 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1 简介"></a>3.2.1 简介</h6><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h6 id="3-2-2-常用命令"><a href="#3-2-2-常用命令" class="headerlink" title="3.2.2 常用命令"></a>3.2.2 常用命令</h6><p>set  <key><value>添加键值对</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps5ib5ec.jpg" class="" title="img"> 

<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  <key>查询对应键值</p>
<p>append  <key><value>将给定的<value> 追加到原值的末尾</p>
<p>strlen  <key>获得值的长度</p>
<p>setnx  <key><value>只有在 key 不存在时   设置 key 的值</p>
<p>incr  <key></p>
<p>将 key 中储存的数字值增1</p>
<p>只能对数字值操作，如果为空，新增值为1</p>
<p>decr  <key></p>
<p>将 key 中储存的数字值减1</p>
<p>只能对数字值操作，如果为空，新增值为-1</p>
<p>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</p>
<p>原子性<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpszouWWt.png" class="" title="img"> 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis单命令的原子性主要得益于Redis的单线程。案例：java中的i++是否是原子操作？不是i=0;两个线程分别对i进行++100次,值是多少？ 2~200i=0i++i=99 i=1 i++i=2i=0  i++ i=1 i++ i=100 </p>
<blockquote>
<p><strong>mset</strong>  <key1><value1><key2><value2>  ….. </p>
<p>同时设置一个或多个 key-value对  </p>
<p><strong>mget</strong>  <key1><key2><key3> …..</p>
<p>同时获取一个或多个 value  </p>
<p><strong>msetnx</strong> <key1><value1><key2><value2>  ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p>原子性，有一个失败则都失败</p>
<p><strong>getrange</strong>  <key>&lt;起始位置&gt;&lt;结束位置&gt;</p>
<p>获得值的范围，类似java中的substring，前包，后包</p>
<p><strong>setrange</strong>  <key>&lt;起始位置&gt;<value></p>
<p>用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</p>
<p><strong>setex</strong>  <key>&lt;过期时间&gt;<value></p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p><strong>getset</strong> <key><value></p>
<p>以新换旧，设置了新值同时获得旧值。</p>
</blockquote>
<h6 id="3-2-3-数据结构"><a href="#3-2-3-数据结构" class="headerlink" title="3.2.3 数据结构"></a>3.2.3 数据结构</h6><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsjwPzAS.jpg" class="" title="img"> 

<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h5 id="3-3-Redis列表-List"><a href="#3-3-Redis列表-List" class="headerlink" title="3.3 Redis列表(List)"></a>3.3 Redis列表(List)</h5><h6 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3.3.1 简介"></a>3.3.1 简介</h6><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsl87VGr.png" class="" title="img"> 

<h6 id="3-3-2-常用命令"><a href="#3-3-2-常用命令" class="headerlink" title="3.3.2 常用命令"></a>3.3.2 常用命令</h6><blockquote>
<p><strong>lpush/rpush</strong>  <key><value1><value2><value3> …. 从左边/右边插入一个或多个值。</p>
<p><strong>lpop/rpop</strong>  <key>从左边/右边吐出一个值。值在键在，值光键亡。</p>
<p><strong>rpoplpush</strong>  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p>
<p><strong>lrange</strong> <key><start><stop></p>
<p>按照索引下标获得元素(从左到右)</p>
<p><strong>lrange mylist 0 -1</strong>  0左边第一个，-1右边第一个，（0-1表示获取所有）</p>
<p><strong>lindex</strong> <key><index>按照索引下标获得元素(从左到右)</p>
<p><strong>llen</strong> <key>获得列表长度 </p>
<p><strong>linsert</strong> <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值</p>
<p><strong>lrem</strong> <key><n><value>从左边删除n个value(从左到右)</p>
<p><strong>lset</strong><key><index><value>将列表key下标为index的值替换成value</p>
</blockquote>
<h6 id="3-3-3-数据结构"><a href="#3-3-3-数据结构" class="headerlink" title="3.3.3 数据结构"></a>3.3.3 数据结构</h6><pre><code>List的数据结构为快速链表quickList。

首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。
</code></pre>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsOLgubH.jpg" class="" title="img"> 

<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h5 id="3-4-Redis集合-Set"><a href="#3-4-Redis集合-Set" class="headerlink" title="3.4 Redis集合(Set)"></a>3.4 Redis集合(Set)</h5><h6 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h6><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h6 id="3-4-2-常用命令"><a href="#3-4-2-常用命令" class="headerlink" title="3.4.2 常用命令"></a>3.4.2 常用命令</h6><p>sadd <key><value1><value2> ….. </p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers <key>取出该集合的所有值。</p>
<p>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</p>
<p>scard<key>返回该集合的元素个数。</p>
<p>srem <key><value1><value2> …. 删除集合中的某个元素。</p>
<p>spop <key>随机从该集合中吐出一个值。</p>
<p>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。</p>
<p>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</p>
<p>sinter <key1><key2>返回两个集合的交集元素。</p>
<p>sunion <key1><key2>返回两个集合的并集元素。</p>
<p>sdiff <key1><key2>返回两个集合的差集元素(key1中的，不包含key2中的)</p>
<h6 id="3-4-3-数据结构"><a href="#3-4-3-数据结构" class="headerlink" title="3.4.3 数据结构"></a>3.4.3 数据结构</h6><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h5 id="3-5-Redis哈希-Hash"><a href="#3-5-Redis哈希-Hash" class="headerlink" title="3.5 Redis哈希(Hash)"></a>3.5 Redis哈希(Hash)</h5><h6 id="3-5-1-简介"><a href="#3-5-1-简介" class="headerlink" title="3.5.1 简介"></a>3.5.1 简介</h6><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<table>
<thead>
<tr>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsiR7jlN.png" class="" title="img"> 每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</th>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps7ahE9x.png" class="" title="img"> 用户ID数据冗余</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsrnOp1m.png" class="" title="img"> 通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题

<h6 id="3-5-2-常用命令"><a href="#3-5-2-常用命令" class="headerlink" title="3.5.2 常用命令"></a>3.5.2 常用命令</h6><blockquote>
<p><strong>hset</strong> <key><field><value>给<key>集合中的  <field>键赋值<value></p>
<p><strong>hget</strong> <key1><field>从<key1>集合<field>取出 value </p>
<p><strong>hmset</strong> <key1><field1><value1><field2><value2>… 批量设置hash的值</p>
<p><strong>hexists</strong><key1><field>查看哈希表 key 中，给定域 field 是否存在。 </p>
<p><strong>hkeys</strong> <key>列出该hash集合的所有field</p>
<p><strong>hvals</strong> <key>列出该hash集合的所有value</p>
<p><strong>hincrby</strong> <key><field><increment>为哈希表 key 中的域 field 的值加上增量 1  -1</p>
<p><strong>hsetnx</strong> <key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p>
</blockquote>
<h6 id="3-5-3-数据结构"><a href="#3-5-3-数据结构" class="headerlink" title="3.5.3 数据结构"></a>3.5.3 数据结构</h6><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h5 id="3-6-Redis有序集合Zset-sorted-set"><a href="#3-6-Redis有序集合Zset-sorted-set" class="headerlink" title="3.6 Redis有序集合Zset(sorted set)"></a>3.6 Redis有序集合Zset(sorted set)</h5><h6 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3.6.1 简介"></a>3.6.1 简介</h6><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h6 id="3-6-2-常用命令"><a href="#3-6-2-常用命令" class="headerlink" title="3.6.2 常用命令"></a>3.6.2 常用命令</h6><blockquote>
<p>zadd  <key><score1><value1><score2><value2>…</p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p>zrange <key><start><stop>  [WITHSCORES]  </p>
<p>返回有序集 key 中，下标在<start><stop>之间的元素</p>
<p>带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key minmax [withscores] [limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key maxmin [withscores] [limit offset count]        </p>
<p>同上，改为从大到小排列。 </p>
<p>zincrby <key><increment><value>    为元素的score加上增量</p>
<p>zrem  <key><value>删除该集合下，指定值的元素 </p>
<p>zcount <key><min><max>统计该集合，分数区间内的元素个数 </p>
<p>zrank <key><value>返回该值在集合中的排名，从0开始。</p>
<p>案例：如何利用zset实现一个文章访问量的排行榜？</p>
</blockquote>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps2DNHKu.png" class="" title="img"> 

<h6 id="3-6-3-数据结构"><a href="#3-6-3-数据结构" class="headerlink" title="3.6.3 数据结构"></a>3.6.3 数据结构</h6><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h6 id="3-6-4-跳跃表（跳表）"><a href="#3-6-4-跳跃表（跳表）" class="headerlink" title="3.6.4 跳跃表（跳表）"></a>3.6.4 跳跃表（跳表）</h6><p>1、简介</p>
<pre><code>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。
</code></pre>
<p>2、实例</p>
<pre><code>对比有序链表和跳跃表，从链表中查询出51
</code></pre>
<p>（1） 有序链表</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsMwAaVC.jpg" class="" title="img"> 

<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2） 跳跃表</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps7rEkBd.jpg" class="" title="img"> 

<p>从第2层开始，1节点比51节点小，向后比较。</p>
<p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>
<h4 id="四、Redis配置文件介绍"><a href="#四、Redis配置文件介绍" class="headerlink" title="四、Redis配置文件介绍"></a>四、Redis配置文件介绍</h4><p>自定义目录：/myredis/redis.conf</p>
<h5 id="4-1-Units单位"><a href="#4-1-Units单位" class="headerlink" title="4.1 Units单位"></a>4.1 Units单位</h5><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit</p>
<p>大小写不敏感</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpskauzTC.png" class="" title="img"> 

<h5 id="4-2-INCLUDES包含"><a href="#4-2-INCLUDES包含" class="headerlink" title="4.2 INCLUDES包含"></a>4.2 INCLUDES包含</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps1A11xr.png" class="" title="img"> 

<p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h5 id="4-3-网络相关配置"><a href="#4-3-网络相关配置" class="headerlink" title="4.3 网络相关配置"></a>4.3 网络相关配置</h5><h6 id="4-3-1-bind"><a href="#4-3-1-bind" class="headerlink" title="4.3.1 bind"></a>4.3.1 bind</h6><p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，无限制接受任何ip地址的访问</p>
<p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p>
<p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsL4G8Lx.png" class="" title="img"> 

<p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsSjGu58.png" class="" title="img"> 

<h6 id="4-3-2-protected-mode"><a href="#4-3-2-protected-mode" class="headerlink" title="4.3.2 protected-mode"></a>4.3.2 protected-mode</h6><p>将本机访问保护模式设置no</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsVgzx6B.png" class="" title="img"> 

<h6 id="4-3-3-Port"><a href="#4-3-3-Port" class="headerlink" title="4.3.3 Port"></a>4.3.3 Port</h6><p>端口号，默认 6379</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsyAAKA9.png" class="" title="img"> 

<h6 id="4-3-4-tcp-backlog"><a href="#4-3-4-tcp-backlog" class="headerlink" title="4.3.4 tcp-backlog"></a>4.3.4 tcp-backlog</h6><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps4N45mL.png" class="" title="img"> 

<h6 id="4-3-5-timeout"><a href="#4-3-5-timeout" class="headerlink" title="4.3.5 timeout"></a>4.3.5 timeout</h6><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps0HFl14.png" class="" title="img"> 

<h6 id="4-3-6-tcp-keepalive"><a href="#4-3-6-tcp-keepalive" class="headerlink" title="4.3.6 tcp-keepalive"></a>4.3.6 tcp-keepalive</h6><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsomc1nX.png" class="" title="img"> 

<h5 id="4-4-GENERAL通用"><a href="#4-4-GENERAL通用" class="headerlink" title="4.4 GENERAL通用"></a>4.4 GENERAL通用</h5><h6 id="4-4-1-daemonize"><a href="#4-4-1-daemonize" class="headerlink" title="4.4.1 daemonize"></a>4.4.1 daemonize</h6><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpszywqZp.png" class="" title="img"> 

<h6 id="4-4-2-pidfile"><a href="#4-4-2-pidfile" class="headerlink" title="4.4.2 pidfile"></a>4.4.2 pidfile</h6><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpszbcKRZ.png" class="" title="img"> 

<h6 id="4-4-3-loglevel"><a href="#4-4-3-loglevel" class="headerlink" title="4.4.3 loglevel"></a>4.4.3 loglevel</h6><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</p>
<p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsvf4219.png" class="" title="img"> 

<h6 id="4-4-4-logfile"><a href="#4-4-4-logfile" class="headerlink" title="4.4.4 logfile"></a>4.4.4 logfile</h6><p>日志文件名称</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpstpgjdo.png" class="" title="img"> 

<h6 id="4-4-5-databases-16"><a href="#4-4-5-databases-16" class="headerlink" title="4.4.5 databases 16"></a>4.4.5 databases 16</h6><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpse24tkp.png" class="" title="img"> 

<h5 id="4-5-SECURITY安全"><a href="#4-5-SECURITY安全" class="headerlink" title="4.5 SECURITY安全"></a>4.5 SECURITY安全</h5><h6 id="4-5-1-设置密码"><a href="#4-5-1-设置密码" class="headerlink" title="4.5.1 设置密码"></a>4.5.1 设置密码</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsfHOK4h.png" class="" title="img"> 

<p>访问密码的查看、设置和取消</p>
<p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p>
<p>永久设置，需要再配置文件中进行设置。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps1feu1f.png" class="" title="img"> 

<h5 id="4-6-LIMITS限制"><a href="#4-6-LIMITS限制" class="headerlink" title="4.6 LIMITS限制"></a>4.6 LIMITS限制</h5><h6 id="4-6-1-maxclients"><a href="#4-6-1-maxclients" class="headerlink" title="4.6.1 maxclients"></a>4.6.1 maxclients</h6><p>Ø 设置redis同时可以与多少个客户端进行连接。</p>
<p>Ø 默认情况下为10000个客户端。</p>
<p>Ø 如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsEl2jUr.png" class="" title="img"> 

<h6 id="4-6-2-maxmemory"><a href="#4-6-2-maxmemory" class="headerlink" title="4.6.2 maxmemory"></a>4.6.2 maxmemory</h6><p>Ø 建议必须设置，否则，将内存占满，造成服务器宕机</p>
<p>Ø 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>Ø 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>Ø 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps0taWyw.png" class="" title="img"> 

<h6 id="4-6-3-maxmemory-policy"><a href="#4-6-3-maxmemory-policy" class="headerlink" title="4.6.3 maxmemory-policy"></a>4.6.3 maxmemory-policy</h6><p>Ø volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</p>
<p>Ø allkeys-lru：在所有集合key中，使用LRU算法移除key</p>
<p>Ø volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</p>
<p>Ø allkeys-random：在所有集合key中，移除随机的key</p>
<p>Ø volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</p>
<p>Ø noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsDEojw6.png" class="" title="img"> 

<h6 id="4-6-4-maxmemory-samples"><a href="#4-6-4-maxmemory-samples" class="headerlink" title="4.6.4 maxmemory-samples"></a>4.6.4 maxmemory-samples</h6><p>Ø 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p>
<p>Ø 一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsi14yIt.png" class="" title="img"> 

<h4 id="五、Redis的发布和订阅"><a href="#五、Redis的发布和订阅" class="headerlink" title="五、Redis的发布和订阅"></a>五、Redis的发布和订阅</h4><h5 id="5-1-什么是发布和订阅"><a href="#5-1-什么是发布和订阅" class="headerlink" title="5.1 什么是发布和订阅"></a>5.1 什么是发布和订阅</h5><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h5 id="5-2-Redis的发布和订阅"><a href="#5-2-Redis的发布和订阅" class="headerlink" title="5.2 Redis的发布和订阅"></a>5.2 Redis的发布和订阅</h5><p>1、客户端可以订阅频道如下图</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpseH2qkE.jpg" class="" title="img"> 

<p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsTzPZ3f.jpg" class="" title="img"> 

<h5 id="5-3-发布订阅命令行实现"><a href="#5-3-发布订阅命令行实现" class="headerlink" title="5.3 发布订阅命令行实现"></a>5.3 发布订阅命令行实现</h5><p>1、 打开一个客户端订阅channel1</p>
<p>SUBSCRIBE channel1</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsasL1s1.jpg" class="" title="img"> 

<p>2、打开另一个客户端，给channel1发布消息hello</p>
<p>publish channel1 hello</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpslLhjCY.jpg" class="" title="img"> 

<p>返回的1是订阅者数量</p>
<p>3、打开第一个客户端可以看到发送的消息</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsqTEudf.jpg" class="" title="img"> 

<p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p>
<h4 id="六、Redis新数据类型"><a href="#六、Redis新数据类型" class="headerlink" title="六、Redis新数据类型"></a>六、Redis新数据类型</h4><h5 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h5><h6 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6.1.1 简介"></a>6.1.1 简介</h6><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsZXmUpQ.jpg" class="" title="img"> 

<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<pre><code>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：
</code></pre>
<p>（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
<p>（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsdi4EnQ.jpg" class="" title="img"> 

<h6 id="6-1-2-命令"><a href="#6-1-2-命令" class="headerlink" title="6.1.2 命令"></a>6.1.2 命令</h6><p>1、setbit</p>
<p>（1）格式</p>
<p>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsuME1NF.jpg" class="" title="img"> 

<p>*offset:偏移量从0开始</p>
<p>（2）实例</p>
<p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p>
<p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsByYnuo.jpg" class="" title="img"> 

<p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpscoD2Vh.jpg" class="" title="img"> 

<p>注：</p>
<p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p>
<p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<p>2、getbit</p>
<p>（1）格式</p>
<p>getbit<key><offset>获取Bitmaps中某个偏移量的值</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsneUclX.jpg" class="" title="img"> 

<p>获取键的第offset位的值（从0开始算）</p>
<p>（2）实例</p>
<p>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsw4n3PU.jpg" class="" title="img"> 

<p>注：因为100根本不存在，所以也是返回0</p>
<p>3、bitcount</p>
<p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p>（1）格式</p>
<p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsvXGvCe.jpg" class="" title="img"> 

<p>（2）实例</p>
<p>计算2022-11-06这天的独立访问用户数量</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps89FZyg.jpg" class="" title="img"> 

<p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsWXoBdu.jpg" class="" title="img"> 

<p>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】</p>
<p>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000</p>
<p>–》bitcount K1 1 2 　　–》1</p>
<p>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001</p>
<p>–》bitcount K1 1 3　　–》3</p>
<p>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000  00000000</p>
<p>–》bitcount K1 0 -2　　–》3</p>
<p> 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p>
<p>4、bitop</p>
<p>(1)格式</p>
<p>bitop and(or/not/xor) <destkey> [key…]</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps6Owby0.jpg" class="" title="img"> 

<p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p>
<p>(2)实例</p>
<p>2020-11-04 日访问网站的userid=1,2,5,9。</p>
<p>setbit unique:users:20201104 1 1</p>
<p>setbit unique:users:20201104 2 1</p>
<p>setbit unique:users:20201104 5 1</p>
<p>setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9。</p>
<p>setbit unique:users:20201103 0 1</p>
<p>setbit unique:users:20201103 1 1</p>
<p>setbit unique:users:20201103 4 1</p>
<p>setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量</p>
<p>bitop and unique:users:and:20201104_03</p>
<p> unique:users:20201103unique:users:20201104</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsefMJAU.jpg" class="" title="img"> 

<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsz2jrji.jpg" class="" title="img"> 

<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsw3pgAP.jpg" class="" title="img"> 

<h6 id="6-1-3-Bitmaps与set对比"><a href="#6-1-3-Bitmaps与set对比" class="headerlink" title="6.1.3 Bitmaps与set对比"></a>6.1.3 Bitmaps与set对比</h6><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户id占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 = 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合类型</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个userid占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 = 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<h5 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h5><h6 id="6-2-1-简介"><a href="#6-2-1-简介" class="headerlink" title="6.2.1 简介"></a>6.2.1 简介</h6><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h6 id="6-2-2-命令"><a href="#6-2-2-命令" class="headerlink" title="6.2.2 命令"></a>6.2.2 命令</h6><p>1、pfadd </p>
<p>（1）格式</p>
<p>pfadd <key>&lt; element&gt; [element …]  添加指定元素到 HyperLogLog 中</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsyBtJVv.jpg" class="" title="img"> 

<p>（2）实例</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsIvFA0m.jpg" class="" title="img"> 

<pre><code>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。
</code></pre>
<p>2、pfcount</p>
<p>（1）格式</p>
<p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsZmcy1b.jpg" class="" title="img"> 

<p>（2）实例</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpskhJXL9.jpg" class="" title="img"> 

<p>3、pfmerge</p>
<p>（1）格式</p>
<p>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsR1ThFm.jpg" class="" title="img"> 

<p>（2）实例</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsMYyOee.jpg" class="" title="img"> 

<h5 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6.3 Geospatial"></a>6.3 Geospatial</h5><h6 id="6-3-1-简介"><a href="#6-3-1-简介" class="headerlink" title="6.3.1 简介"></a>6.3.1 简介</h6><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h6 id="6-3-2-命令"><a href="#6-3-2-命令" class="headerlink" title="6.3.2 命令"></a>6.3.2 命令</h6><p>1、geoadd</p>
<p>（1）格式</p>
<p>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]  添加地理位置（经度，纬度，名称）</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsMxAmPE.jpg" class="" title="img"> 

<p>（2）实例</p>
<p>geoadd china:city 121.47 31.23 shanghai</p>
<p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsqJNuHc.jpg" class="" title="img"> 

<p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p>
<p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p>
<p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p>
<p>已经添加的数据，是无法再次往里面添加的。</p>
<p>2、geopos  </p>
<p>（1）格式</p>
<p>geopos  <key><member> [member…]  获得指定地区的坐标值</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsJGSoaK.jpg" class="" title="img"> 

<p>（2）实例</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpspgtNar.jpg" class="" title="img"> 

<p>3、geodist</p>
<p>（1）格式</p>
<p>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps6LOrq5.jpg" class="" title="img"> 

<p>（2）实例</p>
<p>获取两个位置之间的直线距离</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps8pn15k.jpg" class="" title="img"> 

<p>单位：</p>
<p>m 表示单位为米[默认值]。</p>
<p>km 表示单位为千米。</p>
<p>mi 表示单位为英里。</p>
<p>ft 表示单位为英尺。</p>
<p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p>
<p>4、georadius</p>
<p>（1）格式</p>
<p>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsTYfBml.jpg" class="" title="img"> 

<p>经度 纬度 距离 单位</p>
<p>（2）实例</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsYPkw7s.jpg" class="" title="img"> 



<h4 id="七、Redis-Jedis-测试"><a href="#七、Redis-Jedis-测试" class="headerlink" title="七、Redis_Jedis_测试"></a>七、Redis_Jedis_测试</h4><h5 id="7-1-Jedis所需要的jar包"><a href="#7-1-Jedis所需要的jar包" class="headerlink" title="7.1 Jedis所需要的jar包"></a>7.1 Jedis所需要的jar包</h5><blockquote>
<dependency> 

<pre><code>&lt;groupId&gt;redis.clients&lt;/groupId&gt; 
        
&lt;artifactId&gt;jedis&lt;/artifactId&gt; 
        
&lt;version&gt;3.2.0&lt;/version&gt; 
</code></pre>
</dependency>
</blockquote>
<h5 id="7-2-连接Redis注意事项"><a href="#7-2-连接Redis注意事项" class="headerlink" title="7.2 连接Redis注意事项"></a>7.2 连接Redis注意事项</h5><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令</p>
<p>systemctl stop/disable firewalld.service  </p>
<p>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p>
<h5 id="7-3-Jedis常用操作"><a href="#7-3-Jedis常用操作" class="headerlink" title="7.3 Jedis常用操作"></a>7.3 Jedis常用操作</h5><h6 id="7-3-1-创建动态的工程"><a href="#7-3-1-创建动态的工程" class="headerlink" title="7.3.1 创建动态的工程"></a>7.3.1 创建动态的工程</h6><h6 id="7-3-2-创建测试程序"><a href="#7-3-2-创建测试程序" class="headerlink" title="7.3.2 创建测试程序"></a>7.3.2 创建测试程序</h6><blockquote>
<p>package com.atguigu.jedis;</p>
<p>import redis.clients.jedis.Jedis;</p>
<p>public class Demo01 {public static void main(String[] args) {</p>
<pre><code>Jedis jedis = new Jedis(&quot;192.168.137.3&quot;,6379);
        
String pong = jedis.ping();
        
System.out.println(&quot;连接成功：&quot;+pong);
        
jedis.close();
        
&#125;
</code></pre>
<p>}</p>
</blockquote>
<h5 id="7-4-测试相关数据类型"><a href="#7-4-测试相关数据类型" class="headerlink" title="7.4 测试相关数据类型"></a>7.4 测试相关数据类型</h5><h6 id="7-4-1-Jedis-API-Key"><a href="#7-4-1-Jedis-API-Key" class="headerlink" title="7.4.1 Jedis-API:   Key"></a>7.4.1 Jedis-API:   Key</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">	System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));         </span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="7-4-2-Jedis-API-String"><a href="#7-4-2-Jedis-API-String" class="headerlink" title="7.4.2 Jedis-API:   String"></a>7.4.2 Jedis-API:   String</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="7-4-3-Jedis-API-List"><a href="#7-4-3-Jedis-API-List" class="headerlink" title="7.4.3 Jedis-API:   List"></a>7.4.3 Jedis-API:   List</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-4-4-Jedis-API-set"><a href="#7-4-4-Jedis-API-set" class="headerlink" title="7.4.4 Jedis-API:   set"></a>7.4.4 Jedis-API:   set</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="7-4-5-Jedis-API-hash"><a href="#7-4-5-Jedis-API-hash" class="headerlink" title="7.4.5 Jedis-API:   hash"></a>7.4.5 Jedis-API:   hash</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-4-6-Jedis-API-zset"><a href="#7-4-6-Jedis-API-zset" class="headerlink" title="7.4.6 Jedis-API:   zset"></a>7.4.6 Jedis-API:   zset</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line"> </span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、Redis-Jedis-实例"><a href="#八、Redis-Jedis-实例" class="headerlink" title="八、Redis_Jedis_实例"></a>八、Redis_Jedis_实例</h4><h5 id="8-1-完成一个手机验证码功能"><a href="#8-1-完成一个手机验证码功能" class="headerlink" title="8.1 完成一个手机验证码功能"></a>8.1 完成一个手机验证码功能</h5><p>要求：</p>
<p>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效</p>
<p>2、输入验证码，点击验证，返回成功或失败</p>
<p>3、每个手机号每天只能输入3次</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsSFXU9l.png" class="" title="img"> 

<h4 id="九、Redis与Spring-Boot整合"><a href="#九、Redis与Spring-Boot整合" class="headerlink" title="九、Redis与Spring Boot整合"></a>九、Redis与Spring Boot整合</h4><p>Spring Boot整合Redis非常简单，只需要按如下步骤整合即可</p>
<h5 id="9-1-整合步骤"><a href="#9-1-整合步骤" class="headerlink" title="9.1 整合步骤"></a>9.1 整合步骤</h5><p>1、 在pom.xml文件中引入redis相关依赖</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、 application.properties配置redis配置</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 </span></span><br></pre></td></tr></table></figure>

<p>3、 添加redis配置类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>4、测试一下</p>
<p>RedisTestController中添加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="十、Redis-事务-锁机制-秒杀"><a href="#十、Redis-事务-锁机制-秒杀" class="headerlink" title="十、Redis_事务_锁机制_秒杀"></a>十、Redis_事务_锁机制_秒杀</h4><h5 id="10-1-Redis的事务定义"><a href="#10-1-Redis的事务定义" class="headerlink" title="10.1 Redis的事务定义"></a>10.1 Redis的事务定义</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsiVuy1s.png" class="" title="img"> 

<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h5 id="10-2-Multi、Exec、discard"><a href="#10-2-Multi、Exec、discard" class="headerlink" title="10.2 Multi、Exec、discard"></a>10.2 Multi、Exec、discard</h5><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过discard来放弃组队。  </p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsSWbwiK.jpg" class="" title="img"> 

<p>案例：</p>
<table>
<thead>
<tr>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsVKLohQ.png" class="" title="img"> 组队成功，提交成功</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps7f8BVN.png" class="" title="img"> 组队阶段报错，提交失败</td>
</tr>
<tr>
<td><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsvFRZqh.png" class="" title="img"> 组队成功，提交有成功有失败情况</td>
</tr>
</tbody></table>
<h5 id="10-3-事务的错误处理"><a href="#10-3-事务的错误处理" class="headerlink" title="10.3 事务的错误处理"></a>10.3 事务的错误处理</h5><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsfn9pfZ.png" class="" title="img"> 

<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsXR5GDM.png" class="" title="img"> 

<h5 id="10-4-为什么要做成事务"><a href="#10-4-为什么要做成事务" class="headerlink" title="10.4 为什么要做成事务"></a>10.4 为什么要做成事务</h5><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p>
<h5 id="10-5-事务冲突的问题"><a href="#10-5-事务冲突的问题" class="headerlink" title="10.5 事务冲突的问题"></a>10.5 事务冲突的问题</h5><h6 id="10-5-1-例子"><a href="#10-5-1-例子" class="headerlink" title="10.5.1 例子"></a>10.5.1 例子</h6><p>一个请求想给金额减8000</p>
<p>一个请求想给金额减5000</p>
<p>一个请求想给金额减1000</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsc2P7SS.png" class="" title="img"> 

<h6 id="10-5-2-悲观锁"><a href="#10-5-2-悲观锁" class="headerlink" title="10.5.2 悲观锁"></a>10.5.2 悲观锁</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsNHfbc7.png" class="" title="img"> 

<p><strong>悲观锁(Pessimistic Lock)：</strong>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h6 id="10-5-3-乐观锁"><a href="#10-5-3-乐观锁" class="headerlink" title="10.5.3 乐观锁"></a>10.5.3 乐观锁</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpszm1Tei.png" class="" title="img"> 

<p><strong>乐观锁(Optimistic Lock)：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</p>
<h6 id="10-5-4-WATCH-key-key-…"><a href="#10-5-4-WATCH-key-key-…" class="headerlink" title="10.5.4 WATCH key [key …]"></a>10.5.4 WATCH key [key …]</h6><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsfxr1Ku.png" class="" title="img"> 

<h6 id="10-5-6-unwatch"><a href="#10-5-6-unwatch" class="headerlink" title="10.5.6 unwatch"></a>10.5.6 unwatch</h6><p>取消 WATCH 命令对所有 key 的监视。</p>
<p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<p><a href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p>
<h5 id="10-6-Redis事务三特性"><a href="#10-6-Redis事务三特性" class="headerlink" title="10.6 Redis事务三特性"></a>10.6 Redis事务三特性</h5><p>Ø 单独的隔离操作 </p>
<p>n 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
<p>Ø 没有隔离级别的概念 </p>
<p>n 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
<p>Ø 不保证原子性 </p>
<p>n 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p>
<h4 id="十一、Redis-事务-秒杀案例"><a href="#十一、Redis-事务-秒杀案例" class="headerlink" title="十一、Redis_事务_秒杀案例"></a>十一、Redis_事务_秒杀案例</h4><h5 id="11-1-解决计数器和人员记录的事务操作"><a href="#11-1-解决计数器和人员记录的事务操作" class="headerlink" title="11.1 解决计数器和人员记录的事务操作"></a>11.1 解决计数器和人员记录的事务操作</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsF6l7b4.png" class="" title="img"> 

<h5 id="11-2-Redis事务–秒杀并发模拟"><a href="#11-2-Redis事务–秒杀并发模拟" class="headerlink" title="11.2 Redis事务–秒杀并发模拟"></a>11.2 Redis事务–秒杀并发模拟</h5><p>使用工具ab模拟测试</p>
<p>CentOS6 默认安装</p>
<p>CentOS7需要手动安装</p>
<h6 id="11-2-1-联网：yum-install-httpd-tools"><a href="#11-2-1-联网：yum-install-httpd-tools" class="headerlink" title="11.2.1 联网：yum install httpd-tools"></a>11.2.1 联网：yum install httpd-tools</h6><h6 id="11-2-2-无网络"><a href="#11-2-2-无网络" class="headerlink" title="11.2.2 无网络"></a>11.2.2 无网络</h6><p>（1） 进入cd  /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同）</p>
<p>（2） 顺序安装</p>
<p>apr-1.4.8-3.el7.x86_64.rpm</p>
<p>apr-util-1.5.2-6.el7.x86_64.rpm</p>
<p>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm  </p>
<h6 id="11-2-3-测试及结果"><a href="#11-2-3-测试及结果" class="headerlink" title="11.2.3 测试及结果"></a>11.2.3 测试及结果</h6><ul>
<li>通过ab测试</li>
</ul>
<p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。</p>
<p>内容：prodid=0101&amp;</p>
<p>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p>
<ul>
<li>超卖</li>
</ul>
<table>
<thead>
<tr>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsYqJIJA.png" class="" title="img"></th>
<th><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsdgdniw.png" class="" title="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="11-3-超卖问题"><a href="#11-3-超卖问题" class="headerlink" title="11.3 超卖问题"></a>11.3 超卖问题</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsQ8oe0s.png" class="" title="img"> 

<h5 id="11-4-利用乐观锁淘汰用户，解决超卖问题。"><a href="#11-4-利用乐观锁淘汰用户，解决超卖问题。" class="headerlink" title="11.4 利用乐观锁淘汰用户，解决超卖问题。"></a>11.4 利用乐观锁淘汰用户，解决超卖问题。</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpskot0t5.png" class="" title="img"> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加乐观锁</span></span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.判断库存</span></span><br><span class="line">String qtkeystr = jedis.get(qtkey);</span><br><span class="line"><span class="keyword">if</span>(qtkeystr==<span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未初始化库存&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> qt = Integer.parseInt(qtkeystr);</span><br><span class="line"><span class="keyword">if</span>(qt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已经秒光&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.减少库存</span></span><br><span class="line"><span class="comment">//jedis.decr(qtkey);</span></span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5.加人</span></span><br><span class="line"><span class="comment">//jedis.sadd(usrkey, uid);</span></span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行事务</span></span><br><span class="line">List&lt;Object&gt; list = multi.exec();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断事务提交是否失败</span></span><br><span class="line"><span class="keyword">if</span>(list==<span class="keyword">null</span> || list.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/image-20211106212045210.png" class="" title="image-20211106212045210">



<img src="redis相关知识/image-20211106212111139.png" alt="image-20211106212111139" style="zoom:15%;" />



<h5 id="11-5-继续增加并发测试"><a href="#11-5-继续增加并发测试" class="headerlink" title="11.5 继续增加并发测试"></a>11.5 继续增加并发测试</h5><h6 id="11-5-1-连接有限制"><a href="#11-5-1-连接有限制" class="headerlink" title="11.5.1 连接有限制"></a>11.5.1 连接有限制</h6><p>ab -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsCPJ9L3.png" class="" title="img"> 

<p>增加-r参数，-r  Don’t exit on socket receive errors.</p>
<p>ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p>
<h6 id="11-5-2-已经秒光，可是还有库存"><a href="#11-5-2-已经秒光，可是还有库存" class="headerlink" title="11.5.2 已经秒光，可是还有库存"></a>11.5.2 已经秒光，可是还有库存</h6><p>ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a></p>
<p>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsE9sw56.png" class="" title="img"> 

<h6 id="11-5-3-连接超时，通过连接池解决"><a href="#11-5-3-连接超时，通过连接池解决" class="headerlink" title="11.5.3 连接超时，通过连接池解决"></a>11.5.3 连接超时，通过连接池解决</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsvwqg8S.png" class="" title="img"> 

<h6 id="11-5-4-连接池"><a href="#11-5-4-连接池" class="headerlink" title="11.5.4 连接池"></a>11.5.4 连接池</h6><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p>
<p>通过参数管理连接的行为</p>
<p>代码见项目中</p>
<ul>
<li><p>链接池参数</p>
<ol>
<li><p>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p>
</li>
<li><p>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p>
</li>
<li><p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</p>
</li>
<li><p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</p>
</li>
</ol>
</li>
</ul>
<h5 id="11-6-解决库存遗留问题"><a href="#11-6-解决库存遗留问题" class="headerlink" title="11.6 解决库存遗留问题"></a>11.6 解决库存遗留问题</h5><h6 id="11-6-1-LUA脚本"><a href="#11-6-1-LUA脚本" class="headerlink" title="11.6.1 LUA脚本"></a>11.6.1 LUA脚本</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsI1k8hg.png" class="" title="img"> 

<p>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</p>
<p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p>
<p>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p>
<p><a href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p>
<h6 id="11-6-2-LUA脚本在Redis中的优势"><a href="#11-6-2-LUA脚本在Redis中的优势" class="headerlink" title="11.6.2 LUA脚本在Redis中的优势"></a>11.6.2 LUA脚本在Redis中的优势</h6><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p>
<p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p>
<p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p>
<p>利用lua脚本淘汰用户，解决超卖问题。</p>
<p>redis 2.6版本以后，通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsUcaXHN.png" class="" title="img"> 

<h5 id="11-7-Redis-事务-秒杀案例-代码"><a href="#11-7-Redis-事务-秒杀案例-代码" class="headerlink" title="11.7 Redis_事务_秒杀案例_代码"></a>11.7 Redis_事务_秒杀案例_代码</h5><h6 id="11-7-1-项目结构"><a href="#11-7-1-项目结构" class="headerlink" title="11.7.1 项目结构"></a>11.7.1 项目结构</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpskjxSZ8.jpg" class="" title="img"> 

<h6 id="11-7-2-第一版：简单版"><a href="#11-7-2-第一版：简单版" class="headerlink" title="11.7.2 第一版：简单版"></a>11.7.2 第一版：简单版</h6><p>老师点10次，正常秒杀</p>
<p>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。</p>
<p>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p>
<h6 id="11-7-3-第二版：加事务-乐观锁-解决超卖-但出现遗留库存和连接超时"><a href="#11-7-3-第二版：加事务-乐观锁-解决超卖-但出现遗留库存和连接超时" class="headerlink" title="11.7.3 第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时"></a>11.7.3 第二版：加事务-乐观锁(解决超卖),但出现遗留库存和连接超时</h6><h6 id="11-7-4-第三版：连接池解决超时问题"><a href="#11-7-4-第三版：连接池解决超时问题" class="headerlink" title="11.7.4 第三版：连接池解决超时问题"></a>11.7.4 第三版：连接池解决超时问题</h6><h6 id="11-7-5-第四版：解决库存依赖问题，LUA脚本"><a href="#11-7-5-第四版：解决库存依赖问题，LUA脚本" class="headerlink" title="11.7.5 第四版：解决库存依赖问题，LUA脚本"></a>11.7.5 第四版：解决库存依赖问题，LUA脚本</h6><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure>



<h4 id="十二、Redis持久化之RDB"><a href="#十二、Redis持久化之RDB" class="headerlink" title="十二、Redis持久化之RDB"></a>十二、Redis持久化之RDB</h4><h5 id="12-1-总体介绍"><a href="#12-1-总体介绍" class="headerlink" title="12.1 总体介绍"></a>12.1 总体介绍</h5><p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a></p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsM9NzJ9.png" class="" title="img"> 

<p>Redis 提供了2个不同形式的持久化方式。</p>
<ul>
<li><p>RDB（Redis DataBase）</p>
</li>
<li><p>AOF（Append Of File）</p>
</li>
</ul>
<h5 id="12-2-RDB（Redis-DataBase）"><a href="#12-2-RDB（Redis-DataBase）" class="headerlink" title="12.2 RDB（Redis DataBase）"></a>12.2 RDB（Redis DataBase）</h5><h6 id="12-2-1-官网介绍"><a href="#12-2-1-官网介绍" class="headerlink" title="12.2.1 官网介绍"></a>12.2.1 官网介绍</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsaIXXxk.png" class="" title="img"> 

<h6 id="12-2-2-是什么"><a href="#12-2-2-是什么" class="headerlink" title="12.2.2 是什么"></a>12.2.2 是什么</h6><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p>
<h6 id="12-2-3-备份是如何执行的"><a href="#12-2-3-备份是如何执行的" class="headerlink" title="12.2.3 备份是如何执行的"></a>12.2.3 备份是如何执行的</h6><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<h6 id="12-2-4-Fork"><a href="#12-2-4-Fork" class="headerlink" title="12.2.4 Fork"></a>12.2.4 Fork</h6><ul>
<li><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</li>
<li><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”</p>
</li>
<li><p>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p>
</li>
</ul>
<h6 id="12-2-5-RDB持久化流程"><a href="#12-2-5-RDB持久化流程" class="headerlink" title="12.2.5 RDB持久化流程"></a>12.2.5 RDB持久化流程</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsJjacp1.jpg" class="" title="img"> 

<h6 id="12-2-6-dump-rdb文件"><a href="#12-2-6-dump-rdb文件" class="headerlink" title="12.2.6 dump.rdb文件"></a>12.2.6 dump.rdb文件</h6><p>在redis.conf中配置文件名称，默认为dump.rdb</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsRVvGMU.jpg" class="" title="img"> 

<h6 id="12-2-7-配置位置"><a href="#12-2-7-配置位置" class="headerlink" title="12.2.7 配置位置"></a>12.2.7 配置位置</h6><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p>
<p>dir “/myredis/“</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpstHPBD6.jpg" class="" title="img"> 

<h6 id="12-2-8-如何触发RDB快照；保持策略"><a href="#12-2-8-如何触发RDB快照；保持策略" class="headerlink" title="12.2.8 如何触发RDB快照；保持策略"></a>12.2.8 如何触发RDB快照；保持策略</h6><ul>
<li>配置文件中默认的快照配置</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsstk9l0.jpg" class="" title="img"> 

<ul>
<li><p>命令save VS bgsave</p>
<p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p>
<p>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p>
</li>
<li><p>flushall命令</p>
<p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
</li>
<li><p>SNAPSHOTTING快照</p>
</li>
<li><p>Save</p>
<p>格式：save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p>
<p>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p>
<p>禁用</p>
<p>不设置save指令，或者给save传入空字符串</p>
</li>
<li><p>stop-writes-on-bgsave-error</p>
</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsEWXNVg.jpg" class="" title="img"> 

<pre><code>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.
</code></pre>
<ul>
<li>rdbcompression 压缩文件</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsoZEIFD.jpg" class="" title="img"> 

<pre><code>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。
</code></pre>
<p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<ul>
<li>rdbchecksum 检查完整性</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsmHDA4E.jpg" class="" title="img"> 

<p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p>
<p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p>
<p>推荐yes.</p>
<ul>
<li><p>rdb的备份</p>
<p>先通过config get dir  查询rdb文件的目录 </p>
<p>将*.rdb的文件拷贝到别的地方</p>
<p>rdb的恢复</p>
<p>关闭Redis</p>
<p>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</p>
<p>启动Redis, 备份数据会直接加载</p>
</li>
</ul>
<h6 id="12-2-9-优势"><a href="#12-2-9-优势" class="headerlink" title="12.2.9 优势"></a>12.2.9 优势</h6><ul>
<li><p>适合大规模的数据恢复</p>
</li>
<li><p>对数据完整性和一致性要求不高更适合使用</p>
</li>
<li><p>节省磁盘空间</p>
</li>
<li><p>恢复速度快</p>
</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsX3DV2t.png" class="" title="img"> 

<h6 id="12-2-10-劣势"><a href="#12-2-10-劣势" class="headerlink" title="12.2.10 劣势"></a>12.2.10 劣势</h6><p>l Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p>
<p>l 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</p>
<p>l 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
<h6 id="12-2-11-如何停止"><a href="#12-2-11-如何停止" class="headerlink" title="12.2.11 如何停止"></a>12.2.11 如何停止</h6><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p>
<h6 id="12-2-12-小总结"><a href="#12-2-12-小总结" class="headerlink" title="12.2.12 小总结"></a>12.2.12 小总结</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps1ZcZDR.png" class="" title="img"> 

<h4 id="十三、Redis持久化之AOF"><a href="#十三、Redis持久化之AOF" class="headerlink" title="十三、Redis持久化之AOF"></a>十三、Redis持久化之AOF</h4><h5 id="13-1-AOF（Append-Only-File）"><a href="#13-1-AOF（Append-Only-File）" class="headerlink" title="13.1 AOF（Append Only File）"></a>13.1 AOF（Append Only File）</h5><h6 id="13-1-1-是什么"><a href="#13-1-1-是什么" class="headerlink" title="13.1.1 是什么"></a>13.1.1 是什么</h6><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h6 id="13-1-2-AOF持久化流程"><a href="#13-1-2-AOF持久化流程" class="headerlink" title="13.1.2 AOF持久化流程"></a>13.1.2 AOF持久化流程</h6><p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；</p>
<p>（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</p>
<p>（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</p>
<p>（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsoYNTS0.jpg" class="" title="img"> 

<h6 id="13-1-3-AOF默认不开启"><a href="#13-1-3-AOF默认不开启" class="headerlink" title="13.1.3 AOF默认不开启"></a>13.1.3 AOF默认不开启</h6><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof</p>
<p>AOF文件的保存路径，同RDB的路径一致。</p>
<h6 id="13-1-4-AOF和RDB同时开启，redis听谁的？"><a href="#13-1-4-AOF和RDB同时开启，redis听谁的？" class="headerlink" title="13.1.4 AOF和RDB同时开启，redis听谁的？"></a>13.1.4 AOF和RDB同时开启，redis听谁的？</h6><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p>
<h6 id="13-1-5-AOF启动-修复-恢复"><a href="#13-1-5-AOF启动-修复-恢复" class="headerlink" title="13.1.5 AOF启动/修复/恢复"></a>13.1.5 AOF启动/修复/恢复</h6><ul>
<li><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
</li>
<li><p>正常恢复</p>
<ol>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ol>
</li>
<li><p>异常恢复</p>
<ol>
<li>修改默认的appendonly no，改为yes</li>
<li>如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>恢复：重启redis，然后重新加载</li>
</ol>
</li>
</ul>
<h6 id="13-1-6-AOF同步频率设置"><a href="#13-1-6-AOF同步频率设置" class="headerlink" title="13.1.6 AOF同步频率设置"></a>13.1.6 AOF同步频率设置</h6><p>appendfsync always</p>
<p>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p>
<p>appendfsync everysec</p>
<p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
<p>appendfsync no</p>
<p>redis不主动进行同步，把同步时机交给操作系统。</p>
<h6 id="13-1-7-Rewrite压缩"><a href="#13-1-7-Rewrite压缩" class="headerlink" title="13.1.7 Rewrite压缩"></a>13.1.7 Rewrite压缩</h6><ol>
<li>是什么：</li>
</ol>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<ol start="2">
<li>重写原理，如何实现重写</li>
</ol>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p>
<p>no-appendfsync-on-rewrite：</p>
<p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p>
<pre><code>如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）
</code></pre>
<p>触发机制，何时重写</p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </p>
<p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p>
<p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p>
<p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p>
<p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p>
<p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 </p>
<p>3、重写流程</p>
<p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p>
<p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p>
<p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p>
<p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p>
<p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsIP0A2d.jpg" class="" title="img"> 

<h6 id="13-1-8-优势"><a href="#13-1-8-优势" class="headerlink" title="13.1.8 优势"></a>13.1.8 优势</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps2AR7wB.png" class="" title="img"> 

<ul>
<li><p>备份机制更稳健，丢失数据概率更低。</p>
</li>
<li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>
</li>
</ul>
<h6 id="13-1-9-劣势"><a href="#13-1-9-劣势" class="headerlink" title="13.1.9 劣势"></a>13.1.9 劣势</h6><ul>
<li><p>比起RDB占用更多的磁盘空间。</p>
</li>
<li><p>恢复备份速度要慢。</p>
</li>
<li><p>每次读写都同步的话，有一定的性能压力。</p>
</li>
<li><p>存在个别Bug，造成恢复不能。</p>
</li>
</ul>
<h6 id="13-1-10-小总结"><a href="#13-1-10-小总结" class="headerlink" title="13.1.10 小总结"></a>13.1.10 小总结</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsaEfREu.png" class="" title="img"> 

<h5 id="13-2-总结-Which-one"><a href="#13-2-总结-Which-one" class="headerlink" title="13.2 总结(Which one)"></a>13.2 总结(Which one)</h5><h6 id="13-2-1-用哪个好"><a href="#13-2-1-用哪个好" class="headerlink" title="13.2.1 用哪个好"></a>13.2.1 用哪个好</h6><p>官方推荐两个都启用。</p>
<p>如果对数据不敏感，可以选单独用RDB。</p>
<p>不建议单独用 AOF，因为可能会出现Bug。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
<h6 id="13-2-2-官网建议"><a href="#13-2-2-官网建议" class="headerlink" title="13.2.2 官网建议"></a>13.2.2 官网建议</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsgqLf0O.png" class="" title="img"> 

<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </li>
<li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>同时开启两种持久化方式</li>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </li>
<li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
<li>性能建议</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save</span> <span class="string">900 1这条规则。</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</span></span><br><span class="line"><span class="meta">代价,一是带来了持续的IO，二是AOF</span> <span class="string">rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</span></span><br><span class="line"><span class="meta">只要硬盘许可，应该尽量减少AOF</span> <span class="string">rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</span></span><br><span class="line"><span class="attr">默认超过原大小100%大小时重写可以改到适当的数值。</span></span><br></pre></td></tr></table></figure>



<h4 id="十四、Redis-主从复制"><a href="#十四、Redis-主从复制" class="headerlink" title="十四、Redis_主从复制"></a>十四、Redis_主从复制</h4><h5 id="14-1-是什么"><a href="#14-1-是什么" class="headerlink" title="14.1 是什么"></a>14.1 是什么</h5><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<h5 id="14-2-能干嘛"><a href="#14-2-能干嘛" class="headerlink" title="14.2 能干嘛"></a>14.2 能干嘛</h5><ul>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpssiKt5I.png" class="" title="img"> 

<h5 id="14-3-怎么玩：主从复制"><a href="#14-3-怎么玩：主从复制" class="headerlink" title="14.3 怎么玩：主从复制"></a>14.3 怎么玩：主从复制</h5><p>拷贝多个redis.conf文件include(写绝对路径)</p>
<p>开启daemonize yes</p>
<p>Pid文件名字pidfile</p>
<p>指定端口port</p>
<p>Log文件名字</p>
<p>dump.rdb名字dbfilename</p>
<p>Appendonly 关掉或者换名字</p>
<h6 id="14-3-1-新建redis6379-conf，填写以下内容"><a href="#14-3-1-新建redis6379-conf，填写以下内容" class="headerlink" title="14.3.1 新建redis6379.conf，填写以下内容"></a>14.3.1 新建redis6379.conf，填写以下内容</h6><p>include /myredis/redis.conf</p>
<p>pidfile /var/run/redis_6379.pid</p>
<p>port 6379</p>
<p>dbfilename dump6379.rdb</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps6NT9j1.png" class="" title="img"> 

<h6 id="14-3-2-新建redis6380-conf，填写以下内容"><a href="#14-3-2-新建redis6380-conf，填写以下内容" class="headerlink" title="14.3.2 新建redis6380.conf，填写以下内容"></a>14.3.2 新建redis6380.conf，填写以下内容</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpscRiwkq.png" class="" title="img"> 

<h6 id="14-3-3-新建redis6381-conf，填写以下内容"><a href="#14-3-3-新建redis6381-conf，填写以下内容" class="headerlink" title="14.3.3 新建redis6381.conf，填写以下内容"></a>14.3.3 新建redis6381.conf，填写以下内容</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsNa2CSj.png" class="" title="img"> 

<p><strong>slave-priority 10</strong></p>
<p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p>
<h6 id="14-3-4-启动三台redis服务器"><a href="#14-3-4-启动三台redis服务器" class="headerlink" title="14.3.4 启动三台redis服务器"></a>14.3.4 启动三台redis服务器</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsVQEbPi.png" class="" title="img"> 

<h6 id="14-3-5-查看系统进程，看看三台服务器是否启动"><a href="#14-3-5-查看系统进程，看看三台服务器是否启动" class="headerlink" title="14.3.5 查看系统进程，看看三台服务器是否启动"></a>14.3.5 查看系统进程，看看三台服务器是否启动</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsYvvWfS.png" class="" title="img"> 

<h6 id="14-3-6-查看三台主机运行情况"><a href="#14-3-6-查看三台主机运行情况" class="headerlink" title="14.3.6 查看三台主机运行情况"></a>14.3.6 查看三台主机运行情况</h6><p>info replication</p>
<p>打印主从复制的相关信息</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsUBbGKU.png" class="" title="img"> 

<h6 id="14-3-7-配从-库-不配主-库"><a href="#14-3-7-配从-库-不配主-库" class="headerlink" title="14.3.7 配从(库)不配主(库)"></a>14.3.7 配从(库)不配主(库)</h6><p>slaveof  <ip><port></p>
<p>成为某个实例的从服务器</p>
<p>1、在6380和6381上执行: slaveof 127.0.0.1 6379</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpshNC7A7.png" class="" title="img"> 

<p>2、在主机上写，在从机上可以读取数据</p>
<p>在从机上写数据报错</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsDGvqdA.png" class="" title="img"> 

<p>3、主机挂掉，重启就行，一切如初</p>
<p>4、从机重启需重设：slaveof 127.0.0.1 6379</p>
<p>可以将配置增加到文件中。永久生效。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpswd4AF5.png" class="" title="img"> 

<h5 id="14-4-常用3招"><a href="#14-4-常用3招" class="headerlink" title="14.4 常用3招"></a>14.4 常用3招</h5><h6 id="14-4-1-一主二仆"><a href="#14-4-1-一主二仆" class="headerlink" title="14.4.1 一主二仆"></a>14.4.1 一主二仆</h6><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p>
<p>从机是否可以写？set可否？ </p>
<p>主机shutdown后情况如何？从机是上位还是原地待命？</p>
<p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p>
<p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps8yITwF.png" class="" title="img"> 

<h6 id="14-4-2-薪火相传"><a href="#14-4-2-薪火相传" class="headerlink" title="14.4.2 薪火相传"></a>14.4.2 薪火相传</h6><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p>
<p>用 slaveof  <ip><port></p>
<p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p>
<p>风险是一旦某个slave宕机，后面的slave都没法备份</p>
<p>主机挂了，从机还是从机，无法写数据了</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsmrFpmJ.png" class="" title="img"> 

<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps3To71P.png" class="" title="img"> 

<h6 id="14-4-3-反客为主"><a href="#14-4-3-反客为主" class="headerlink" title="14.4.3 反客为主"></a>14.4.3 反客为主</h6><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p>
<p>用 slaveof  no one  将从机变为主机。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsjFmEkL.png" class="" title="img"> 

<h5 id="14-5-复制原理"><a href="#14-5-复制原理" class="headerlink" title="14.5 复制原理"></a>14.5 复制原理</h5><ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsu0ReF8.png" class="" title="img"> 

<h5 id="14-6-哨兵模式-sentinel"><a href="#14-6-哨兵模式-sentinel" class="headerlink" title="14.6 哨兵模式(sentinel)"></a>14.6 哨兵模式(sentinel)</h5><h6 id="14-6-1-是什么"><a href="#14-6-1-是什么" class="headerlink" title="14.6.1 是什么"></a>14.6.1 是什么</h6><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsWKkVzp.png" class="" title="img"> 

<h6 id="14-6-2-怎么玩-使用步骤"><a href="#14-6-2-怎么玩-使用步骤" class="headerlink" title="14.6.2 怎么玩(使用步骤)"></a>14.6.2 怎么玩(使用步骤)</h6><ul>
<li>调整为一主二仆模式，6379带着6380、6381</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsuFaVS7.png" class="" title="img"> 

<ul>
<li><p>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</p>
</li>
<li><p>配置哨兵,填写内容</p>
<p>sentinel monitor mymaster 127.0.0.1 6379 1</p>
<p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </p>
</li>
<li><p>启动哨兵</p>
<p>/usr/local/bin</p>
<p>redis做压测可以用自带的redis-benchmark工具</p>
<p>执行redis-sentinel  /myredis/sentinel.conf </p>
</li>
</ul>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsWUnKND.png" class="" title="img"> 

<ul>
<li>当主机挂掉，从机选举中产生新的主机</li>
</ul>
<p>(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</p>
<p>哪个从机会被选举为主机呢？根据优先级别：slave-priority </p>
<p>原主机重启后会变为从机。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsKO5GHN.png" class="" title="img"> 

<ul>
<li>复制延时</li>
</ul>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h6 id="14-6-3-故障恢复"><a href="#14-6-3-故障恢复" class="headerlink" title="14.6.3 故障恢复"></a>14.6.3 故障恢复</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsWVLIkq.png" class="" title="img"> 

<p>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高</p>
<p>偏移量是指获得原主机数据最全的</p>
<p>每个redis实例启动后都会随机生成一个40位的runid</p>
<h6 id="14-6-4-主从复制"><a href="#14-6-4-主从复制" class="headerlink" title="14.6.4 主从复制"></a>14.6.4 主从复制</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title">getJedisFromSentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(jedisSentinelPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line"></span><br><span class="line">            JedisPoolConfig jedisPoolConfig =<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">            jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">jedisPoolConfig.setBlockWhenExhausted(<span class="keyword">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line"></span><br><span class="line">jedisSentinelPool=<span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line"><span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="十五、Redis集群"><a href="#十五、Redis集群" class="headerlink" title="十五、Redis集群"></a>十五、Redis集群</h4><h5 id="15-1-问题"><a href="#15-1-问题" class="headerlink" title="15.1 问题"></a>15.1 问题</h5><p>容量不够，redis如何进行扩容？</p>
<p>并发写操作， redis如何分摊？</p>
<p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p>
<h5 id="15-2-什么是集群"><a href="#15-2-什么是集群" class="headerlink" title="15.2 什么是集群"></a>15.2 什么是集群</h5><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h5 id="15-3-删除持久化数据"><a href="#15-3-删除持久化数据" class="headerlink" title="15.3 删除持久化数据"></a>15.3 删除持久化数据</h5><p>将rdb,aof文件都删除掉。</p>
<h5 id="15-4-制作6个实例，6379-6380-6381-6389-6390-6391"><a href="#15-4-制作6个实例，6379-6380-6381-6389-6390-6391" class="headerlink" title="15.4 制作6个实例，6379,6380,6381,6389,6390,6391"></a>15.4 制作6个实例，6379,6380,6381,6389,6390,6391</h5><h6 id="15-4-1-配置基本信息"><a href="#15-4-1-配置基本信息" class="headerlink" title="15.4.1 配置基本信息"></a>15.4.1 配置基本信息</h6><pre><code>开启daemonize yes

Pid文件名字

指定端口

Log文件名字

Dump.rdb名字

Appendonly 关掉或者换名字
</code></pre>
<h6 id="15-4-2-redis-cluster配置修改"><a href="#15-4-2-redis-cluster配置修改" class="headerlink" title="15.4.2 redis cluster配置修改"></a>15.4.2 redis cluster配置修改</h6><pre><code>cluster-enabled yes  打开集群模式

cluster-config-file nodes-6379.conf 设定节点配置文件名

cluster-node-timeout 15000  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。
</code></pre>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">include</span> <span class="string">/home/bigdata/redis.conf</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">&quot;/var/run/redis_6379.pid&quot;</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">&quot;dump6379.rdb&quot;</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">&quot;/home/bigdata/redis_cluster&quot;</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span></span><br><span class="line"><span class="meta">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="meta">cluster-config-file</span> <span class="string">nodes-6379.conf</span></span><br><span class="line"><span class="meta">cluster-node-timeout</span> <span class="string">15000</span></span><br></pre></td></tr></table></figure>



<h6 id="15-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件"><a href="#15-4-3-修改好redis6379-conf文件，拷贝多个redis-conf文件" class="headerlink" title="15.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件"></a>15.4.3 修改好redis6379.conf文件，拷贝多个redis.conf文件</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsHJosTE.png" class="" title="img"> 

<h6 id="15-4-4-使用查找替换修改另外5个文件"><a href="#15-4-4-使用查找替换修改另外5个文件" class="headerlink" title="15.4.4 使用查找替换修改另外5个文件"></a>15.4.4 使用查找替换修改另外5个文件</h6><p>例如：:%s/6379/6380  </p>
<h6 id="15-4-5-启动6个redis服务"><a href="#15-4-5-启动6个redis服务" class="headerlink" title="15.4.5 启动6个redis服务"></a>15.4.5 启动6个redis服务</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps3jmGkU.png" class="" title="img"> 

<h5 id="15-5-将六个节点合成一个集群"><a href="#15-5-将六个节点合成一个集群" class="headerlink" title="15.5 将六个节点合成一个集群"></a>15.5 将六个节点合成一个集群</h5><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsgQNKrD.png" class="" title="img"> 

<ul>
<li>合体：</li>
</ul>
<p>cd  /opt/redis-6.2.1/src</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</span><br></pre></td></tr></table></figure>



<p>此处不要用127.0.0.1， 请用真实IP地址</p>
<p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsmU3Viv.png" class="" title="img"> 

<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsdFtG2B.png" class="" title="img"> 

<ul>
<li>普通方式登录</li>
</ul>
<p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsPROCBG.png" class="" title="img"> 

<h5 id="15-6-c-采用集群策略连接，设置数据会自动切换到相应的写主机"><a href="#15-6-c-采用集群策略连接，设置数据会自动切换到相应的写主机" class="headerlink" title="15.6 -c 采用集群策略连接，设置数据会自动切换到相应的写主机"></a>15.6 -c 采用集群策略连接，设置数据会自动切换到相应的写主机</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsdvhQ5a.png" class="" title="img"> 

<h5 id="15-7-通过-cluster-nodes-命令查看集群信息"><a href="#15-7-通过-cluster-nodes-命令查看集群信息" class="headerlink" title="15.7 通过 cluster nodes 命令查看集群信息"></a>15.7 通过 cluster nodes 命令查看集群信息</h5><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsjQJy6v.png" class="" title="img"> 

<h5 id="15-8-redis-cluster-如何分配这六个节点"><a href="#15-8-redis-cluster-如何分配这六个节点" class="headerlink" title="15.8 redis cluster 如何分配这六个节点?"></a>15.8 redis cluster 如何分配这六个节点?</h5><p>一个集群至少要有三个主节点。</p>
<p>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p>
<p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p>
<h5 id="15-9-什么是slots"><a href="#15-9-什么是slots" class="headerlink" title="15.9 什么是slots"></a>15.9 什么是slots</h5><p>[OK] All nodes agree about slots configuration.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Check for open slots…</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Check slots coverage…</p>
</blockquote>
</blockquote>
</blockquote>
<p>[OK] All 16384 slots covered.</p>
<p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， </p>
<p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<p>节点 A 负责处理 0 号至 5460 号插槽。</p>
<p>节点 B 负责处理 5461 号至 10922 号插槽。</p>
<p>节点 C 负责处理 10923 号至 16383 号插槽。</p>
<h5 id="15-10-在集群中录入值"><a href="#15-10-在集群中录入值" class="headerlink" title="15.10 在集群中录入值"></a>15.10 在集群中录入值</h5><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>
<p>redis-cli客户端提供了 –c 参数实现自动重定向。</p>
<p>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p>
<p>不在一个slot下的键值，是不能使用mget,mset等多键操作。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpszdwG2f.png" class="" title="img"> 

<p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsTiprHP.png" class="" title="img"> 

<h5 id="15-11-查询集群中的值"><a href="#15-11-查询集群中的值" class="headerlink" title="15.11 查询集群中的值"></a>15.11 查询集群中的值</h5><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps095ctS.png" class="" title="img"> 

<h5 id="15-12-故障恢复"><a href="#15-12-故障恢复" class="headerlink" title="15.12 故障恢复"></a>15.12 故障恢复</h5><p>如果主节点下线？从节点能否自动升为主节点？注意：15秒超时</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsAAZqC5.png" class="" title="img"> 

<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsBqm3Tu.png" class="" title="img"> 

<p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p>
<p>redis.conf中的参数  cluster-require-full-coverage</p>
<h5 id="15-13-集群的Jedis开发"><a href="#15-13-集群的Jedis开发" class="headerlink" title="15.13 集群的Jedis开发"></a>15.13 集群的Jedis开发</h5><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p>
<p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15-14-Redis-集群提供了以下好处"><a href="#15-14-Redis-集群提供了以下好处" class="headerlink" title="15.14 Redis 集群提供了以下好处"></a>15.14 Redis 集群提供了以下好处</h5><p>实现扩容</p>
<p>分摊压力</p>
<p>无中心配置相对简单</p>
<h5 id="15-15-Redis-集群的不足"><a href="#15-15-Redis-集群的不足" class="headerlink" title="15.15 Redis 集群的不足"></a>15.15 Redis 集群的不足</h5><p>多键操作是不被支持的 </p>
<p>多键的Redis事务是不被支持的。lua脚本不被支持</p>
<p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
<h4 id="十六、Redis应用问题解决"><a href="#十六、Redis应用问题解决" class="headerlink" title="十六、Redis应用问题解决"></a>十六、Redis应用问题解决</h4><h5 id="16-1-缓存穿透"><a href="#16-1-缓存穿透" class="headerlink" title="16.1 缓存穿透"></a>16.1 缓存穿透</h5><h5 id="16-1-1-问题描述"><a href="#16-1-1-问题描述" class="headerlink" title="16.1.1 问题描述"></a>16.1.1 问题描述</h5><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsMjfpcE.jpg" class="" title="img"> 

<h5 id="16-1-2-解决方案"><a href="#16-1-2-解决方案" class="headerlink" title="16.1.2 解决方案"></a>16.1.2 解决方案</h5><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>解决方案：</p>
<p><strong>（1）</strong> 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p>
<p><strong>（2）</strong> 设置可访问的名单（白名单）：</p>
<p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
<p><strong>（3）</strong> 采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p><strong>（4）</strong> 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
<h5 id="16-2-缓存击穿"><a href="#16-2-缓存击穿" class="headerlink" title="16.2 缓存击穿"></a>16.2 缓存击穿</h5><h6 id="16-2-1-问题描述"><a href="#16-2-1-问题描述" class="headerlink" title="16.2.1 问题描述"></a>16.2.1 问题描述</h6><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps9uSIoX.jpg" class="" title="img"> 

<h6 id="16-2-2-解决方案"><a href="#16-2-2-解决方案" class="headerlink" title="16.2.2 解决方案"></a>16.2.2 解决方案</h6><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<p>解决问题：</p>
<p>（1）预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p>
<p>（2）实时调整：现场监控哪些数据热门，实时调整key的过期时长</p>
<p>（3）使用锁：</p>
<p>（1） 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</p>
<p>（2） 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</p>
<p>（3） 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</p>
<p>（4） 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps54iGVP.jpg" class="" title="img"> 

<h5 id="16-3-缓存雪崩"><a href="#16-3-缓存雪崩" class="headerlink" title="16.3 缓存雪崩"></a>16.3 缓存雪崩</h5><h6 id="16-3-1-问题描述"><a href="#16-3-1-问题描述" class="headerlink" title="16.3.1 问题描述"></a>16.3.1 问题描述</h6><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p>
<p>正常访问</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsalffN7.jpg" class="" title="img"> 

<p>缓存失效瞬间</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsq8oXDD.jpg" class="" title="img"> 

<h6 id="16-3-2-解决方案"><a href="#16-3-2-解决方案" class="headerlink" title="16.3.2 解决方案"></a>16.3.2 解决方案</h6><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p>
<p>解决方案：</p>
<p><strong>（1）</strong> 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</p>
<p><strong>（2）</strong> 使用锁或队列：</p>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p>
<p><strong>（3）</strong> 设置过期标志更新缓存：</p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
<p><strong>（4）</strong> 将缓存失效时间分散开：</p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h5 id="16-4-分布式锁"><a href="#16-4-分布式锁" class="headerlink" title="16.4 分布式锁"></a>16.4 分布式锁</h5><h6 id="16-4-1-问题描述"><a href="#16-4-1-问题描述" class="headerlink" title="16.4.1 问题描述"></a>16.4.1 问题描述</h6><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li><p>基于数据库实现分布式锁</p>
</li>
<li><p>基于缓存（Redis等）</p>
</li>
<li><p>基于Zookeeper</p>
</li>
</ol>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li><p>性能：redis最高</p>
</li>
<li><p>可靠性：zookeeper最高</p>
</li>
</ol>
<p>这里，我们就基于redis实现分布式锁。</p>
<h6 id="16-4-2-解决方案：使用redis实现分布式锁"><a href="#16-4-2-解决方案：使用redis实现分布式锁" class="headerlink" title="16.4.2 解决方案：使用redis实现分布式锁"></a>16.4.2 解决方案：使用redis实现分布式锁</h6><p>redis:命令</p>
<p># set sku:1:info “OK” NX PX 10000</p>
<p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p>
<p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p>
<p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p>
<p>XX ：只在键已经存在时，才对键进行设置操作。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsT1AbpB.jpg" class="" title="img"> 

<ol>
<li><p>多个客户端同时获取锁（setnx）</p>
</li>
<li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p>
</li>
<li><p>其他客户端等待重试</p>
</li>
</ol>
<p>编写代码</p>
<p>Redis: set num 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setne</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启，服务集群，通过网关压力测试：</p>
<p>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a></p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsQYdSEC.jpg" class="" title="img"> 

<p>查看redis中num的值：</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsgW16qZ.jpg" class="" title="img"> 

<p>基本实现。</p>
<p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p>
<p>解决：设置过期时间，自动释放锁。</p>
<h6 id="16-4-4-优化之设置锁的过期时间"><a href="#16-4-4-优化之设置锁的过期时间" class="headerlink" title="16.4.4 优化之设置锁的过期时间"></a>16.4.4 优化之设置锁的过期时间</h6><p>设置过期时间有两种方式：</p>
<ol>
<li><p>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</p>
</li>
<li><p>在set时指定过期时间（推荐）</p>
</li>
</ol>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsarfSaJ.jpg" class="" title="img"> 

<p>设置过期时间：</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsErCO7X.jpg" class="" title="img"> 

<p>压力测试肯定也没有问题。自行测试</p>
<p>问题：可能会释放其他服务器的锁。</p>
<p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p>
<ol>
<li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p>
</li>
<li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p>
</li>
<li><p>index3获取到锁，执行业务逻辑</p>
</li>
<li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p>
</li>
</ol>
<p>最终等于没锁的情况。 </p>
<p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
<h6 id="16-4-5-优化之UUID防误删"><a href="#16-4-5-优化之UUID防误删" class="headerlink" title="16.4.5 优化之UUID防误删"></a>16.4.5 优化之UUID防误删</h6><img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps7fNm8n.jpg" class="" title="img"> 

<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps0x2aDK.jpg" class="" title="img"> 

<p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<ol>
<li>index1执行删除时，查询到的lock值确实和uuid相等</li>
</ol>
<p>uuid=v1</p>
<p>set(lock,uuid)；</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsgY79Hv.jpg" class="" title="img"> 

<ol start="2">
<li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li>
</ol>
<p>在redis中没有了lock，没有了锁。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsGHqSkG.jpg" class="" title="img"> 

<ol start="3">
<li>index2获取了lock</li>
</ol>
<p>index2线程获取到了cpu的资源，开始执行方法</p>
<p>uuid=v2</p>
<p>set(lock,uuid)；</p>
<ol start="4">
<li>index1执行删除，此时会把index2的lock删除</li>
</ol>
<p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsKteqc4.jpg" class="" title="img"> 

<p>删除的index2的锁！</p>
<h6 id="16-4-6-优化之LUA脚本保证删除的原子性"><a href="#16-4-6-优化之LUA脚本保证删除的原子性" class="headerlink" title="16.4.6 优化之LUA脚本保证删除的原子性"></a>16.4.6 优化之LUA脚本保证删除的原子性</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLockLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">    String skuId = <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">    String locKey = <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取锁</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">    <span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">    <span class="comment">// 如果true</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">        <span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">        <span class="comment">/*使用lua脚本来锁*/</span></span><br><span class="line">        <span class="comment">// 定义lua 脚本</span></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用redis执行lua执行</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        <span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">        <span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">        <span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Lua 脚本详解：</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsuW2DKq.jpg" class="" title="img"> 

<p>项目中正确使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。</span><br><span class="line">String locKey =<span class="string">&quot;lock:&quot;</span>+skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>1、加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span></span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">Boolean lock = <span class="keyword">this</span>.redisTemplate.opsForValue()</span><br><span class="line">      .setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>2、使用lua释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 释放锁 del</span></span><br><span class="line">String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 设置lua脚本返回的数据类型</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置lua脚本返回类型为Long</span></span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br></pre></td></tr></table></figure>



<p>3、重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">testLock();</span><br></pre></td></tr></table></figure>

<p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<p>- 互斥性。在任意时刻，只有一个客户端能持有锁。</p>
<p>- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p>
<p>- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p>
<p>- 加锁和解锁必须具有原子性。</p>
<h4 id="十七、-Redis6-0新功能"><a href="#十七、-Redis6-0新功能" class="headerlink" title="十七、 Redis6.0新功能"></a>十七、 Redis6.0新功能</h4><h4 id="17-1-ACL"><a href="#17-1-ACL" class="headerlink" title="17.1 ACL"></a>17.1 ACL</h4><h6 id="17-1-1-简介"><a href="#17-1-1-简介" class="headerlink" title="17.1.1 简介"></a>17.1.1 简介</h6><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p>
<p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p>
<p>（1）接入权限:用户名和密码 </p>
<p>（2）可以执行的命令 </p>
<p>（3）可以操作的 KEY</p>
<p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p>
<h6 id="17-1-2-命令"><a href="#17-1-2-命令" class="headerlink" title="17.1.2 命令"></a>17.1.2 命令</h6><p>1、使用acl list命令展现用户权限列表</p>
<p>（1）数据说明</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsip1nDw.jpg" class="" title="img"> 

<p>2、使用acl cat命令</p>
<p>（1）查看添加权限指令类别</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps0lJwc6.jpg" class="" title="img"> 

<p>（2）加参数类型名可以查看类型下具体命令</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpskBmR7F.jpg" class="" title="img"> 

<p>3、使用acl whoami命令查看当前用户</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wps0tkhCX.jpg" class="" title="img"> 

<p>4、使用aclsetuser命令创建和编辑用户ACL</p>
<p>（1）ACL规则</p>
<p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p>
<table>
<thead>
<tr>
<th>ACL规则</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>参数</td>
<td>说明</td>
</tr>
<tr>
<td>启动和禁用用户</td>
<td>on</td>
<td>激活某用户账号</td>
</tr>
<tr>
<td>off</td>
<td>禁用某用户账号。注意，已验证的连接仍然可以工作。如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证。</td>
<td></td>
</tr>
<tr>
<td>权限的添加删除</td>
<td>+<command></td>
<td>将指令添加到用户可以调用的指令列表中</td>
</tr>
<tr>
<td>-<command></td>
<td>从用户可执行指令列表移除指令</td>
<td></td>
</tr>
<tr>
<td>+@<category></td>
<td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令。</td>
<td></td>
</tr>
<tr>
<td>-@<actegory></td>
<td>从用户可调用指令中移除类别</td>
<td></td>
</tr>
<tr>
<td>allcommands</td>
<td>+@all的别名</td>
<td></td>
</tr>
<tr>
<td>nocommand</td>
<td>-@all的别名</td>
<td></td>
</tr>
<tr>
<td>可操作键的添加或删除</td>
<td>~<pattern></td>
<td>添加可作为用户可操作的键的模式。例如~*允许所有的键</td>
</tr>
</tbody></table>
<p>（2）通过命令创建新用户默认权限</p>
<p>acl setuser user1</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsa9Cuhm.jpg" class="" title="img"> 

<p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p>
<p>（3）设置有用户名、密码、ACL权限、并启用的用户</p>
<p>acl setuser user2 on &gt;password ~cached:* +get</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsYaX8cU.jpg" class="" title="img"> 

<p>(4)切换用户，验证权限</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpsxsnzN1.jpg" class="" title="img"> 

<h5 id="17-2-IO多线程"><a href="#17-2-IO多线程" class="headerlink" title="17.2 IO多线程"></a>17.2 IO多线程</h5><h6 id="17-2-1-简介"><a href="#17-2-1-简介" class="headerlink" title="17.2.1 简介"></a>17.2.1 简介</h6><p>Redis6终于支撑多线程了，告别单线程了吗？</p>
<p>IO多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程。Redis6执行命令依然是单线程。</p>
<h6 id="17-2-2-原理架构"><a href="#17-2-2-原理架构" class="headerlink" title="17.2.2 原理架构"></a>17.2.2 原理架构</h6><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpssO4VCG.jpg" class="" title="img"> 

<p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p>
<p>io-threads-do-reads  yes </p>
<p>io-threads 4</p>
<h5 id="17-3-工具支持-Cluster"><a href="#17-3-工具支持-Cluster" class="headerlink" title="17.3 工具支持 Cluster"></a>17.3 工具支持 Cluster</h5><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p>
<img src="/2022/02/12/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/wpszqLQOJ.jpg" class="" title="img"> 

<h5 id="17-4-Redis新功能持续关注"><a href="#17-4-Redis新功能持续关注" class="headerlink" title="17.4 Redis新功能持续关注"></a>17.4 Redis新功能持续关注</h5><p>Redis6新功能还有：</p>
<p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p>
<p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p>
<p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p>
<p>4、Modules API</p>
<p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1GT4y1A756?spm_id_from=333.788.b_636f6d6d656e74.19">原视频地址</a></p>
<p><a href="https://gitee.com/yooome/golang">原文章地址</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>偏序介绍</title>
    <url>/2021/12/27/%E5%81%8F%E5%BA%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="偏序介绍"><a href="#偏序介绍" class="headerlink" title="偏序介绍"></a>偏序介绍</h4><ul>
<li>偏序</li>
<li>全序</li>
<li>偏序与全序区别</li>
<li>Lattice（格）<ul>
<li>Lattice（格）</li>
<li>Semilattice（半格）</li>
<li>Complete Lattice（全格）</li>
<li>Product Lattice（乘积格）</li>
</ul>
</li>
<li>上界与下界</li>
</ul>
<hr>
<span id="more"></span>

<p>偏序</p>
<ul>
<li><p>参考链接</p>
<p><a href="https://www.zhihu.com/question/36758436">全序与偏序</a></p>
</li>
<li><p>偏序</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>Partiallyordered set，简写poset</p>
</li>
<li><p>设R是集合A上的一个二元关系，若R满足：</p>
<p>Ⅰ <strong>自反性</strong>：对任意x∈A，有xRx；</p>
<p>Ⅱ <strong>反对称性</strong>（即反对称关系）：对任意x,y∈A，若xRy，且yRx，则x=y；</p>
<p>Ⅲ <strong>传递性</strong>：对任意x, y,z∈A，若xRy，且yRz，则xRz。</p>
<p>则称R为A上的偏序关系，通常记作≼。注意这里的≼不必是指一般意义上的“小于或等于”。</p>
<p>若然有x≼y，我们也说x排在y前面（x precedes y）。</p>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p><strong>严格偏序</strong>，反自反偏序</p>
<ul>
<li><p>给定集合S，“&lt;”是S上的二元关系，若“&lt;”满足：</p>
<p>反自反性：∀a∈S，有a≮a；</p>
<p>非对称性：∀a，b∈S，a&lt;b ⇒ b≮a；</p>
<p>传递性：∀a，b，c∈S，a&lt;b且b&lt;c，则a&lt;c；</p>
<p>则称“&lt;”是S上的严格偏序或反自反偏序</p>
</li>
<li><p>严格偏序与有向无环图（dag）有直接的对应关系。一个集合上的严格偏序的关系图就是一个有向无环图。其传递闭包是它自己</p>
</li>
</ul>
</li>
<li><p><strong>非严格偏序</strong>，自反偏序</p>
<ul>
<li><p>给定集合S，“≤”是S上的二元关系，若“≤”满足：</p>
<p>自反性：∀a∈S，有a≤a；</p>
<p>反对称性：∀a，b∈S，a≤b且b≤a，则a=b；</p>
<p>传递性：∀a，b，c∈S，a≤b且b≤c，则a≤c；</p>
<p>则称“≤”是S上的非严格偏序或自反偏序。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><p>假设有 A={1,2,3,4}，假设R是集合A上的关系：{&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;4,4&gt;,&lt;1,2&gt;,&lt;1,4&gt;,&lt;2,4&gt;,&lt;3,4&gt;}，那么：</p>
<p>自反性：可以看到 &lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;4,4&gt; 都在R中，满足。</p>
<p>反对称性：由于 &lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;4,4&gt; 不属于 x !=y ，所以不考虑这4种，对于 &lt;1,2&gt;，有 &lt;2,1&gt; 不在R中；对于&lt;2,4&gt; 有&lt;4,2&gt;不在R中；对于&lt;3,4&gt; 有&lt;4,3&gt; 不在 R中，满足。</p>
<p>传递性：&lt;1,1&gt;&lt;1,2&gt;在R中，并且&lt;1,2&gt;在R中；&lt;1,1&gt;&lt;1,4&gt;在R中，并且&lt;1,4&gt;在R中；&lt;2,2&gt;&lt;2,4&gt;在R中，并且&lt;2,4&gt;在R中；&lt;3,3&gt;&lt;3,4&gt;在R中，并且&lt;3,4&gt;在R中；等等其他，满足。</p>
<p>所以说R是偏序关系。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>全序</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>如果R是A上的偏序关系，那么对于任意的A集合上的 x,y，都有 x &lt;= y，或者 y &lt;= x，二者必居其一，那么则称R是A上的全序关系</p>
</li>
<li><p>设集合X上有一全序关系，如果我们把这种关系用 ≤ 表述，则下列陈述对于 X 中的所有 a, b 和 c 成立：</p>
<p>如果 a ≤ b 且 b ≤ a 则 a = b (反对称性)</p>
<p>如果 a ≤ b 且 b ≤ c 则 a ≤ c (传递性)</p>
<p>a ≤ b 或 b ≤ a (完全性)</p>
</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>假设有 A={a,b,c}，假设R是集合A上的关系：{&lt;a,a&gt;,&lt;b,b&gt;,&lt;c,c&gt;,&lt;a,b&gt;,&lt;a,c&gt;,&lt;b,c&gt;}和上述一样，可以证明具有自反性，反对称性，传递性，所以是偏序的，有因为有 &lt;a,b&gt;,&lt;a,c&gt;,&lt;b,c&gt;， 也就是说两两关系都有了，所以满足对于任意的A集合上的 x,y，都有 x &lt;= y，或者 y &lt;= x，二者必居其一，所以说是全序关系</li>
</ul>
</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li><p><strong>偏序集合</strong>：配备了偏序关系的集合。</p>
<p>偏序：只对部分要元素成立关系（部分可比）</p>
<p>集合内只有部分元素之间在这个关系下是可以比较的。</p>
<p>比如：比如复数集中并不是所有的数都可以比较大小，那么“大小”就是复数集的一个偏序关系</p>
</li>
<li><p><strong>全序集合</strong>：配备了全序关系的集合。</p>
<p>全序：对集合中任意两个元素都有关系</p>
<p>集合内任何一对元素在在这个关系下都是相互可比较的。</p>
<p>比如：有限长度的序列按字典序是全序的。最常见的是单词在字典中是全序的</p>
</li>
<li><p>例子</p>
<ul>
<li><p>集合的包含关系是一种偏序。</p>
<p>在正整数集中定义偏序：若a能整除b，我们就记为a≺b</p>
<p>显然它满足序公理。但整数集中，不是任何两个数都存在整除关系，这个关系是局部的（partial），太“偏颇”，于是被称为偏序</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Lattice</p>
<ul>
<li><p>参考链接</p>
<p><a href="https://blog.csdn.net/zhang971105/article/details/109244115">格</a></p>
</li>
<li><p><strong>Lattice（格）</strong></p>
<ul>
<li>定义<ul>
<li>如果一个偏序集的任意两个元素都有最小上界和最大下界，那么这一偏序集是一个格</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Semilattice（半格）</strong></p>
<ul>
<li>定义<ul>
<li>最小上界和最大下界只存在一个的偏序集称半格，只存在最小上界称为“join semilattice”，只存在最大下界称为“meet semilattice”</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Complete Lattice</strong>（全格）</p>
<ul>
<li>定义</li>
<li>一个偏序集的任意子集均存在最小上界和最大下界，那么这个偏序集成为全格</li>
<li>特点<ul>
<li>每个全格都存在一个最大元素 top（⊤=⊔P）和最小元素bottom（⊥=⊓P）</li>
<li>所有元素有限的格（finite lattice）均是全格。（反之不成立）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Product Lattice（乘积格）</strong></p>
<ul>
<li><p>给定n个lattice，L1 = (P1, ⊑1), L2 = (P2, ⊑2), …, Ln = (Pn, ⊑n)，如果每个lattice都有对应的⊔i(最小上界)和⊓i(最大下界)，那么我们得到一个Product Lattice Ln = (P, ⊑)并有以下四个定义：</p>
<p>1.P = P1 × … × Pn</p>
<p>2.(x1, …, xn) ⊑ (y1, …, yn) ⟺ (x1 ⊑ y1) ∧ … ∧ (xn ⊑ yn)</p>
<p>3.(x1, …, xn) ⊔ (y1, …, yn) = (x1 ⊔1 y1, …, xn ⊔n yn)</p>
<p>4.(x1, …, xn) ⊓ (y1, …, yn) = (x1 ⊓1 y1, …, xn ⊓n yn)</p>
</li>
<li><p>Product Lattice仍是Lattice，若每个子格为全格，那么乘积也是全格</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>上界与下界</p>
<ul>
<li><img src="/2021/12/27/%E5%81%8F%E5%BA%8F%E4%BB%8B%E7%BB%8D/image-20211227213940631.png" class="" title="image-20211227213940631"></li>
<li><p>前提</p>
<ul>
<li>给定偏序集(P, ⊑)及其子集S，满足S ⊆ P，则有：</li>
</ul>
</li>
<li><p>上界（不唯一）</p>
<ul>
<li>若∀x ∈ S, x ⊑ u,那么u ∈ P是子集S的上界</li>
</ul>
</li>
<li><p>下界（不唯一）</p>
<ul>
<li>若∀x ∈ S, l ⊑ x,那么l ∈ P是子集S的下界</li>
</ul>
</li>
<li><p>最小上界⊔S(lub)</p>
</li>
<li><p>最大下界⊓S(glb)</p>
</li>
<li><p>特点</p>
<ul>
<li>不是每个偏序都有lub和glb</li>
<li>但是如果一个偏序有lub和glb，那么它就是唯一的</li>
</ul>
</li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>偏序</category>
      </categories>
      <tags>
        <tag>偏序</tag>
        <tag>Lattice</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc中的SSA化算法</title>
    <url>/2021/12/26/gcc%E4%B8%AD%E7%9A%84SSA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p><a href="#SSA%E5%8C%96%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B">SSA化算法过程</a></p>
<ul>
<li><p><a href="#gcc%E4%B8%ADSSA%E5%8C%96%E7%9A%84%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0">gcc中SSA化的算法描述</a></p>
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%AF%E9%85%8D%E7%BB%93%E7%82%B9%E8%BE%B9%E7%95%8C">计算当前函数的支配结点边界</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E5%87%BD%E6%95%B0%E6%AF%8F%E6%9D%A1%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84defs/uses%E4%BF%A1%E6%81%AF">遍历并记录函数每条指令中出现的变量的defs/uses信息</a></li>
<li><a href="#%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97phi%E5%87%BD%E6%95%B0%E7%9A%84%E6%8F%92%E5%85%A5%E7%82%B9">为每个变量计算phi函数的插入点</a></li>
<li><a href="#%E6%8C%89%E7%85%A7%E6%94%AF%E9%85%8D%E6%A0%91%E7%9A%84DFS%E9%81%8D%E5%8E%86%E9%87%8D%E5%86%99%E6%AF%8F%E4%B8%AAbb%E7%9A%84%E6%AF%8F%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%B9%B6%E5%B0%86%E6%95%B4%E4%B8%AA%E5%87%BD%E6%95%B0SSA%E5%8C%96">按照支配树的DFS遍历重写每个bb的每条指令并将整个函数SSA化</a></li>
</ul>
</li>
<li><p><a href="#gcc%E4%B8%ADssa%E5%8C%96%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">gcc中ssa化的整体流程</a></p>
<ul>
<li><a href="#pass_build_ssa">pass_build_ssa</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84def/use%E5%88%86%E6%9E%90">函数指令序列的def/use分析</a></li>
<li><a href="#%E4%B8%BA%E6%AF%8F%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8F%92%E5%85%A5phi%E5%87%BD%E6%95%B0">为每个变量插入phi函数</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E5%86%99(SSA%E5%8C%96)">指令重写(SSA化)</a></li>
</ul>
</li>
</ul>
<hr>
<span id="more"></span>

<h4 id="SSA化算法过程"><a href="#SSA化算法过程" class="headerlink" title="SSA化算法过程"></a>SSA化算法过程</h4><h5 id="gcc中SSA化的算法描述"><a href="#gcc中SSA化的算法描述" class="headerlink" title="gcc中SSA化的算法描述"></a>gcc中SSA化的算法描述</h5><p>SSA化的流程可以简化为:</p>
<p><strong>(1)对所有变量插入必要的phi函数</strong></p>
<p><strong>(2)依次重写各个变量的定值/使用(转化为SSA格式)</strong></p>
<p>而具体到gcc中则大体分为4个步骤:</p>
<h5 id="计算当前函数的支配结点边界"><a href="#计算当前函数的支配结点边界" class="headerlink" title="计算当前函数的支配结点边界"></a>计算当前函数的支配结点边界</h5><p>​        按照迭代的必经结点边界算法, 要想确定phi函数插入的位置,必须要先根据函数的CFG确定函数的支配结点边界(支配结点边界的定义和算法见[2]), 在gcc中则是</p>
<pre><code>  1) 先通过calculate_dominance_info计算当前函数的支配结点信息

  2) 再通过compute_dominance_frontiers计算当前函数的支配结点边界信息
</code></pre>
<h5 id="遍历并记录函数每条指令中出现的变量的defs-uses信息"><a href="#遍历并记录函数每条指令中出现的变量的defs-uses信息" class="headerlink" title="遍历并记录函数每条指令中出现的变量的defs/uses信息"></a>遍历并记录函数每条指令中出现的变量的defs/uses信息</h5><p>​        此步主要是收集函数每条指令中出现的变量的defs/uses信息,这些信息保存在标量的bitmap中, 故可以按照任意的顺序遍历指令,而在gcc中则是采用基于支配树的深度优先遍历(DFS)顺序遍历各个基本块(bb)中的一条条指令</p>
<h5 id="为每个变量计算phi函数的插入点"><a href="#为每个变量计算phi函数的插入点" class="headerlink" title="为每个变量计算phi函数的插入点"></a>为每个变量计算phi函数的插入点</h5><p>​        1)中已经计算出了每个bb的支配结点边界信息；2)中计算出了每个变量的defs/uses信息, 按照迭代的必经结点边界算法, 此变量每一个def出现的结点的必经结点边界结点均需要插入一个phi函数, 插入后的phi函数作为此变量的一个新定值(def)点参与迭代计算.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对当前函数中的每个变量均需要通过此算法计算出其需要插入phi函数的结点信息,并在对应结点为每个变量分别插入phi函数</span><br></pre></td></tr></table></figure>
<h5 id="按照支配树的DFS遍历重写每个bb的每条指令并将整个函数SSA化"><a href="#按照支配树的DFS遍历重写每个bb的每条指令并将整个函数SSA化" class="headerlink" title="按照支配树的DFS遍历重写每个bb的每条指令并将整个函数SSA化"></a>按照支配树的DFS遍历重写每个bb的每条指令并将整个函数SSA化</h5><p>​        这里和步骤2)不同, SSA化的过程必须按照支配树的深度优先算法遍历结点,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)对于每个结点顺序需遍历所有语句,对于每条语句:</span><br><span class="line"></span><br><span class="line">   	A.若发现一个操作数中涉及变量使用(use)时,需要将此操作数改为对此变量在DFS上最新定义(SSA_NAME)的使用</span><br><span class="line">   	</span><br><span class="line"> 		B.若发现一个操作数中涉及变量定值(def)时,需要为此变量新创建一个SSA_NAME作为此变量的最新定义, 并将此此操作数改为新创建的SSA_NAME</span><br><span class="line"> 		</span><br><span class="line">   (2) 语句处理完毕后续为此结点的每个后继结点的所有phi函数确定一个参数(phi函数的第x个参数来自其第x个前驱结点)</span><br><span class="line">   </span><br><span class="line">    phi函数对应原始变量在4.4)-1)-2)中的最新定值(def)则为phi函数的第x个参数,代表运行时来若控制流来自第x个前驱,则当前参数x的定值应来自哪个SSA_NAME</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="gcc中ssa化的整体流程"><a href="#gcc中ssa化的整体流程" class="headerlink" title="gcc中ssa化的整体流程"></a>gcc中ssa化的整体流程</h4><h5 id="pass-build-ssa"><a href="#pass-build-ssa" class="headerlink" title="pass_build_ssa"></a>pass_build_ssa</h5><p>​        在gcc中 pass_build_ssa 负责对一个函数进行首次ssa转化,而 update_ssa则负责对转化后的ssa的更新, pass_build_ssa大体流程如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  pass_build_ssa负责对函数cfun的SSA化,整个SSA化可以分为4步:</span></span><br><span class="line"><span class="comment">  1.计算当前函数的支配结点边界信息                                                //compute_dominance_frontiers (dfs);</span></span><br><span class="line"><span class="comment">  2.以支配树的DFS遍历为顺序, 标记每条指令中的def/use信息到各个全局变量              //mark_def_dom_walker (CDI_DOMINATORS).walk (fun-&gt;cfg-&gt;x_entry_block_ptr);</span></span><br><span class="line"><span class="comment">  3.根据1中的支配节点边界信息和2中统计的每个变量的def/use信息, 确认每个</span></span><br><span class="line"><span class="comment">    变量需要在哪些bb中插入phi函数,并为每个变量插入对应个数的phi函数                 //insert_phi_nodes (dfs);</span></span><br><span class="line"><span class="comment">  4.以支配树的DFS遍历为顺序,遍历所有bb并重写每条指令中的所有use/def操作数(SSA化)    //rewrite_blocks</span></span><br><span class="line"><span class="comment">    1) 在遍历到每个bb时执行:</span></span><br><span class="line"><span class="comment">       1) 将bb中所有phi函数的返回值,写入到其对应变量的当前定义中(currdef)</span></span><br><span class="line"><span class="comment">       2) 遍历bb中所有指令序列,并重写其中的变量:</span></span><br><span class="line"><span class="comment">          1) 当发现一个变量的use时,用其currdef这个SSA_NAME替换指令中原有的use操作数</span></span><br><span class="line"><span class="comment">          2) 当发现一个变量的def时,为其新创建一个SSA_NAME替换指令中原有的def操作数,并将此SSA_NAME记录到此变量的currdef中,以及入栈</span></span><br><span class="line"><span class="comment">       3) 重写此bb所有后续bb中每个phi函数的第i个参数,i为当前bb在其后续bb的前驱bbs中的编号,phi函数的第i个参数被修改为其对应变量var在当前bb中最后的def(currdef)</span></span><br><span class="line"><span class="comment">    2) 在每个bb的所有sub bb都遍历结束后:</span></span><br><span class="line"><span class="comment">       1) 将4-1-2-2)中栈中保存的所有def都恢复到其对应变量的currdef中, 以保证当前bb分析完毕其父bb中的变量定义不变,继续rename其兄弟bb时才能保证正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">pass_build_ssa::execute</span> <span class="params">(function *fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bitmap_head *dfs;</span><br><span class="line">  basic_block bb;</span><br><span class="line">  <span class="built_in">init_ssa_operands</span> (fun);        <span class="comment">/* 此函数主要为当前函数分配了virtual use/def操作的虚拟操作数vop */</span></span><br><span class="line">  <span class="built_in">init_ssa_renamer</span> ();              <span class="comment">/* 标记当前函数尚未处于SSA格式, 初始化记录此函数中每个变量def/use的 var_infos 数组 */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 根据此函数基本块的数目分配一个一维的bitmap并初始化, 后续use/def分析中会在此bitmap中标记出现了use/def的bb(大部分都会出现) */</span></span><br><span class="line">  interesting_blocks = <span class="built_in">sbitmap_alloc</span> (<span class="built_in">last_basic_block_for_fn</span> (fun));</span><br><span class="line">  <span class="built_in">bitmap_clear</span> (interesting_blocks);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 根据此函数基本块数目,分配并初始化一个二维的bitmap矩阵(dfs[x][x]),后续此bitmap用来记录此函数中每个bb的支配结点边界信息 */</span></span><br><span class="line">  dfs = <span class="built_in">XNEWVEC</span> (bitmap_head, <span class="built_in">last_basic_block_for_fn</span> (fun));</span><br><span class="line">  <span class="built_in">FOR_EACH_BB_FN</span> (bb, fun)</span><br><span class="line">    <span class="built_in">bitmap_initialize</span> (&amp;dfs[bb-&gt;index], &amp;bitmap_default_obstack);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* step1:根据此函数(cfun)的CFG寄存器支配树和每个bb的支配结点边界[2], 支配节点边界是判断是否需要插入phi函数的关键,最终dfs中:</span></span><br><span class="line"><span class="comment">        * dfs[x]记录bb x的支配节点边界</span></span><br><span class="line"><span class="comment">        * dfs[x][y] = true; 代表y是x节点的一个支配节点边界节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">calculate_dominance_info</span> (CDI_DOMINATORS);      <span class="comment">/* 这里先根据CFG计算此函数的支配树,支配树以一个个支配结点结构体保存在各个 bb-&gt;doms[0]中 */</span></span><br><span class="line">  <span class="built_in">compute_dominance_frontiers</span> (dfs);              <span class="comment">/* 根据支配树信息(bbs-&gt;doms), 计算所有bb的支配结点边界信息并记录到二维bitmap dfs中 */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* step2:按照DFS算法遍历此函数的支配树中每个结点(bbs-&gt;doms),对于每个结点都要遍历其整个指令序列(bb-&gt;gimple_df-&gt;seqs)中的</span></span><br><span class="line"><span class="comment">    每一条语句(stmt),并将每条语句的def/use信息更新到 stmt-&gt;vuse/vdef/use_ops的同时,也更新到全局的var_infos/interest_blocks</span></span><br><span class="line"><span class="comment">    (针对整个函数),以及m_kills(针对当前bb)中 */</span></span><br><span class="line">  <span class="built_in">mark_def_dom_walker</span> (CDI_DOMINATORS).<span class="built_in">walk</span> (fun-&gt;cfg-&gt;x_entry_block_ptr);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* step3: 根据支配结点边界信息和每个变量的def/use信息,为每个变量在必要的bb中插入此变量的phi函数, 一个bb中所有插入的phi函数均记录在其bb-&gt;gimple_df-&gt;phi_nodes链表中,</span></span><br><span class="line"><span class="comment">    按照算法, 某个变量var若在某个bb中出现了def,则此bb的支配结点边界中所有的bbs都要插入var的phi函数</span></span><br><span class="line"><span class="comment">    需要注意的是:此时插入的phi函数只有返回值结点(为var新生成的SSA_NAME),其参数列表为空,只有在其前驱结点重写后phi函数的参数才能得以填充 */</span></span><br><span class="line">  <span class="built_in">insert_phi_nodes</span> (dfs);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* step4: 按照DFS算法再次遍历函数的支配树,并重写每个bb中的每条指令stmt(也就是SSA化), stmt中的每个use要改为对齐currdef(SSA_NAME)的use, </span></span><br><span class="line"><span class="comment">    每个def都要新建一个新的SSA_NAME; 对于一个bb的SSA化又分为三步:</span></span><br><span class="line"><span class="comment">     1. 将此bb中所有phi函数的返回值设置为其对应变量的currdef</span></span><br><span class="line"><span class="comment">     2. 遍历此bb中所有stmt, 将其中所有use的操作数改为其currdef; 若碰到def则为其原始变量var生成一个新的SSA_NAME,将def的操作数和currdef替换为新的SSA_NAME</span></span><br><span class="line"><span class="comment">     3. 遍历此bb在函数CFG中所有的后继bb, 填充后继bb中所有phi指令的一个参数(第x个参数,x为此bb在其后继bb的所有前驱结点中的编号)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">rewrite_blocks</span> (<span class="built_in">ENTRY_BLOCK_PTR_FOR_FN</span> (fun), REWRITE_ALL);</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数指令序列的def-use分析"><a href="#函数指令序列的def-use分析" class="headerlink" title="函数指令序列的def/use分析"></a>函数指令序列的def/use分析</h5><p>​        要分析当前函数中所有变量的def/use信息,这是通过函数mark_def_dom_walker::walk()实现的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mark_def_dom_walker</span> :</span> <span class="keyword">public</span> dom_walker        <span class="comment">/* 没有单独实现 walk函数,继承父类walk函数 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">mark_def_dom_walker</span> (cdi_direction direction);</span><br><span class="line">  ~<span class="built_in">mark_def_dom_walker</span> ();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> edge <span class="title">before_dom_children</span> <span class="params">(basic_block)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  bitmap m_kills;                <span class="comment">/* 此bitmap可以看做是一个以变量UID为下标的一维数组, m_kills[x] = 1;则代表UID为x的变量在当前分析的bb中出现了kill def */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dom_walker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">walk</span> <span class="params">(basic_block)</span></span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   在此函数执行前,bb所在的函数必须已经计算过了支配树(calculate_dominance_info),此时计算结果已经保存到各个bb-&gt;doms中了,</span></span><br><span class="line"><span class="comment">  而此函数则通过深度优先遍历算法(DFS)遍历从bb开始的整个支配树的所有结点,且:</span></span><br><span class="line"><span class="comment">   * 在刚遍历到某个结点时,为当前结点调用before_dom_children(basic_block);回调</span></span><br><span class="line"><span class="comment">     - 若此回调返回STOP,则其所有子节点不必再遍历</span></span><br><span class="line"><span class="comment">     - 若此回调返回非STOP,则按照DFS继续遍历其子结点</span></span><br><span class="line"><span class="comment">   * 在某个结点(及其子节点)遍历完毕后, 为当前结点调用after_dom_children(basic_block);回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dom_walker::walk</span> <span class="params">(basic_block bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sp = <span class="number">0</span>;</span><br><span class="line">  basic_block dest;</span><br><span class="line">  basic_block *worklist = <span class="built_in">XNEWVEC</span> (basic_block, <span class="built_in">n_basic_blocks_for_fn</span> (cfun) * <span class="number">2</span>);    <span class="comment">/* 为后续递归遍历分配临时的结点栈 */</span></span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* 只遍历有前驱的bb或函数出入口bb */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">EDGE_COUNT</span> (bb-&gt;preds) &gt; <span class="number">0</span> || bb == <span class="built_in">ENTRY_BLOCK_PTR_FOR_FN</span> (cfun) || bb == <span class="built_in">EXIT_BLOCK_PTR_FOR_FN</span> (cfun))</span><br><span class="line">      &#123;</span><br><span class="line">        edge taken_edge = <span class="literal">NULL</span>;</span><br><span class="line">        taken_edge = <span class="built_in">before_dom_children</span> (bb);    <span class="comment">/* 在遍历到一个结点时,先调用 before_dom_children 回调 */</span></span><br><span class="line">        worklist[sp++] = bb;                      <span class="comment">/* 将当前节点放到worklist中,作为栈帧标记(NULL为分隔符),后续会先递归处理其子节点 */</span></span><br><span class="line">        worklist[sp++] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (taken_edge != STOP)                    <span class="comment">/* 若回调返回的非 STOP(-1) */</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">int</span> saved_sp = sp;</span><br><span class="line">          <span class="comment">/* 遍历结点bb在支配树中的所有子节点,支配树信息在walk之前应该已经计算出(calculate_dominance_info),并记录在各个bb-&gt;doms中 */</span></span><br><span class="line">          <span class="keyword">for</span> (dest = <span class="built_in">first_dom_son</span> (m_dom_direction, bb); dest; dest = <span class="built_in">next_dom_son</span> (m_dom_direction, dest))</span><br><span class="line">            worklist[sp++] = dest;                <span class="comment">/* 在栈中记录当前bb的所有要遍历的支配树中的子结点 */</span></span><br><span class="line">          <span class="keyword">if</span> (sp - saved_sp &gt; <span class="number">1</span> &amp;&amp; m_dom_direction == CDI_DOMINATORS &amp;&amp; m_bb_to_rpo)        <span class="comment">/* 若对支配树的 DFS遍历有顺序要求,则将bb的子节点排序以确保后续的遍历顺序 */</span></span><br><span class="line">            <span class="built_in">sort_bbs_postorder</span> (&amp;worklist[saved_sp], sp - saved_sp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">           </span><br><span class="line">      <span class="keyword">while</span> (sp &gt; <span class="number">0</span> &amp;&amp; !worklist[sp - <span class="number">1</span>])         <span class="comment">/* 若当前bb没有子结点,或所有子节点都处理完毕,则为当前结点调用处理完毕后的回调, while循环负责处理多级结点返回 */</span>    </span><br><span class="line">      &#123;</span><br><span class="line">        --sp;                          <span class="comment">/* 忽略前面标记的NULL分隔符 */</span></span><br><span class="line">        bb = worklist[--sp];           <span class="comment">/* 处理上一层的下一个bb */</span></span><br><span class="line">               ......</span><br><span class="line">        <span class="built_in">after_dom_children</span> (bb);       <span class="comment">/* 当前结点及其子节点遍历完毕的回调函数 */</span></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (sp)</span><br><span class="line">        bb = worklist[--sp];           <span class="comment">/* 递归遍历worklist中下一个结点 */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;                         <span class="comment">/* 整个支配树结点的DFS遍历完毕, 退出循环 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span> (worklist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        由上可知, mark_def_dom_walker (CDI_DOMINATORS).walk (fun-&gt;cfg-&gt;x_entry_block_ptr); 实际上是通过其父类的walk函数从当前函数的入口bb开始根据DFS算法遍历了此函数的支配树,并对每个bb调用了回调函数mark_def_dom_walker::before_dom_children,此函数定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">edge <span class="title">mark_def_dom_walker::before_dom_children</span> <span class="params">(basic_block bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gimple_stmt_iterator gsi;</span><br><span class="line">  <span class="built_in">bitmap_clear</span> (m_kills);            <span class="comment">/* 重新清空记录当前bb中kill defs的数组 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (gsi = <span class="built_in">gsi_start_bb</span> (bb); !<span class="built_in">gsi_end_p</span> (gsi); <span class="built_in">gsi_next</span> (&amp;gsi))            <span class="comment">/* 遍历当前bb中所有gimple语句 */</span></span><br><span class="line">    <span class="comment">/* 分析每条语句中的def/use信息,结果更新到stmt-&gt;vuse/vdef/use_ops的同时也</span></span><br><span class="line"><span class="comment">       将统计信息更新到全局变量var_infos,interesting_blocks,以及参数m_kills中 */</span></span><br><span class="line">    <span class="built_in">mark_def_sites</span> (bb, <span class="built_in">gsi_stmt</span> (gsi), m_kills);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_def_sites</span> <span class="params">(basic_block bb, gimple *stmt, bitmap kills)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tree def;</span><br><span class="line">  use_operand_p use_p;</span><br><span class="line">  ssa_op_iter iter;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">update_stmt</span> (stmt);    <span class="comment">/* 分析stmt中的 virutal use/def, real use信息,并将其更新到当前语句 stmt-&gt;vuse/vdef/use_ops中 */</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="built_in">set_register_defs</span> (stmt, <span class="literal">false</span>);    <span class="comment">/* 默认标记当前stmt中不存在操作数的def/use操作 */</span></span><br><span class="line">  <span class="built_in">set_rewrite_uses</span> (stmt, <span class="literal">false</span>);</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">FOR_EACH_SSA_USE_OPERAND</span> (use_p, stmt, iter, SSA_OP_ALL_USES)    <span class="comment">/* 遍历此stmt中的所有uses的操作数 */</span></span><br><span class="line">  &#123;</span><br><span class="line">      tree sym = <span class="built_in">USE_FROM_PTR</span> (use_p);                  <span class="comment">/* 获取当前处理的操作数中的变量树节点信息 */</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         在当前bb的每条语句分析过程中(见下面的循环)如果发现了某变量的def,那么此def对于当前bb来说就是个kill def,</span></span><br><span class="line"><span class="comment">        而如果分析到一个变量的use前还没有在当前bb中发现其kill def,则说明此变量的值来自其前驱bb, 那么此时就要</span></span><br><span class="line"><span class="comment">        标记此变量在当前bb中出现了传播使用(set_livein_block)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">bitmap_bit_p</span> (kills, <span class="built_in">DECL_UID</span> (sym)))        <span class="comment">/* 若此变量在当前bb中未出现kill def */</span></span><br><span class="line">        <span class="built_in">set_livein_block</span> (sym, bb);                     <span class="comment">/* 在变量的全局var_info-&gt;def_blocks-&gt;livein_blocks中标记,变量sym在基本块bb中为传播使用 */</span></span><br><span class="line">      <span class="built_in">set_rewrite_uses</span> (stmt, <span class="literal">true</span>);                    <span class="comment">/* 标记当前语句stmt中有需要被重写的use操作数 */</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">FOR_EACH_SSA_TREE_OPERAND</span> (def, stmt, iter, SSA_OP_ALL_DEFS)    <span class="comment">/* 动态分析当前stmt的所有defs, 并遍历所有被def的变量 */</span></span><br><span class="line">  &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="built_in">set_def_block</span> (def, bb, <span class="literal">false</span>);                  <span class="comment">/* 在当前变量的 var_info-&gt;def_blocks-&gt;def_blocks 中标记在基本块bb中出现了此变量的def */</span></span><br><span class="line">      <span class="built_in">bitmap_set_bit</span> (kills, <span class="built_in">DECL_UID</span> (def));          <span class="comment">/* 在per bb的kills数组中标记当前bb中出现了变量def的 kill def */</span></span><br><span class="line">      <span class="built_in">set_register_defs</span> (stmt, <span class="literal">true</span>);                  <span class="comment">/* 在当前语句stmt中标记其中出现了某操作数的def操作 */</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 当当前分析的bb中任何一条语句(stmt)中出现了操作数的use/def操作,当前bb就要被标记为interesting. 除了特别简单的bb,基本上大部分bb都会标记到interesting_blocks中 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">rewrite_uses_p</span> (stmt) || <span class="built_in">register_defs_p</span> (stmt))</span><br><span class="line">    <span class="built_in">bitmap_set_bit</span> (interesting_blocks, bb-&gt;index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="为每个变量插入phi函数"><a href="#为每个变量插入phi函数" class="headerlink" title="为每个变量插入phi函数"></a>为每个变量插入phi函数</h5><p>​        分析完def/use信息后,则需要为当前函数的每个变量在需要的位置(bb)处插入phi函数,此过程是在函数 insert_phi_nodes中实现的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此函数负责为当前函数中所有变量在需要插入phi函数的bb中插入phi函数， phi函数全部记录在每个bb-&gt;gimple_df-&gt;phi_nodes中</span></span><br><span class="line"><span class="comment">  需要注意的是此时phi函数的参数尚未填充,只有返回值填充了(其对应变量派生的SSA_NAME)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_phi_nodes</span> <span class="params">(bitmap_head *dfs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  var_info *info;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    var_infos[]中记录了当前函数所有变量(local_decls)在整个函数中的def/use信息, 而在def/use分析中简单的排除了一些不需要插入phi函数的变量(need_phi_state = NEED_PHI_STATE_NO的变量,</span></span><br><span class="line"><span class="comment">   这样的变量在整个函数中只存在一个def,且其所有use点所在的bb都被def所在的bb支配),而vars数组中最终只记录了那些可能需要插入phi函数的变量做二次分析和处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function">auto_vec&lt;var_info *&gt; <span class="title">vars</span> <span class="params">(var_infos-&gt;elements ())</span></span>;</span><br><span class="line">  <span class="built_in">FOR_EACH_HASH_TABLE_ELEMENT</span> (*var_infos, info, var_info_p, hi)</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;info.need_phi_state != NEED_PHI_STATE_NO)</span><br><span class="line">      vars.<span class="built_in">quick_push</span> (info);</span><br><span class="line">  vars.<span class="built_in">qsort</span> (insert_phi_nodes_compare_var_infos);        <span class="comment">/* 根据变量的UID排序 */</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">FOR_EACH_VEC_ELT</span> (vars, i, info)                         <span class="comment">/* 遍历当前函数中每个可能要插入phi结点的变量(info为迭代器) */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * info-&gt;info.def_blocks.def_blocks 记录info-&gt;var这个变量在各个bb中的def信息(bitmap)</span></span><br><span class="line"><span class="comment">        * dtf记录整个函数所有bb的支配结点边界信息</span></span><br><span class="line"><span class="comment">        此函数根据二者计算出需要为当前变量var插入phi函数的所有bb的信息,返回的idf同样是一个bitmap,若idf[i]-1,则代表在编号为i的bb中需要为变量info-&gt;var插入phi函数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      bitmap idf = <span class="built_in">compute_idf</span> (info-&gt;info.def_blocks.def_blocks, dfs);</span><br><span class="line">      <span class="comment">/* 根据idf这个bitmap, 向其对应的bb中为变量info-&gt;var创建一个gphi指令,并将此指令添加到 bb-&gt;gimple_df-&gt;phi_nodes中, </span></span><br><span class="line"><span class="comment">        ifd是标准算法算出的phi函数插入点,而此函数在创建前还会再次裁剪 idf bitmap(对于变量kill def且不存在livein use的bb,无需插入phi函数) */</span></span><br><span class="line">      <span class="built_in">insert_phi_nodes_for</span> (info-&gt;var, idf, <span class="literal">false</span>);</span><br><span class="line">      <span class="built_in">BITMAP_FREE</span> (idf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   此函数负责根据变量var的def信息(def_blocks)和整个函数所有bb的支配结点边界信息,(dfs) 计算出需要为此函数插入phi函数的bb信息(bitmap phi_insertion_points)并返回此bitmap</span></span><br><span class="line"><span class="comment">  phi函数的算法是:</span></span><br><span class="line"><span class="comment">  1) 当前变量x所有的def点(bb)的支配结点边界中所有结点都需要插入phi函数</span></span><br><span class="line"><span class="comment">  2) 插入的phi函数相当于对变量x的隐式def,故插入了phi函数的结点(bb)的支配结点边界中所有结点也都要插入phi函数</span></span><br><span class="line"><span class="comment">  3) 针对一个变量x, 任何一个bb中只需要为其插入一个phi函数即可,无需重复插入,因为phi函数参数来自于所有前驱,一个phi函数就代表了所有可能的隐式def;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">bitmap <span class="title">compute_idf</span> <span class="params">(bitmap def_blocks, bitmap_head *dfs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bitmap_iterator bi;</span><br><span class="line">  <span class="keyword">unsigned</span> bb_index, i;</span><br><span class="line">  bitmap phi_insertion_points;</span><br><span class="line"> </span><br><span class="line">  <span class="function">auto_vec&lt;<span class="keyword">int</span>&gt; <span class="title">work_stack</span> <span class="params">(<span class="number">2</span> * n_basic_blocks_for_fn (cfun))</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 此bitmap为函数的返回值, 其是一个一维数组,下标为bb在当前函数的索引号， phi_insertion_points[i] = 1;则代表当前bb中需要为变量x插入phi函数 */</span></span><br><span class="line">  phi_insertion_points = <span class="built_in">BITMAP_ALLOC</span> (<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 按照算法, phi函数需要插入到变量 x所有def点所在bb的支配结点边界结点中, 这里首先将所有出现变量x def点的bb加入到队列中 */</span></span><br><span class="line">  <span class="built_in">EXECUTE_IF_SET_IN_BITMAP</span> (def_blocks, <span class="number">0</span>, bb_index, bi)</span><br><span class="line">    work_stack.<span class="built_in">quick_push</span> (bb_index);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (work_stack.<span class="built_in">length</span> () &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bb_index = work_stack.<span class="built_in">pop</span> ();        <span class="comment">/* 获取下一个存在变量x def的bb的编号 */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &amp;dfs[bb_index] 记录索引号为bb_index的bb的支配结点边界信息(下标为bb索引号, dfs[bb_index][i] = 1; 则代表编号为i的bb为编号为 bb_index的bb的支配结点) </span></span><br><span class="line"><span class="comment">        此宏展开后会依次比较 dfs[bb_index] 和phi_insertion_points 中的每一个bit,若 dfs[bb_index][i] = 1; 而phi_insertion_points[i] = 0; 则代表发现了</span></span><br><span class="line"><span class="comment">       新的需要插入phi函数的bb(编号为i),此时会将i push到work_stack中,下一次循环后会递归遍历此bb;</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      <span class="built_in">EXECUTE_IF_AND_COMPL_IN_BITMAP</span> (&amp;dfs[bb_index], phi_insertion_points, <span class="number">0</span>, i, bi)</span><br><span class="line">      &#123;</span><br><span class="line">        work_stack.<span class="built_in">quick_push</span> (i);    <span class="comment">/* 结点i因插入了φ函数,其支配结点边界结点也要加入到 phi_insertion_points中 */</span></span><br><span class="line">        <span class="built_in">bitmap_set_bit</span> (phi_insertion_points, i);    <span class="comment">/* 标记结点i中需要插入φ函数 */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> phi_insertion_points;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   此函数为变量var在需要插入phi函数的bb中插入gphi指令(包括创建,派生var的一个SSA_NAME作为gphi返回值,并将gphi插入到bb-&gt;gimple_df-&gt;phi_nodes指令序列中)</span></span><br><span class="line"><span class="comment">  在插入前会尝试删除一些不需要插入phi函数的点(如果变量var在某个bb中不存在liven_use,且存在kill_def,则此bb无需插入phi函数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_phi_nodes_for</span> <span class="params">(tree var, bitmap phi_insertion_points, <span class="keyword">bool</span> update_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> bb_index;</span><br><span class="line">  edge e;</span><br><span class="line">  gphi *phi;</span><br><span class="line">  basic_block bb;</span><br><span class="line">  bitmap_iterator bi;</span><br><span class="line">  def_blocks *def_map = <span class="built_in">find_def_blocks_for</span> (var);    <span class="comment">/* 此结构体中存着变量var的多个bitmap,包括 kill def/livein use */</span></span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* def_blocks和 livein_blocks都是在 各个bb的mark_def_sites中分析出的:</span></span><br><span class="line"><span class="comment">     * def_blocks[i] = 1;代表变量var在编号为i的bb中出现了kill def;</span></span><br><span class="line"><span class="comment">     * livein_blocks[i] = 1; 代表变量var在编号为i的bb中出现了传播使用(也就是第一次访问是use,而不是def)</span></span><br><span class="line"><span class="comment">     而在一个bb中,如果一个变量没有出现livein,且存在kill def,那么这个bb中是不需要插入phi函数的,简单说就是:在一个bb的顺序指令执行过程中,</span></span><br><span class="line"><span class="comment">    一个变量先被赋值然后才被使用,那么在SSA化时其前驱bb对此变量的def就不必考虑了(因为没有人用), 但如果变量在此bb中没有def则必须插入phi函数,</span></span><br><span class="line"><span class="comment">    否则会影响到此bb后续bb中var的定值.</span></span><br><span class="line"><span class="comment">     这里就是从phi_insertion_points中去除了livein_use,且有kill def的bb,这些bb无需插入phi函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="built_in">prune_unused_phi_nodes</span> (phi_insertion_points, def_map-&gt;def_blocks, def_map-&gt;livein_blocks);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* phi_insertion_points 中剩余的结点均需要为变量var插入phi函数,这里遍历其中每个bb */</span></span><br><span class="line">  <span class="built_in">EXECUTE_IF_SET_IN_BITMAP</span> (phi_insertion_points, <span class="number">0</span>, bb_index, bi)</span><br><span class="line">  &#123;</span><br><span class="line">    bb = <span class="built_in">BASIC_BLOCK_FOR_FN</span> (cfun, bb_index);    <span class="comment">/* 根据bb_index获取bb的basic_block结构体 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (update_p)</span><br><span class="line">      <span class="built_in">mark_block_for_update</span> (bb);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TREE_CODE</span> (var) == SSA_NAME) &#123;    <span class="comment">/* SSA_NAME 是在 update_ssa中用到的,先pass */</span></span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         <span class="comment">/* 正常变量是走这里 */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建一个gphi指令,为变量var生成一个新的SSA_NAME设置为此gphi的返回值结点(所以phi函数的返回值SSA_NAME的version编号都较小),</span></span><br><span class="line"><span class="comment">       gphi指令的所有参数都暂不填充(因为所有的指令尚未SSA化,无法填充), 并将新生成的gphi指令链接到当前bb-&gt;gimple_df-&gt;phi_nodes指令序列的末尾</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      phi = <span class="built_in">create_phi_node</span> (var, bb);</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set_register_defs</span> (phi, <span class="literal">true</span>);        <span class="comment">/* 标记当前gphi语句中存在def操作(因为其返回值结点被def了) */</span></span><br><span class="line">    <span class="built_in">mark_phi_for_rewrite</span> (bb, phi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指令重写-SSA化"><a href="#指令重写-SSA化" class="headerlink" title="指令重写(SSA化)"></a>指令重写(SSA化)</h5><p>​        phi函数插入完毕后,需要对整个函数所有bb中的所有指令序列中所有的def/use变量进行重写,此过程是在函数rewrite_blocks 中完成的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rewrite_blocks</span> <span class="params">(basic_block entry, <span class="keyword">enum</span> rewrite_mode what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (what == REWRITE_ALL)</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         按照DFS遍历当前函数的支配树,并在:</span></span><br><span class="line"><span class="comment">         * 遍历到某个bb时执行回调 rewrite_dom_walker::before_dom_children</span></span><br><span class="line"><span class="comment">         * 遍历完成某个bb(及其所有sub bb)后执行回调 rewrite_dom_walker::after_dom_children</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="built_in">rewrite_dom_walker</span> (CDI_DOMINATORS).<span class="built_in">walk</span> (entry);        <span class="comment">/* pass_build_ssa时走这里 */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (what == REWRITE_UPDATE)</span><br><span class="line">      <span class="built_in">rewrite_update_dom_walker</span> (CDI_DOMINATORS).<span class="built_in">walk</span> (entry);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">gcc_unreachable</span> ();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">def_blocks</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  bitmap def_blocks;       <span class="comment">/* 记录当前变量在哪些bb中出现了kill def */</span></span><br><span class="line">  bitmap phi_blocks;</span><br><span class="line">  bitmap livein_blocks;    <span class="comment">/* 记录当前变量在哪些bb中出现了livein use */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">common_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">ENUM_BITFIELD</span> (need_phi_state) need_phi_state : <span class="number">2</span>;    <span class="comment">/* 记录def/use分析中简单的判断结果,即当前变量是否不需要插入phi函数 */</span></span><br><span class="line">  tree current_def;                                     <span class="comment">/* 记录此变量在rewrite_stmt中当前的定义(通常是其一个SSA_NAME) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">def_blocks</span> <span class="title">def_blocks</span>;</span>                         <span class="comment">/* 记录此变量在所有bb中的kill def/livein use 信息 */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">var_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  tree var;             <span class="comment">/* 此var_info中记录了哪个变量的信息 */</span></span><br><span class="line">  common_info info;     <span class="comment">/* 记录此变量的def/use,currdef等相关信息 */</span> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   此函数负责在DFS遍历到支配树中每个结点bb时,将其中的所有stmt SSA化, SSA化的流程分为三步:</span></span><br><span class="line"><span class="comment">   1. 将此bb中所有phi函数的返回值设置为其对应变量的currdef</span></span><br><span class="line"><span class="comment">   2. 遍历此bb中所有stmt, 将其中所有use的操作数改为其currdef; 若碰到def则为其原始变量var生成一个新的SSA_NAME,将def的操作数和currdef替换为新的SSA_NAME</span></span><br><span class="line"><span class="comment">   3. 遍历此bb在函数CFG中所有的后继bb, 填充后继bb中所有phi指令的一个参数(第x个参数,x为此bb在其后继bb的所有前驱结点中的编号)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">edge <span class="title">rewrite_dom_walker::before_dom_children</span> <span class="params">(basic_block bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  block_defs_stack.<span class="built_in">safe_push</span> (NULL_TREE);        <span class="comment">/* 在stack中做一个标记,代表当前开始处理一个新的bb */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     对于一个变量x来说,其phi函数的作用就是在SSA化的过程中为phi函数所在bb整合此变量在其各个前驱bb中的定义, </span></span><br><span class="line"><span class="comment">    故在SSA化的重写阶段,若一个变量在某个bb中有phi函数,那么phi函数的返回值(x的一个SSA_NAME,见insert_phi_nodes)会作为分析此bb时x的最新定义.</span></span><br><span class="line"><span class="comment">     这里是将当前bb的所有phi函数的返回值,设置为其对应变量的最新定义(变量的var_info.currdef)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (gphi_iterator gsi = <span class="built_in">gsi_start_phis</span> (bb); !<span class="built_in">gsi_end_p</span> (gsi); <span class="built_in">gsi_next</span> (&amp;gsi))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         获取gphi指令的返回值结点,其必为一个SSA_NAME结点,见phi函数的创建过程</span></span><br><span class="line"><span class="comment">        pass_build_ssa =&gt; insert_phi_nodes =&gt; insert_phi_nodes_for =&gt; create_phi_node</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      tree result = <span class="built_in">gimple_phi_result</span> (<span class="built_in">gsi_stmt</span> (gsi));        <span class="comment">/* 获取此phi函数返回值结点 */</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 将返回值结点设置为其原始变量的currdef, 如:</span></span><br><span class="line"><span class="comment">         若当result 为SSA_NAME x_1, 则 SSA_NAME_VAR (result)为变量x,这里设置 x的var_info.curredef = (tree)x_1; </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="built_in">register_new_def</span> (result, <span class="built_in">SSA_NAME_VAR</span> (result));        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bitmap_bit_p</span> (interesting_blocks, bb-&gt;index))    <span class="comment">/* 若当前bb在前面def/use分析中发现其中至少存在一个def/use */</span></span><br><span class="line">    <span class="comment">/* 遍历当前bb中的每一条语句,并修改每条语句中需要被重写的操作数，注意这里遍历的是bb-&gt;gimple_df-&gt;seqs, 而不是phi_nodes */</span></span><br><span class="line">    <span class="keyword">for</span> (gimple_stmt_iterator gsi = <span class="built_in">gsi_start_bb</span> (bb); !<span class="built_in">gsi_end_p</span> (gsi); <span class="built_in">gsi_next</span> (&amp;gsi))</span><br><span class="line">      <span class="built_in">rewrite_stmt</span> (&amp;gsi);    <span class="comment">/* 此函数负责对一条指令(stmt)进行重写 */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 当前bb重写完毕(SSA化完毕),则所有的变量都已经变为其SSA形式了,此时需要为其所有后继结点填充所有phi函数的第i个参数, i为此bb在其后继的前驱结点中的编号 */</span></span><br><span class="line">  <span class="built_in">rewrite_add_phi_arguments</span> (bb);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   此函数负责重写si-&gt;ptr这条语句(stmt)中的所有def/use,将此stmt SSA化, 其处理顺序是先处理use后处理def,这也符合正常一条指令执行的逻辑,stmt中:</span></span><br><span class="line"><span class="comment">  * 发现所有对原始变量var的use的操作数指针,都会被改为(指向)对其currdef这个SSA_NAME结点</span></span><br><span class="line"><span class="comment">  * 发现所有对原始变量var的def,都会先为变量var新生成一个SSA_NAME,并将def操作数的指针改为(指向)新SSA_NAME结点,并将新的SSA_NAME更新到变量var的currdef</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rewrite_stmt</span> <span class="params">(gimple_stmt_iterator *si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gimple *stmt = <span class="built_in">gsi_stmt</span> (*si);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 若当前语句中没有需要被重写的use/def,则直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">rewrite_uses_p</span> (stmt) &amp;&amp; !<span class="built_in">register_defs_p</span> (stmt))     <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">rewrite_uses_p</span> (stmt))        <span class="comment">/* 1.若当前语句中存在需要被重写的use operands,则先重写uses所有的uses操作数 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 遍历当前stmt的real use链表(stmt-&gt;use_ops),其中记录了当前stmt SSA化时需要被修改的USE操作数, 并将其修改为对应变量的当前SSA_NAME定义</span></span><br><span class="line"><span class="comment">       如 y = x; 若此指令解析前x的当前定义为x_1,则这里将指令修改为 y = x_1; */</span></span><br><span class="line">    <span class="built_in">FOR_EACH_SSA_USE_OPERAND</span> (use_p, stmt, iter, SSA_OP_ALL_USES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* use_p-&gt;use 指向此stmt的一个操作数的内存,这里先获取其原始操作数var(即 var = *use_p-&gt;use) */</span></span><br><span class="line">        tree var = <span class="built_in">USE_FROM_PTR</span> (use_p);    </span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 修改此操作数为变量var的当前定义(currdef), 即 *use_p-&gt;use = var_1; (若currdef为var_1) */</span></span><br><span class="line">        <span class="built_in">SET_USE</span> (use_p, <span class="built_in">get_reaching_def</span> (var));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">register_defs_p</span> (stmt))        <span class="comment">/* 2. 若当前语句中存在需要被重写的def operands(见mark_def_sites),则重写所有的defs操作数 */</span></span><br><span class="line">    <span class="built_in">FOR_EACH_SSA_DEF_OPERAND</span> (def_p, stmt, iter, SSA_OP_ALL_DEFS)</span><br><span class="line">    &#123;</span><br><span class="line">      tree var = <span class="built_in">DEF_FROM_PTR</span> (def_p);    <span class="comment">/* 从stmt中的def操作数中读取当前被def的变量的树节点 */</span></span><br><span class="line">      tree name;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">TREE_CODE</span> (var) == SSA_NAME) <span class="keyword">continue</span>;    <span class="comment">/* 忽略SSA_NAME */</span></span><br><span class="line">      <span class="built_in">gcc_checking_assert</span> (<span class="built_in">DECL_P</span> (var));</span><br><span class="line">      ......</span><br><span class="line">      name = <span class="built_in">make_ssa_name</span> (var, stmt);             <span class="comment">/* 为变量var新的def点重新分配一个var的SSA_NAME */</span></span><br><span class="line">      <span class="built_in">SET_DEF</span> (def_p, name);                        <span class="comment">/* 将stmt某操作数中的变量var修改为其SSA_NAME,将定义转化为静态单赋值形式 */</span></span><br><span class="line">      <span class="comment">/* 在支配树的DFS遍历中, 变量var的当前定义此时已经变为了新生成的SSA_NAME name, 将其更新到变量var的currdef中,后续再出现的use则使用此新的def,</span></span><br><span class="line"><span class="comment">         需要注意的是这里,这里会在全局block_defs_stack中保存所有旧的def,在rewrite_dom_walker::after_dom_children会恢复已有修改, 因为</span></span><br><span class="line"><span class="comment">         在支配树的DFS遍历中若有 A=&gt;B, A=&gt;C; 那么分析B时产生的def只作用于B以及其所有sub bb, 而当回到A重新遍历C时要重新使用A中的def继续分析,</span></span><br><span class="line"><span class="comment">         所以这里会有一个入栈操作.after_dom_children中完成出栈操作 */</span></span><br><span class="line">      <span class="built_in">register_new_def</span> (<span class="built_in">DEF_FROM_PTR</span> (def_p), var); </span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 在一个bb及其所有sub bb处理完成后,要恢复此bb中的所有currdef,恢复后才可以继续遍历此bb的兄弟bb,此函数则完成currdef的恢复操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewrite_dom_walker::after_dom_children</span> <span class="params">(basic_block bb ATTRIBUTE_UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (block_defs_stack.<span class="built_in">length</span> () &gt; <span class="number">0</span>)    <span class="comment">/* 遍历def栈中的所有内容, 其插入点是上面的register_new_def函数 */</span></span><br><span class="line">  &#123;</span><br><span class="line">      tree tmp = block_defs_stack.<span class="built_in">pop</span> ();   <span class="comment">/* 获取stack中一个要恢复的SSA_NAME */</span></span><br><span class="line">      tree saved_def, var;</span><br><span class="line">      <span class="keyword">if</span> (tmp == NULL_TREE) <span class="keyword">break</span>;          <span class="comment">/* 遍历当NULL_TREE代表当前bb之前的所有入栈处理完毕,NULL_TREE在栈中作为分隔符分隔各个bb的栈信息 */</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">TREE_CODE</span> (tmp) == SSA_NAME) &#123;    <span class="comment">/* 大多数情况下之前push进来的结点为某个变量的SSA_NAME结点 */</span></span><br><span class="line">        saved_def = tmp;                    <span class="comment">/* 当前需要恢复的SSA_NAME */</span></span><br><span class="line">        var = <span class="built_in">SSA_NAME_VAR</span> (saved_def);     <span class="comment">/* 获取SSA_NAME的原始变量 */</span></span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                              <span class="comment">/* 非SSA_NAME则说明push到原始变量了,说明在当前bb的父节点之前没有变量var的def出现 */</span></span><br><span class="line">       saved_def = <span class="literal">NULL</span>;                    <span class="comment">/* 没有def出现时标记saved_def为空 */</span></span><br><span class="line">       var = tmp;                           <span class="comment">/* tmo即为原始变量 */</span></span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">/* var为原始变量,先找到其var_info结构体,然后恢复其之前定义为 saved_def */</span></span><br><span class="line">     <span class="built_in">get_common_info</span> (var)-&gt;current_def = saved_def;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  此函数负责遍历当前bb在函数CFG中的所有后继bb, 遍历每个后继bb中的每一条phi指令,其目的是为了填充所有bb中所有phi函数的一个参数,</span></span><br><span class="line"><span class="comment">  后继bb中所有phi函数的参数都来自其前驱bb,在其前驱bb SSA化后要立即为其所有后续bb添加SSA化后的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rewrite_add_phi_arguments</span> <span class="params">(basic_block bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  edge e;</span><br><span class="line">  edge_iterator ei;</span><br><span class="line">  <span class="built_in">FOR_EACH_EDGE</span> (e, ei, bb-&gt;succs)    <span class="comment">/* 遍历当前bb的所有直接后继bb,这里遍历的是边 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    gphi *phi;</span><br><span class="line">    gphi_iterator gsi;</span><br><span class="line">    <span class="keyword">for</span> (gsi = <span class="built_in">gsi_start_phis</span> (e-&gt;dest); !<span class="built_in">gsi_end_p</span> (gsi); <span class="built_in">gsi_next</span> (&amp;gsi))    <span class="comment">/* 遍历每个后继bb中的所有phi语句 */</span></span><br><span class="line">    &#123;</span><br><span class="line">      phi = gsi.<span class="built_in">phi</span> ();</span><br><span class="line">      res = <span class="built_in">gimple_phi_result</span> (phi);        <span class="comment">/* 获取phi函数的返回值节点, 也就是此gphi语句中最终def的那个 SSA_NAME */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        SSA_NAME_VAR (res))获取ssa name 对应的var节点, 而get_reaching_def 则获取var变量当前最新的def是哪个变量,</span></span><br><span class="line"><span class="comment">        如res可能是var_1 = φ(,...) 中的var_1(SSA_NAME),而返回的currdef是var的最新定义(可能是var_3,也是个SSA_NAME)           </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      currdef = <span class="built_in">get_reaching_def</span> (<span class="built_in">SSA_NAME_VAR</span> (res));</span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">/* 将currdef记录到 phi函数的第x个参数中(phi.arg[x].def),并增加currdef这个SSA_NAME的use链表(将phi.arg[x].imm_use</span></span><br><span class="line"><span class="comment">        链接到currdef.imm_use使用链中),这里的x是 e这条边在e-&gt;dest结点中的前驱边编号(当前bb在其某后继结点中的前驱结点编号)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="built_in">add_phi_arg</span> (phi, currdef, e, loc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SSA基本概念及原理参考文章</p>
<ul>
<li><a href="https://lwy0518.github.io/2021/12/10/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA%EF%BC%88Intermediate-Representation%EF%BC%89/">程序分析之中间表示</a></li>
<li><a href="https://blog.csdn.net/lidan113lidan/article/details/119336214">gcc中的支配树</a></li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/lidan113lidan/article/details/119336399?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.highlightwordscore&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.highlightwordscore">原文链接</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>SSA</category>
      </categories>
      <tags>
        <tag>SSA</tag>
        <tag>gcc</tag>
        <tag>算法</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题更新</title>
    <url>/2021/12/22/Hexo-NexT-%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h3 id="更新Next主题"><a href="#更新Next主题" class="headerlink" title="更新Next主题"></a>更新Next主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -rf ./themes/next</span><br><span class="line">$ cnpm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<h3 id="安装第三方插件"><a href="#安装第三方插件" class="headerlink" title="安装第三方插件"></a>安装第三方插件</h3><h4 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm install @next-theme/plugins</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim _config.next.yml</span><br></pre></td></tr></table></figure>

<p>复制以下代码到_config.next.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vendors:</span><br><span class="line">  plugins: local</span><br></pre></td></tr></table></figure>

<hr>
<span id="more"></span>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/2021/12/21/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h4><p><img src="https://img2018.cnblogs.com/blog/443934/201810/443934-20181012170211920-1988294604.png"></p>
<hr>
<span id="more"></span>

<blockquote>
<p><a href="https://www.cnblogs.com/hongdada/p/9776547.html">原文链接</a></p>
</blockquote>
<h5 id="源码模式"><a href="#源码模式" class="headerlink" title="源码模式"></a>源码模式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+/</span><br></pre></td></tr></table></figure>

<h5 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[TOC]按回车</span><br></pre></td></tr></table></figure>

<h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+alt+f</span><br></pre></td></tr></table></figure>

<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="built_in">shift</span>+`</span><br></pre></td></tr></table></figure>

<h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+数字</span><br></pre></td></tr></table></figure>

<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+t</span><br></pre></td></tr></table></figure>

<h5 id="选中一行"><a href="#选中一行" class="headerlink" title="选中一行"></a>选中一行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+l</span><br></pre></td></tr></table></figure>

<h5 id="选中单词"><a href="#选中单词" class="headerlink" title="选中单词"></a>选中单词</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+d</span><br></pre></td></tr></table></figure>

<h5 id="选中相同格式的文字"><a href="#选中相同格式的文字" class="headerlink" title="选中相同格式的文字"></a>选中相同格式的文字</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+e</span><br></pre></td></tr></table></figure>

<h5 id="跳转到文章开头"><a href="#跳转到文章开头" class="headerlink" title="跳转到文章开头"></a>跳转到文章开头</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+home</span><br></pre></td></tr></table></figure>

<h5 id="跳转到文章结尾"><a href="#跳转到文章结尾" class="headerlink" title="跳转到文章结尾"></a>跳转到文章结尾</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+end</span><br></pre></td></tr></table></figure>

<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+f</span><br></pre></td></tr></table></figure>

<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+h</span><br></pre></td></tr></table></figure>

<h5 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+u</span><br></pre></td></tr></table></figure>

<h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alt+<span class="built_in">shift</span>+5</span><br></pre></td></tr></table></figure>

<h5 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">直接拖动到指定位置即可或者ctrl+<span class="built_in">shift</span>+i</span><br></pre></td></tr></table></figure>

<h5 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + k</span><br></pre></td></tr></table></figure>

<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + b</span><br></pre></td></tr></table></figure>

<h5 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + i</span><br></pre></td></tr></table></figure>

<h5 id="添加参考文献"><a href="#添加参考文献" class="headerlink" title="添加参考文献"></a>添加参考文献</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[^1] <span class="comment"># ^ 后面添加数字</span></span><br></pre></td></tr></table></figure>





<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>污点分析</title>
    <url>/2021/12/21/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<hr>
<meta name="referrer" content="no-referrer" />

<ul>
<li><a href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">污点分析技术</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">基本原理</a><ul>
<li><a href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%AE%9A%E4%B9%89">污点分析定义</a></li>
<li><a href="#%E8%AF%86%E5%88%AB%E6%B1%A1%E7%82%B9%E6%BA%90%E5%92%8C%E6%B1%87%E8%81%9A%E7%82%B9">识别污点源和汇聚点</a></li>
<li><a href="#%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90">污点传播分析</a><ul>
<li><a href="#%E6%98%BE%E7%A4%BA%E6%B5%81%E5%88%86%E6%9E%90">显示流分析</a></li>
<li><a href="#%E9%9A%90%E5%BC%8F%E6%B5%81%E5%88%86%E6%9E%90">隐式流分析</a></li>
</ul>
</li>
<li><a href="#%E6%97%A0%E5%AE%B3%E5%A4%84%E7%90%86">无害处理</a></li>
</ul>
</li>
<li><a href="#%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF">污点传播分析的关键技术</a><ul>
<li><a href="#%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E4%B8%AD%E7%9A%84%E6%98%BE%E7%A4%BA%E6%B5%81%E5%88%86%E6%9E%90">污点传播中的显示流分析</a><ul>
<li><a href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">静态分析技术</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">动态分析技术</a><ul>
<li><a href="#%E7%A1%AC%E4%BB%B6">硬件</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6">基于软件</a></li>
<li><a href="#%E6%B7%B7%E5%90%88%E5%9E%8B">混合型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E6%B5%81%E5%88%86%E6%9E%90">污点传播中的隐式流分析</a><ul>
<li><a href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">静态分析技术</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">动态分析技术</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p><a href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90">污点分析方法实现实例分析</a></p>
<ul>
<li><p><a href="%E9%9D%99%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">静态污点分析技术</a></p>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90">基于数据流的污点分析</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90">基于依赖关系的污点分析</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90">静态污点分析实例分析</a></li>
</ul>
</li>
<li><p><a href="#%E5%8A%A8%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF">动态污点分析技术</a></p>
<ul>
<li><p><a href="#%E5%8A%A8%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">动态污点分析的方法实现</a></p>
<ul>
<li><a href="#%E6%B1%A1%E7%82%B9%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0">污点数据标记</a></li>
<li><a href="#%E6%B1%A1%E7%82%B9%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA">污点动态跟踪</a></li>
<li><a href="#%E6%B1%A1%E7%82%B9%E8%AF%AF%E7%94%A8%E6%A3%80%E6%9F%A5">污点误用检查</a></li>
</ul>
</li>
<li><p><a href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90">实例分析</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF">污点分析在实际应用中的关键技术</a></p>
<ul>
<li><a href="#%E6%A3%80%E6%B5%8B%E6%99%BA%E8%83%BD%E6%89%8B%E6%9C%BA%E9%9A%90%E7%A7%81%E6%B3%84%E9%9C%B2">检测智能手机隐私泄露</a><ul>
<li><a href="#%E9%9D%99%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90">静态污点分析</a><ul>
<li><a href="#%E7%BB%84%E4%BB%B6%E5%86%85%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90">组件内污点传播分析</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90">组件间污点传播分析</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90">组件与库函数之间的污点传播分析</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90">动态污点分析</a><ul>
<li><a href="#%E7%BB%84%E4%BB%B6%E5%86%85%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90">组件内污点传播分析</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90">组件间污点传播分析</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%87%BD%E6%95%B0%E9%97%B4%E7%9A%84%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD">组件与本地库函数间的污点传播</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#%E6%80%BB%E7%BB%93">总结</a></p>
</li>
<li><p><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="污点分析技术"><a href="#污点分析技术" class="headerlink" title="污点分析技术"></a>污点分析技术</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h4 id="污点分析定义"><a href="#污点分析定义" class="headerlink" title="污点分析定义"></a>污点分析定义</h4><p>污点分析可以抽象成一个**三元组<code>&lt;sources,sinks,sanitizers&gt;</code>**的形式，其中，<code>source</code> 即污点源，代表直接引入不受信任的数据或者机密数据到系统中；<code>sink</code> 即污点汇聚点，代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性)；<code>sanitizer</code> 即无害处理，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。</p>
<p>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理，而直接传播到污点汇聚点。如果不能，说明系统是信息流安全的；否则，说明系统产生了隐私数据泄露或危险数据操作等安全问题。</p>
<p>在漏洞分析中，使用污点分析技术将所感兴趣的数据(通常来自程序的外部输入，假定所有输入都是危险的)标记为污点数据，然后通过跟踪和污点数据相关的信息的流向，可以知道它们是否会影响某些关键的程序操作，进而挖掘程序漏洞。即将程序是否存在某种漏洞的问题转化为污点信息是否会被 Sink 点上的操作所使用的问题。</p>
<p>污点分析常常包括以下几个部分(如图 2 所示)：</p>
<ul>
<li>识别污点信息在程序中的产生点（Source点）并对污点信息进行标记(根据所分析的系统的不同使用定制的识别策略)</li>
<li>污点传播分析(利用特定的规则跟踪分析污点信息在程序中的传播过程)</li>
<li>漏洞检测、无害处理(在一些关键的程序点（Sink点）检测关键的操作是否会受到污点信息的影响)</li>
</ul>
<p><img src="https://ch3nye.top/images/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF1.png" alt="污点分析过程"></p>
<h4 id="识别污点源和汇聚点"><a href="#识别污点源和汇聚点" class="headerlink" title="识别污点源和汇聚点"></a>识别污点源和汇聚点</h4><p>识别污点源和污点汇聚点是污点分析的前提。目前，在不同的应用程序中识别污点源和汇聚点的方法各不相同。缺乏通用方法的原因一方面来自系统模型、编程语言之间的差异。另一方面，污点分析关注的安全漏洞类型不同，也会导致对污点源和污点汇聚点的收集方法迥异。表 1 所示为在 Web 应用程序漏洞检测中的污点源示例[^1]，它们是 Web 框架中关键对象的属性。</p>
<p><img src="https://ch3nye.top/images/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF2.png" alt="污点源示例"></p>
<p><strong>现有的识别污点源和汇聚点的方法可以大致分成 3 类:</strong></p>
<ul>
<li>使用启发式的策略进行标记,例如把来自程序外部输入的数据统称为“污点”数据,保守地认为这些数据有可能包含恶意的攻击数据(如 PHP Aspis)；</li>
<li>根据具体应用程序调用的 API 或者重要的数据类型,手工标记源和汇聚点(如 DroidSafe[^2])；</li>
<li>使用统计或机器学习技术自动地识别和标记污点源及汇聚点[^3]。</li>
</ul>
<h4 id="污点传播分析"><a href="#污点传播分析" class="headerlink" title="污点传播分析"></a>污点传播分析</h4><p>污点传播分析就是分析污点标记数据在程序中的传播途径.按照分析过程中关注的程序依赖关系的不同, 可以将污点传播分析分为<strong>显式流分析</strong>和<strong>隐式流分析</strong>。</p>
<h5 id="显示流分析"><a href="#显示流分析" class="headerlink" title="显示流分析"></a>显示流分析</h5><p>污点传播分析中的显式流分析就是分析污点标记如何随程序中变量之间的<strong>数据依赖关系传播</strong></p>
<p><img src="https://ch3nye.top/images/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF3.png" alt="显示污点分析示例代码"></p>
<p>以图 3 所 示的程序为例,变量 a 和 b 被预定义的污点源函数 source 标记为污点源.假设 a 和 b 被赋予的污点标记分别为taint_a 和 taint_b.由于第 5 行的变量 x 直接数据依赖于变量 a,第 6 行的变量 y 直接数据依赖于变量 b,显式流分析会分别将污点标记 taint_a 和 taint_b 传播给第 5 行的变量 x 和第 6 行的变量 y.又由于 x 和 y 分别可以到达第 7 行和第 8 行的污点汇聚点(用预定义的污点汇聚点函数 sink 标识),图 3 所示的代码存在信息泄漏的问题.我们将在后面具体介绍目前污点传播分析中显式流分析面临的主要挑战和解决方法。</p>
<h5 id="隐式流分析"><a href="#隐式流分析" class="headerlink" title="隐式流分析"></a>隐式流分析</h5><p>污点传播分析中的隐式流分析是分析污点标记如何随程序中变量之间的**控制依赖关系传播,**也就是分析污点标记如何从条件指令传播到其所控制的语句。</p>
<p><img src="https://ch3nye.top/images/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF4.png" alt="隐式污点分析示例代码"></p>
<p>在图 4 所示的程序中,变量 X 是被污点标记的字符串类型变量,变量 Y 和变量 X 之间并<strong>没有直接或间接的数据依赖关系(显式流关系),但 X 上的污点标记可以经过控制依赖隐式地传播到 Y</strong>。</p>
<p>具体来说,由第 4 行的循环条件控制的外层循环顺序地取出 X 中的每一个字符,转化成整型后赋给变量 x,再由第 7 行的循环条件控制的内层循环以累加的方式将 x 的值赋给 y,最后由外层循环将 y 逐一传给 Y.最终,第 12 行的 Y 值和 X 值相同,程序存在信息泄漏问题.但是,如果不进行隐式流污点传播分析,第 12 行 的变量 Y 将不会被赋予污点标记,程序的信息泄漏问题被掩盖.</p>
<p>隐式流污点传播一直以来都是一个重要的问题,和显式流一样,如果不被正确处理,会使污点分析的结果不精确.由于对隐式流污点传播处理不当导致本应被标记的变量没有被标记的问题称为欠污染(under-taint)问题.相反地,由于污点标记的数量过多而导致污点变量大量扩散的问题称为过污染(over-taint)问题.目前,针对隐式流问题的研究重点是尽量减少欠污染和过污染的情况.我们将在后面具体介绍现有技术是如何解决上述问题的。</p>
<h4 id="无害处理"><a href="#无害处理" class="headerlink" title="无害处理"></a>无害处理</h4><p>污点数据在传播的过程中可能会经过无害处理模块,<strong>无害处理模块是指污点数据经过该模块的处理后,数据本身不再携带敏感信息或者针对该数据的操作不会再对系统产生危害</strong>.换言之,带污点标记的数据在经过无害处理模块后,污点标记可以被移除.<strong>正确地使用无害处理可以降低系统中污点标记的数量,提高污点分析的效率,并且避免由于污点扩散导致的分析结果不精确的问题</strong></p>
<p>在应用过程中,为了防止敏感数据被泄露(保护保密性),通常会对敏感数据进行加密处理.此时,<strong>加密库函数应该被识别成无害处理模块</strong>.这一方面是由于库函数中使用了大量的加密算法,导致攻击者很难有效地计算出密码的可能范围;另一方面是加密后的数据不再具有威胁性,继续传播污点标记没有意义。</p>
<p>此外,为了防止外界数据因为携带危险操作而对系统关键区域产生危害(保护完整性),通常会对输入的数据进行验证。</p>
<p>综上,目前对<strong>污点源、污点汇聚点以及无害处理模块的识别通常根据系统或漏洞类型使用定制的方法</strong>.由于这些方法都比较直接,本文将不再进行更深入的探讨.下一节将重点介绍污点传播中的关键技术。</p>
<p>总结，使用污点分析检测程序漏洞的工作原理如下图所示：</p>
<p><img src="https://firmianay.gitbooks.io/ctf-all-in-one/content/pic/5.5_overview.png" alt="污点分析检测程序漏洞的工作原理"></p>
<ul>
<li>基于数据流的污点分析。在不考虑隐式信息流的情况下，可以将污点分析看做针对污点数据的数据流分析。根据污点传播规则跟踪污点信息或者标记路径上的变量污染情况，进而检查污点信息是否影响敏感操作。</li>
<li>基于依赖关系的污点分析。考虑隐式信息流，在分析过程中，根据程序中的语句或者指令之间的依赖关系，检查 Sink 点处敏感操作是否依赖于 Source 点处接收污点信息的操作。</li>
</ul>
<h3 id="污点传播分析的关键技术"><a href="#污点传播分析的关键技术" class="headerlink" title="污点传播分析的关键技术"></a>污点传播分析的关键技术</h3><p>污点传播分析是当前污点分析领域的研究重点.<strong>与程序分析技术相结合,可以获得更加高效、精确的污点分析结果</strong>.根据<strong>分析过程中是否需要运行程序,可以将污点传播分析分为静态污点分析和动态污点分析</strong>.本节主要介绍如何使用动/静态程序分析技术来解决污点传播中的显式流分析和隐式流分析问题</p>
<blockquote>
<p>显式流分析和隐式流分析是从两种不同的角度(数据流和控制流)来观察污点传播</p>
</blockquote>
<h4 id="污点传播中的显式流分析"><a href="#污点传播中的显式流分析" class="headerlink" title="污点传播中的显式流分析"></a>污点传播中的显式流分析</h4><h5 id="静态分析技术"><a href="#静态分析技术" class="headerlink" title="静态分析技术"></a>静态分析技术</h5><p><strong>静态污点传播分析(简称静态污点分析)是指在不运行且不修改代码的前提下,通过分析程序变量间的数据依赖关系来检测数据能否从污点源传播到污点汇聚点</strong>.</p>
<p>静态污点分析的对象一般是<strong>程序的源码</strong>或<strong>中间表示</strong>.可以将对污点传播中<strong>显式流的静态分析问题</strong>转化为对程序中<strong>静态数据依赖的分析</strong>:</p>
<ul>
<li>首先,根据程序中的函数调用关系构建调用图(call graph,简称CG);</li>
<li>然后,在函数内或者函数间根据不同的程序特性进行具体的数据流传播分析.常见的显式流污点传播方式包括<strong>直接赋值传播、通过函数(过程)调用传播以及通过别名(指针)传播</strong></li>
</ul>
<p><strong>以图 5 所示的 Java 程序为例:</strong></p>
<p><img src="https://ch3nye.top/images/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF5.png" alt="静态污点传播示例代码"></p>
<p>第 3 行的变量 b 为初始的污点标记变量,程序第 4 行将一个包含变量 b 的算术表达式的计算结果直接赋给变量 c.由于变量 c 和变量 b 之间具有直接的赋值关系,污点标记可直接从赋值语句右部的变量传播到左部,也就是上述 3种显式流污点传播方式中的<strong>直接赋值传播</strong></p>
<p>接下来,变量 c 被作为实参传递给程序第 5 行的函数 foo,c 上的污点标记也通过<strong>函数调用传播</strong>到 foo 的形参 z,z 的污点标记又通过直接赋值传播到程序第 8 行的 x.f.由于 foo 的另外两个参数对象 x 和 y 都是对对象 a 的引用,二者之间存在别名,因此,x.f的污点标记可以通过<strong>别名传播</strong>到第 9 行的污点汇聚点,程序存在泄漏问题.</p>
<p>目前,<strong>利用数据流分析解决显式污点传播分析中的直接赋值传播和函数调用传播已经相当成熟</strong>,研究的重点是如何为别名传播的分析提供更精确、高效的解决方案.由于精确度越高(上下文敏感、流敏感、域敏感、对象敏感等)的程序静态分析技术往往伴随着越大的时空开销,追求全敏感且高效的别名分析难度较大.又由于静态污点传播分析关注的是从污点源到污点汇聚点之间的数据流关系,分析对象并非完整的程序,而是确定的入口和出口之间的程序片段.这就意味着可<strong>以尝试采用按需(on-demand)定制的别名分析方法来解决显式流态污点分析中的别名传播问题</strong></p>
<h5 id="动态分析技术"><a href="#动态分析技术" class="headerlink" title="动态分析技术"></a>动态分析技术</h5><p>动态污点传播分析(简称动态污点分析)<strong>是指在程序运行过程中,通过实时监控程序的污点数据在系统程序中的传播来检测数据能否从污点源传播到污点汇聚点</strong>.动态污点传播分析首先需要为污点数据扩展一个污点标记(tainted tag)的标签并将其存储在存储单元(内存、寄存器、缓存等)中,然后根据指令类型和指令操作数设计相应的传播逻辑传播污点标记</p>
<p><strong>动态污点传播分析按照实现层次被分为基于硬件、基于软件以及混合型的污点传播分析这3类</strong></p>
<h6 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1.硬件"></a>1.硬件</h6><p><strong>基于硬件的污点传播分析需要定制的硬件支持</strong>,一般需要在原有体系结构上为寄存器或者内存扩展一个标记位,用来存储污点标记</p>
<h6 id="2-基于软件"><a href="#2-基于软件" class="headerlink" title="2.基于软件"></a>2.基于软件</h6><p><strong>基于软件的污点传播分析通过修改程序的二进制代码来进行污点标记位的存储与传播</strong></p>
<p>基于软件的污点传播的<strong>优点在于不必更改处理器等底层的硬件,并且可以支持更高的语义逻辑的安全策略</strong>(利用其更贴近源程序层次的特点),但缺点是使用插桩(instrumentation <strong>在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针</strong>)或代码重写(code rewriting)修改程序往往会给分析系统带来巨大的开销.相反地,基于硬件的污点传播分析虽然可以利用定制硬件降低开销,但通常不能支持更高的语义逻辑的安全策略,并且需要对处理器结构进行重新设计</p>
<h6 id="3-混合型"><a href="#3-混合型" class="headerlink" title="3.混合型"></a>3.混合型</h6><p>混合型的污点分析是对上述两类方法的折中,即,<strong>通过尽可能少的硬件结构改动以保证更高的语义逻辑的安全策略</strong></p>
<p>目前,针对动态污点传播分析的研究工作关注的<strong>首要问题是如何设计有效的污点传播逻辑,以确保精确的污点传播分析</strong></p>
<h4 id="污点传播中的隐式流分析"><a href="#污点传播中的隐式流分析" class="headerlink" title="污点传播中的隐式流分析"></a>污点传播中的隐式流分析</h4><p>污点传播分析中的隐式流分析就是<strong>分析污点数据如何通过控制依赖进行传播</strong>,如果忽略了对隐式流污点传播的分析,则会导致欠污染的情况;如果对隐式流分析不当,那么除了欠污染之外,还可能出现过污染的情况.与显式流分析类似,<strong>隐式流分析技术同样也可以分为静态分析和动态分析两类</strong></p>
<h5 id="静态分析技术-1"><a href="#静态分析技术-1" class="headerlink" title="静态分析技术"></a>静态分析技术</h5><p><strong>静态隐式流分析面临的核心问题是精度与效率不可兼得的问题</strong>.精确的隐式流污点传播分析需要分析每一个分支控制条件是否需要传播污点标记.<strong>路径敏感的数据流分析往往会产生路径爆炸问题</strong>,导致开销难以接受.为了降低开销,一种简单的静态传播(标记)分支语句的污点标记方法<strong>是将控制依赖于它的语句全部进行污点标记</strong>,但该方法会导致一些并不携带隐私数据的变量被标记,导致过污染情况的发生.过污染会引起污点的大量扩散,最终导致用户得到的报告中信息过多,难以使用</p>
<h5 id="动态分析技术-1"><a href="#动态分析技术-1" class="headerlink" title="动态分析技术"></a>动态分析技术</h5><p><strong>动态隐式流分析关注的首要问题是如何确定污点控制条件下需要标记的语句的范围</strong>.由于动态执行轨迹并不能反映出被执行的指令之间的控制依赖关系,<strong>目前的研究多采用离线的静态分析辅助判断动态污点传播中的隐式流标记范围</strong>.Clause等人提出,利用离线静态分析得到的控制流图节点间的后支配(post-dominate)关系来解决动态污点传播中的隐式流标记问题</p>
<p><strong>例如,如图 6(a)所示</strong>,程序第 3 行的分支语句被标记为污点源,当document.cookie 的值为 abc 时,会发生污点数据泄露.根据基于后支配关系的标记算法,会对该示例第 4 行语句的指令目的地,即 x 的值进行污点标记.(ps:因为根据该分支控制下的语句的执行结果可以判定污染源document.cookie的值,造成污点数据泄露)</p>
<p><img src="https://ch3nye.top/images/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF7.png" alt="隐式流污点分析示例代码"></p>
<p><strong>动态分析面临的第 2 个问题是由于部分泄漏(partially leaked)导致的漏报</strong>.部分泄漏是指污点信息通过<strong>动态未执行部分进行传播并泄漏</strong>.Vogt等人发现,只动态地标记分支条件下的语句会发生这种情况</p>
<p><strong>仍以图 6(a)中的程序为例</strong>:当第 3 行的控制条件被执行时,对应的 x 会被标记.此时,x 的值为 true,而 y 值没有变化,仍然为 false.在后续执行过程中,由于第 9行的污点汇聚点不可达,而第 12 行的汇聚点可达,动态分析没有检测到污点数据泄漏.但攻击者由第 11 行 y 等于 false 的条件能够反推出程序执行了第 3 行的分支条件,程序实际上存在信息泄漏的问题.这个信息泄露是由第 6 行未被执行到的 y 的赋值语句所触发的.因此,y 应该被动态污点传播分析所标记.为了解决部分泄漏问题,Vogt等人在传统的动态污点分析基础上增加了离线的静态分析,以跟踪动态执行过程中的控制依赖关系,<strong>对污点分支控制范围内的所有赋值语句中的变量都进行标记</strong>.具体到图 6(a)所示的例子,就是第 4 行和第 6 行中的变量均会被污点标记.但是,Vogt 等人的方法仍然会产生过污染的情况.</p>
<p><strong>动态分析需要解决的第 3 个问题是如何选择合适的污点标记分支进行污点传播</strong>.鉴于单纯地将所有包含污点标记的分支进行传播会导致过污染的情况,可以根据信息泄漏范围的不同,定量地设计污点标记分支的选择策略.</p>
<p><strong>以图 6(b)所示的程序为例</strong>,第 2 行的变量 a 为初始的污点标记变量.第 5 行、第 7 行、第 9 行均为以 a作为源操作数的污点标记的分支.如果传播策略为只要分支指令中包含污点标记就对其进行传播,那么第 5 行、第 7 行、第 9 行将分别被传播给第 6 行、第 8 行、第 10 行,并最终传播到第 12 行的污点汇聚点.如果对这段程序进行深入分析会发现,3个分支条件所提供的信息值(所能泄露的信息范围)并不相同,分别是 a 等于 10、a大于 10 且小于或等于 13(将 w 值代入计算)以及 a 小于 10.对于 a 等于 10 的情况,攻击者可以根据第 12 行泄漏的 x 的值直接还原出污点源处 a 的值(<strong>这类分支也被称为能够保存完整信息的分支</strong>);对于 a 大于 10 且小于或等于 13 的情况,攻击者也只需要尝试 3 次就可以还原信息;而对于 a 小于 10 的情况,攻击者所获得的不确定性较大,成功还原信息的几率显著低于前两种,对该分支进行污点传播的实际意义不大.</p>
<p>Bao等人<strong>只将严格控制依赖(strict control dependence)识别成需要污点传播的分支</strong>,其中,<strong>严格控制依赖即分支条件表达式的两端具有常数差异的分支</strong>.但是,Bao 的方法只适用于能够在编译阶段计算出常数差异的分支.</p>
<h3 id="污点分析方法实现"><a href="#污点分析方法实现" class="headerlink" title="污点分析方法实现"></a>污点分析方法实现</h3><h4 id="静态污点分析技术"><a href="#静态污点分析技术" class="headerlink" title="静态污点分析技术"></a>静态污点分析技术</h4><p>静态污点分析系统首先对程序代码进行解析，获得程序代码的中间表示，然后在中间表示的基础上对程序代码进行控制流分析等辅助分析，以获得需要的控制流图、调用图等。在辅助分析的过程中，系统可以利用污点分析规则在中间表示上识别程序中的 Source 点和 Sink 点。最后检测系统根据污点分析规则，利用静态污点分析检查程序是否存在污点类型的漏洞。</p>
<h5 id="基于数据流的污点分析"><a href="#基于数据流的污点分析" class="headerlink" title="基于数据流的污点分析"></a>基于数据流的污点分析</h5><p>在基于数据流的污点分析中，常常需要一些辅助分析技术，例如别名分析、取值分析等，来提高分析精度。辅助分析和污点分析交替进行，通常沿着程序路径的方向分析污点信息的流向，检查 Source 点处程序接收的污点信息是否会影响到 Sink 点处的敏感操作。</p>
<p><strong>过程内的分析</strong>中，按照一定的顺序分析过程内的每一条语句或者指令，进而分析污点信息的流向。</p>
<ul>
<li>记录污点信息。在静态分析层面，程序变量的污染情况为主要关注对象。为记录污染信息，通常为变量添加一个污染标签。最简单的就是一个布尔型变量，表示变量是否被污染。更复杂的标签还可以记录变量的污染信息来自哪些 Source 点，甚至精确到 Source 点接收数据的哪一部分。当然也可以不使用污染标签，这时我们通过对变量进行跟踪的方式达到分析污点信息流向的目的。例如使用栈或者队列来记录被污染的变量。</li>
<li>程序语句的分析。在确定如何记录污染信息后，将对程序语句进行静态分析。通常我们主要关注赋值语句、控制转移语句以及过程调用语句三类。<ul>
<li>赋值语句。<ul>
<li>对于简单的赋值语句，形如 <code>a = b</code> 这样的，记录语句左端的变量和右端的变量具有相同的污染状态。程序中的常量通常认为是未污染的，如果一个变量被赋值为常量，在不考虑隐式信息流的情况下，认为变量的状态在赋值后是未污染的。</li>
<li>对于形如 <code>a = b + c</code> 这样带有二元操作的赋值语句，通常规定如果右端的操作数只要有一个是被污染的，则左端的变量是污染的（除非右端计算结果为常量）。</li>
<li>对于和数组元素相关的赋值，如果可以通过静态分析确定数组下标的取值或者取值范围，那么就可以精确地判断数组中哪个或哪些元素是污染的。但通常静态分析不能确定一个变量是污染的，那么就简单地认为整个数组都是污染的。</li>
<li>对于包含字段或者包含指针操作的赋值语句，常常需要用到指向分析的分析结果。</li>
</ul>
</li>
<li>控制转移语句。<ul>
<li>在分析条件控制转移语句时，首先考虑语句中的路径条件可能是包含对污点数据的限制，在实际分析中常常需要识别这种限制污点数据的条件，以判断这些限制条件是否足够包含程序不会受到攻击。如果得出路径条件的限制是足够的，那么可以将相应的变量标记为未污染的。</li>
<li>对于循环语句，通常规定循环变量的取值范围不能受到输入的影响。例如在语句 <code>for (i = 1； i &lt; k； i++)&#123;&#125;</code> 中，可以规定循环的上界 k 不能是污染的。</li>
</ul>
</li>
<li>过程调用语句。<ul>
<li>可以使用过程间的分析或者直接应用过程摘要进行分析。污点分析所使用的过程摘要主要描述怎样改变与该过程相关的变量的污染状态，以及对哪些变量的污染状态进行检测。这些变量可以是过程使用的参数、参数的字段或者过程的返回值等。例如在语句 <code>flag = obj。method(str)；</code> 中，str 是污染的，那么通过过程间的分析，将变量 obj 的字段 str 标记为污染的，而记录方法的返回值的变量 flag 标记为未污染的。</li>
<li>在实际的过程间分析中，可以对已经分析过的过程构建过程摘要。例如前面的语句，其过程摘要描述为：方法 method 的参数污染状态决定其接收对象的实例域 str 的污染状态，并且它的返回值是未受污染的。那么下一次分析需要时，就可以直接应用摘要进行分析。</li>
</ul>
</li>
</ul>
</li>
<li>代码的遍历。一般情况下，常常使用流敏感的方式或者路径敏感的方式进行遍历，并分析过程中的代码。如果使用流敏感的方式，可以通过对不同路径上的分析结果进行汇集，以发现程序中的数据净化规则。如果使用路径敏感的分析方式，则需要关注路径条件，如果路径条件中涉及对污染变量取值的限制，可认为路径条件对污染数据进行了净化，还可以将分析路径条件对污染数据的限制进行记录，如果在一条程序路径上，这些限制足够保证数据不会被攻击者利用，就可以将相应的变量标记为未污染的。</li>
</ul>
<p><strong>过程间的分析</strong>与数据流过程间分析类似，使用自底向上的分析方法，分析调用图中的每一个过程，进而对程序进行整体的分析。</p>
<h5 id="基于依赖关系的污点分析"><a href="#基于依赖关系的污点分析" class="headerlink" title="基于依赖关系的污点分析"></a>基于依赖关系的污点分析</h5><p>在基于依赖关系的污点分析中，首先利用程序的中间表示、控制流图和过程调用图构造程序完整的或者局部的程序的依赖关系。在分析程序依赖关系后，根据污点分析规则，检测 Sink 点处敏感操作是否依赖于 Source 点。</p>
<p>分析程序依赖关系的过程可以看做是构建程序依赖图的过程。程序依赖图是一个有向图。它的节点是程序语句，它的有向边表示程序语句之间的依赖关系。程序依赖图的有向边常常包括数据依赖边和控制依赖边。在构建有一定规模的程序的依赖图时，需要按需地构建程序依赖关系，并且优先考虑和污点信息相关的程序代码。</p>
<h5 id="静态污点分析实例分析"><a href="#静态污点分析实例分析" class="headerlink" title="静态污点分析实例分析"></a>静态污点分析实例分析</h5><p>在使用污点分析方法检测程序漏洞时，污点数据相关的程序漏洞是主要关注对象，如 SQL 注入漏洞、命令注入漏洞和跨站脚本漏洞等。</p>
<p>下面是一个存在 SQL 注入漏洞 ASP 程序的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Set pwd = &quot;bar&quot;</span><br><span class="line">    Set sql1 = &quot;SELECT companyname FROM &quot; &amp; Request。Cookies(&quot;hello&quot;)</span><br><span class="line">    Set sql2 = Request。QueryString(&quot;foo&quot;)</span><br><span class="line">    MySqlStuff pwd， sql1， sql2</span><br><span class="line">    Sub MySqlStuff(password， cmd1， cmd2)</span><br><span class="line">    Set conn = Server。CreateObject(&quot;ADODB。Connection&quot;)</span><br><span class="line">    conn。Provider = &quot;Microsoft。Jet。OLEDB。4。0&quot;</span><br><span class="line">    conn。Open &quot;c：/webdata/foo。mdb&quot;， &quot;foo&quot;， password</span><br><span class="line">    Set rs = conn。Execute(cmd2)</span><br><span class="line">    Set rs = Server。CreateObject(&quot;ADODB。recordset&quot;)</span><br><span class="line">    rs。Open cmd1， conn</span><br><span class="line">    End Sub</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>首先对这段代码表示为一种三地址码的形式，例如第 3 行可以表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;SELECT companyname FROM &quot;</span><br><span class="line">b = &quot;hello&quot;</span><br><span class="line">param0 Request</span><br><span class="line">param1 b</span><br><span class="line">callCookies</span><br><span class="line">return c</span><br><span class="line">sql1 = a &amp; c</span><br></pre></td></tr></table></figure>

<p>解析完毕后，需要对程序代码进行控制流分析，这里只包含了一个调用关系（第 5 行）。</p>
<p>接下来，需要识别程序中的 Source 点和 Sink 点以及初始的被污染的数据。</p>
<p>具体的分析过程如下：</p>
<ul>
<li>调用 Request。Cookies(“hello”) 的返回结果是污染的，所以变量 sql1 也是污染的。</li>
<li>调用 Request。QueryString(“foo”) 的返回结果 sql2 是污染的。</li>
<li>函数 MySqlStuff 被调用，它的参数 sql1，sql2 都是污染的。分了分析函数的处理过程，根据第 6 行函数的声明，标记其参数 cmd1，cmd2 是污染的。</li>
<li>第 10 行是程序的 Sink 点，函数 conn。Execute 执行 SQL 操作，其参数 cmd2 是污染的，进而发现污染数据从 Source 点传播到 Sink 点。因此，认为程序存在 SQL 注入漏洞</li>
</ul>
<h4 id="动态污点分析技术"><a href="#动态污点分析技术" class="headerlink" title="动态污点分析技术"></a>动态污点分析技术</h4><p>动态污点分析是在程序运行的基础上，对数据流或控制流进行监控，从而实现对数据在内存中的显式传播、数据误用等进行跟踪和检测。动态污点分析与静态污点分析的唯一区别在于静态污点分析技术在检测时并不真正运行程序，而是通过模拟程序的执行过程来传播污点标记，而动态污点分析技术需要运行程序，同时实时传播并检测污点标记。</p>
<p>动态污点分析技术可分为三个部分：</p>
<ul>
<li>污点数据标记：程序攻击面是程序接受输入数据的接口集，一般由程序入口点和外部函数调用组成。在污点分析中，来自外部的输入数据会被标记为污点数据。根据输入数据来源的不同，可分为三类：网络输入、文件输入和输入设备输入。</li>
<li>污点动态跟踪：在污点数据标记的基础上，对进程进行指令粒度的动态跟踪分析，分析每一条指令的效果，直至覆盖整个程序的运行过程，跟踪数据流的传播。<ul>
<li>动态污点跟踪通常基于以下三种机制<ul>
<li>动态代码插桩：可以跟踪单个进程的污点数据流动，通过在被分析程序中插入分析代码，跟踪污点信息流在进程中的流动方向。</li>
<li>全系统模拟：利用全系统模拟技术，分析模拟系统中每条指令的污点信息扩散路径，可以跟踪污点数据在操作系统内的流动。</li>
<li>虚拟机监视器：通过在虚拟机监视器中增加分析污点信息流的功能，跟踪污点数据在整个客户机中各个虚拟机之间的流动。</li>
</ul>
</li>
<li>污点动态跟踪通常需要影子内存（shadow memory）来映射实际内存的污染情况，从而记录内存区域和寄存器是否是被污染的。对每条语句进行分析的过程中，污点跟踪攻击根据影子内存判断是否存在污点信息的传播，从而对污点信息进行传播并将传播结果保存于影子内存中，进而追踪污点数据的流向。</li>
<li>一般情况下，数据移动类和算数类指令都将造成显示的信息流传播。为了跟踪污点数据的显示传播，需要在每个数据移动指令和算数指令执行前做监控，当指令的结果被其中一个操作数污染后，把结果数据对应的影子内存设置为一个指针，指向源污染点操作数指向的数据结构。</li>
</ul>
</li>
<li>污点误用检查：在正确标记污点数据并对污点数据的传播进行实时跟踪后，就需要对攻击做出正确的检测即检测污点数据是否有非法使用的情况。</li>
</ul>
<p>动态污点分析的优缺点：</p>
<ul>
<li>优点：误报率较低，检测结果的可信度较高。</li>
<li>缺点：<ul>
<li>漏报率较高：由于程序动态运行时的代码覆盖率决定的。</li>
<li>平台相关性较高：特定的动态污点分析工具只能够解决在特定平台上运行的程序。</li>
<li>资源消耗大：包括空间上和时间上。</li>
</ul>
</li>
</ul>
<h5 id="动态污点分析的方法实现"><a href="#动态污点分析的方法实现" class="headerlink" title="动态污点分析的方法实现"></a>动态污点分析的方法实现</h5><h6 id="1-污点数据标记"><a href="#1-污点数据标记" class="headerlink" title="1.污点数据标记"></a>1.污点数据标记</h6><p>污点数据通常主要是指软件系统所接受的外部输入数据，在计算机中，这些数据可能以内存临时数据的形式存储，也可能以文件的形式存储。当程序需要使用这些数据时，一般通过函数或系统调用来进行数据访问和处理，因此只需要对这些关键函数进行监控，即可得到程序读取或输出了什么污点信息。另外对于网络输入，也需要对网络操作函数进行监控。</p>
<p>识别出污点数据后，需要对污点进行标记。污点生命周期是指在该生命周期的时间范围内，污点被定义为有效。污点生命周期开始于污点创建时刻，生成污点标记，结束于污点删除时刻，清除污点标记。</p>
<ul>
<li>污点创建<ul>
<li>将来自于非可靠来源的数据分配给某寄存器或内存操作数时</li>
<li>将已经标记为污点的数据通过运算分配给某寄存器或内存操作数时</li>
</ul>
</li>
<li>污点删除<ul>
<li>将非污点数据指派给存放污点的寄存器或内存操作数时</li>
<li>将污点数据指派给存放污点的寄存器或内存地址时，此时会删除原污点，并创建新污点</li>
<li>一些会清除污点痕迹的算数运算或逻辑运算操作时</li>
</ul>
</li>
</ul>
<h6 id="2-污点动态跟踪"><a href="#2-污点动态跟踪" class="headerlink" title="2.污点动态跟踪"></a>2.污点动态跟踪</h6><p>当污点数据从一个位置传递到另一个位置时，则认为产生了污点传播。污点传播规则：</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>传播规则</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td>拷贝或移动指令</td>
<td>T(a)&lt;-T(b)</td>
<td>mov a， b</td>
</tr>
<tr>
<td>算数运算指令</td>
<td>T(a)&lt;-T(b)</td>
<td>add a， b</td>
</tr>
<tr>
<td>堆栈操作指令</td>
<td>T(esp)&lt;-T(a)</td>
<td>push a</td>
</tr>
<tr>
<td>拷贝或移动类函数调用指令</td>
<td>T(dst)&lt;-T(src)</td>
<td>call memcpy</td>
</tr>
<tr>
<td>清零指令</td>
<td>T(a)&lt;-false</td>
<td>xor a， a</td>
</tr>
</tbody></table>
<p>注：T(x) 的取值分为 true 和 false 两种，取值为 true 时表示 x 为污点，否则 x 不是污点。</p>
<p>对于污点信息流，通过污点跟踪和函数监控，已经能够进行污点信息流流动方向的分析。但由于缺少对象级的信息，仅靠指令级的信息流动并不能完全给出要分析的软件的确切行为。因此，需要在函数监控的基础上进行视图重建，如获取文件对象和套接字对象的详细信息，以方便进一步的分析工作。</p>
<p>根据漏洞分析的实际需求，污点分析应包括两方面的信息：</p>
<ul>
<li>污点的传播关系，对于任一污点能够获知其传播情况。</li>
<li>对污点数据进行处理的所有指令信息，包括指令地址、操作码、操作数以及在污点处理过程中这些指令执行的先后顺序等。</li>
</ul>
<p>污点动态跟踪的实现通常使用：</p>
<ul>
<li>影子内存：真实内存中污点数据的镜像，用于存放程序执行的当前时刻所有的有效污点。</li>
<li>污点传播树：用于表示污点的传播关系。</li>
<li>污点处理指令链：用于按时间顺序存储与污点数据处理相关的所有指令。</li>
</ul>
<p>当遇到会引起污点传播的指令时，首先对指令中的每个操作数都通过污点快速映射查找影子内存中是否存在与之对应的影子污点从而确定其是否为污点数据，然后根据污点传播规则得到该指令引起的污点传播结果，并将传播产生的新污点添加到影子内存和污点传播树中，同时将失效污点对应的影子污点删除。同时由于一条指令是否涉及污点数据的处理，需要在污点分析过程中动态确定，因此需要在污点处理指令链中记录污点数据的指令信息。</p>
<h6 id="3-污点误用检查"><a href="#3-污点误用检查" class="headerlink" title="3.污点误用检查"></a>3.污点误用检查</h6><p>污点敏感点，即 Sink 点，是污点数据有可能被误用的指令或系统调用点，主要分为：</p>
<ul>
<li>跳转地址：检查污点数据是否用于跳转对象，如返回地址、函数指针、函数指针偏移等。具体操作是在每个跳转类指令（如call、ret、jmp等）执行前进行监控分析，保证跳转对象不是污点数据所在的内存地址。</li>
<li>格式化字符串：检查污点数据是否用作printf系列函数的格式化字符串参数。</li>
<li>系统调用参数：检查特殊系统调用的特殊参数是否为污点数据。</li>
<li>标志位：跟踪标志位是否被感染，及被感染的标志位是否用于改变程序控制流。</li>
<li>地址：检查数据移动类指令的地址是否被感染。</li>
</ul>
<p>在进行污点误用检查时，通常需要根据一些漏洞模式来进行检查，首先需要明确常见漏洞在二进制代码上的表现形式，然后将其提炼成漏洞模式，以更有效地指导自动化的安全分析。</p>
<h5 id="动态污点分析的实例分析"><a href="#动态污点分析的实例分析" class="headerlink" title="动态污点分析的实例分析"></a>动态污点分析的实例分析</h5><p>下面我们来看一个使用动态污点分析的方法检测缓冲区溢出漏洞的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">15</span>]；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in strncpy， source： %s\n&quot;</span>， str)；</span><br><span class="line">    <span class="built_in">strncpy</span>(temp， str， <span class="built_in">strlen</span>(str))；        <span class="comment">// Sink 点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc， <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> source[<span class="number">30</span>]；</span><br><span class="line">    gets(source)；                           <span class="comment">// Source 点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(source) &lt; <span class="number">30</span>)</span><br><span class="line">        fun(source)；</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;too long string， %s\n&quot;</span>， source)；</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞很明显， 调用 strncpy 函数存在缓冲区溢出。</p>
<p>程序接受外部输入字符串的二进制代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x08048609 &lt;+51&gt;：    lea    eax，[ebp-0x2a]</span><br><span class="line">0x0804860c &lt;+54&gt;：    push   eax</span><br><span class="line">0x0804860d &lt;+55&gt;：    call   0x8048400 &lt;gets@plt&gt;</span><br><span class="line">...</span><br><span class="line">0x0804862c &lt;+86&gt;：    lea    eax，[ebp-0x2a]</span><br><span class="line">0x0804862f &lt;+89&gt;：    push   eax</span><br><span class="line">0x08048630 &lt;+90&gt;：    call   0x8048566 &lt;fun&gt;</span><br></pre></td></tr></table></figure>

<p>程序调用 strncpy 函数的二进制代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x080485a1 &lt;+59&gt;：    push   DWORD PTR [ebp-0x2c]</span><br><span class="line">0x080485a4 &lt;+62&gt;：    call   0x8048420 &lt;strlen@plt&gt;</span><br><span class="line">0x080485a9 &lt;+67&gt;：    add    esp，0x10</span><br><span class="line">0x080485ac &lt;+70&gt;：    sub    esp，0x4</span><br><span class="line">0x080485af &lt;+73&gt;：    push   eax</span><br><span class="line">0x080485b0 &lt;+74&gt;：    push   DWORD PTR [ebp-0x2c]</span><br><span class="line">0x080485b3 &lt;+77&gt;：    lea    eax，[ebp-0x1b]</span><br><span class="line">0x080485b6 &lt;+80&gt;：    push   eax</span><br><span class="line">0x080485b7 &lt;+81&gt;：    call   0x8048440 &lt;strncpy@plt&gt;</span><br></pre></td></tr></table></figure>

<p>首先，在扫描该程序的二进制代码时，能够扫描到 <code>call &lt;gets@plt&gt;</code>，该函数会读入外部输入，即程序的攻击面。确定了攻击面后，我们将分析污染源数据并进行标记，即将 <code>[ebp-0x2a]</code> 数组（即源程序中的source）标记为污点数据。程序继续执行，该污染标记会随着该值的传播而一直传递。在进入 <code>fun()</code> 函数时，该污染标记通过形参实参的映射传递到参数 <code>str</code> 上。然后运行到 Sink 点函数 <code>strncpy()</code>。该函数的第二个参数即 <code>str</code> 和 第三个参数 <code>strlen(str)</code> 都是污点数据。最后在执行 <code>strncpy()</code> 函数时，若设定了相应的漏洞规则（目标数组小于源数组），则漏洞规则将被触发，检测出缓冲区溢出漏洞。</p>
<h3 id="污点分析在实际应用中的关键技术"><a href="#污点分析在实际应用中的关键技术" class="headerlink" title="污点分析在实际应用中的关键技术"></a>污点分析在实际应用中的关键技术</h3><p>污点分析被广泛地应用在系统隐私数据泄露、安全漏洞等问题的检测中.在实际应用过程中,由于系统框架、语言特性等方面的差异,通用的污点分析技术往往难以适用.比如:系统框架的高度模块化以及各模块之间复杂的调用关系导致污点源到汇聚点的传播路径变得复杂、庞大,采用通用的污点分析技术可能面临开销难以接受的问题;通用的污点分析技术对新的语言特性支持有限等.为此,需要针对不同的应用场景,对通用的污点分析技术进行扩展或定制</p>
<p>本节以两个代表性的应用场景——智能手机的隐私泄漏检测和Web应用安全漏洞检测为切入点,总结近10年来污点分析技术在上述领域的应用实践过程中所面临的问题和关键解决技术</p>
<h4 id="检测智能手机隐私泄露"><a href="#检测智能手机隐私泄露" class="headerlink" title="检测智能手机隐私泄露"></a>检测智能手机隐私泄露</h4><p>针对Android的污点传播分析也围绕组件展开,按照传播可能通过的模块的不同,分为<strong>组件内污点传播、组件间污点传播、组件与库函数之间的污点传播这3类</strong>(如图7所示).接下来将分别介绍针对这3类传播问题的静态和动态污点传播分析技术</p>
<p><img src="https://ch3nye.top/images/image-20201222115622305.png" alt="Android上的污点传播分类"></p>
<h5 id="静态污点分析"><a href="#静态污点分析" class="headerlink" title="静态污点分析"></a>静态污点分析</h5><h6 id="1-组件内污点传播分析"><a href="#1-组件内污点传播分析" class="headerlink" title="1.组件内污点传播分析"></a>1.组件内污点传播分析</h6><p>组件内部污点分析面临的主要问题是如何构建完整的分析模型.不同于传统的C/C++程序(有唯一的Main函数入口),Android应用程序存在有多个入口函数的情况.这个情况源于Android应用程序复杂的运行生命周期(例如onCreate,onStart,onResume,onPause等)以及程序中大量存在的回调函数和异步函数调用.由于任何的程序入口都有可能是隐私数据的来源,在静态的污点分析开始之前必须构建完整的应用程序模型,以确保程序中每一种可能的执行路径都会被静态污点传播分析覆盖到</p>
<p>LeakMiner[^4]和CHEX[^5]尝试使用增量的方法构建系统调用图.</p>
<p>Arzt等人设计的FlowDroid[^6]提出了一种更系统的构建Android程序完整分析模型的方法:首先,通过XML配置文件提取与Android生命周期相关的入口函数,将这些方法作为节点,并根据Android生命周期构建调用图(如图8所示);其次,对于生命周期内的回调函数,在该调用图的基础上增加不透明谓词节点(即图8中菱形的P节点);然后,增量式地将回调函数加入这个函数调用图;最后,将调用图上所有的执行入口连接到一个虚假的Main函数上.FlowDroid中的一次合法的执行,就是对调用图进行的一次遍历</p>
<p><img src="https://ch3nye.top/images/image-20201222154039907.png" alt="FlowDroid使用控制流图示例"></p>
<p>Gordon等人[^7]提出的DroidSafe使用Android设备实现(Android device implementation)来构建Android的完整分析模型.Android设备实现是对Android运行环境的一个简单模拟,它使用Java语言,结合Android Open Source Porject(AOSP),实现了与原Android接口语义等价的模型,并使用精确分析存根(accurate analysis stub)将AOSP代码之外的函数加入到模型中</p>
<h6 id="2-组件间污点传播分析"><a href="#2-组件间污点传播分析" class="headerlink" title="2.组件间污点传播分析"></a>2.组件间污点传播分析</h6><p>即使正确分析了组件内的数据流关系,污点数据仍然可能通过组件间的数据流来传递,从而造成信息泄露.如上图7左侧所示,即使保证了对组件A内部污点传播的精确分析,组件A仍然可能通过调用方法startActivityforResult()将信息传递给组件B,再通过组件B产生泄露.因此,针对Android应用的污点分析还需要分析出组件间所有可能的数据流信息.组件间通信是通过组件发送Intent消息对象完成的.<strong>Intent按照参数字段是否包含目标组件名称分为显式Intent和隐式Intent</strong>.如图9所示:显式Intent对象使用一个包含目标组件名称的参数显式地指定通信的下一个组件;隐式Intent使用action,category等域隐式地让Android系统通过Intent Filter自动选择一个组件调用.目前,解决该问题的主要思想是利用Intent参数信息分析组件间的数据流</p>
<p><img src="https://ch3nye.top/images/image-20201222154544009.png" alt="显示和隐式Intent组件间通信"></p>
<p><strong>解决组件间数据流的前提是解析Intent的目的地</strong>,解析Intent目的地包括解析显式Intent的目的地和隐式Intent的目的地.由于显式Intent的目的地可以直接通过初始化Intent的地址字符串参数获得,目前,<strong>解析显式Intent目的地的常用方法是使用字符串分析</strong>工具提取Intent中字符串参数的信息.</p>
<p>解析隐式Intent目的地的主要方法是<strong>分析配置文件信息与Intent Filter注册器之间的映射关系,建立发送Intent组件和接受Intent组件之间的配对关系</strong>.在解析出Intent目的地之后,问题的重点转移到如何提高组件间数据流分析的精度上.</p>
<p>Klieber等人尝试在已经建立好的组件内污点分析的基础上,结合推导规则来分析组件间数据流.在分析之前,需要收集组件内部的污点源和汇聚点以及组件内Intent的发送目的地标签等信息.表4和表5给出了推导规则的前提定义和具体的推导规则,其中,一次完整的分析是指根据已知组件内部的信息src→sink<em>s<strong>r</strong>c</em>→<em>s<strong>i</strong>n**k</em>以及推导规则识别所有src′→sink′<em>s<strong>r</strong>c</em>′→<em>s<strong>i</strong>n**k</em>′的流集合</p>
<p>Octeau等人尝试使用现有的程序分析方法提高组件间数据流分析的精度,他们将组件间数据流分析问题转化成IDE(interprocedural distributive environment)问题[58]进行求解.DroidSafe设计了一种对象敏感的别名分析技术,在此基础上提供的精度优化方法包括:提取Intent的目的地的字符串参数、将Intent目的地的初始化函数嵌入到目的组件当中以提高别名分析的精度,同时,增加处理Android Service的支持</p>
<p><img src="https://ch3nye.top/images/image-20201222120307884.png" alt="推导规则前提定义"></p>
<p><img src="https://ch3nye.top/images/image-20201222120316977.png" alt="污点分析推到规则"></p>
<h6 id="组件与库函数之间的污点传播分析"><a href="#组件与库函数之间的污点传播分析" class="headerlink" title="组件与库函数之间的污点传播分析"></a>组件与库函数之间的污点传播分析</h6><p>组件与库函数之间的污点传播分析面临的<strong>主要问题</strong>包括对Android库函数自身庞大的代码量的分析以及组件和某些库函数使用的实现语言不同(Android组件通常用Java实现,而本地库则采用C/C++代码编写)这两方面</p>
<h5 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a>动态污点分析</h5><p><strong>Android系统中的动态污点同样需要分析组件内污点传播、组件间污点传播以及组件代码与本地库之间的污点传播</strong>.动态污点分析面临的<strong>主要挑战是系统信息除了在系统内部通过DEX指令传播以外,还会经过其他的通道,如本地库、网络、文件等</strong>.</p>
<h6 id="1-组件内的污点传播"><a href="#1-组件内的污点传播" class="headerlink" title="1.组件内的污点传播"></a>1.组件内的污点传播</h6><h6 id="2-组件间的污点传播"><a href="#2-组件间的污点传播" class="headerlink" title="2.组件间的污点传播"></a>2.组件间的污点传播</h6><h6 id="3-组件与本地库函数间的污点传播"><a href="#3-组件与本地库函数间的污点传播" class="headerlink" title="3.组件与本地库函数间的污点传播"></a>3.组件与本地库函数间的污点传播</h6><p>包括污点数据通过本地库代码或文件进行传播.TaintDroid通过设计后置条件对本地代码的函数进行污点传播.后置条件为:</p>
<p>(a) 所有本地代码访问的外部变量都会被标记上污点标签;</p>
<p>(b) 根据预定义规则将被赋值的函数返回值也标记上污点标签</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>污点分析作为信息流分析的一种实践技术,被广泛应用于互联网及移动终端平台上应用程序的信息安全保障中.本文介绍了污点分析的基本原理和通用技术,并针对近年来污点分析在解决实际应用程序安全问题时遇到的问题和关键解决技术进行了分析综述.不同于基于安全类型系统的信息流分析技术,污点分析可以不改变程序现有的编程模型或语言特性,并提供精确信息流传播跟踪.在实际应用过程中,污点分析还需要借助传统的程序分析技术的支持,例如静态分析中的数据流分析、动态分析中的代码重写等技术.另外,结合测试用例生成技术、符号执行技术以及虚拟机技术,也会给污点分析带来更多行之有效的解决方案</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[^1]:Vogt P, Nentwich F, Jovanovic N, Kirda E, Kruegel C, Vigna G. Cross site scripting prevention with dynamic data tainting and static analysis. In: Proc. of the NDSS 2007. 2007. 12. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.4505">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.4505</a><br>[^2]:Gordon MI, Kim D, Perkins JH, Gilham L, Nguyen N, Rinard MC. Information flow analysis of Android applications in DroidSafe. In: Proc. of the NDSS 2015. 2015. [doi: 10.14722/ndss.2015.23089]<br>[^3]:Rasthofer S, Arzt S, Bodden E. A machine-learning approach for classifying and categorizing android sources and sinks. In: Proc. of the Network and Distributed System Security Symp. (NDSS). 2014. [doi: 10.14722/ndss.2014.23039]</p>
<p>[^4]:Yang Z, Yang M. Leakminer: Detect information leakage on Android with static taint analysis. In: Proc. of the Software Engineering. IEEE, 2012. 101−104. [doi: 10.1109/WCSE.2012.26]<br>[^5]:Lu L, Li Z, Wu Z, Lee W, Jiang G. Chex: Statically vetting Android apps for component hijacking vulnerabilities. In: Proc. of the 2012 ACM Conf. on Computer and Communications Security. ACM Press, 2012. 229−240. [doi: 10.1145/2382196.2382223]<br>[^6]:Arzt S, Rasthofer S, Fritz C, Bodden E, Bartel A, Klein J, Le Traon Y, Octeau D, McDaniel P. Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps. ACM SIGPLAN Notices, 2014,49(6):259−269. [doi: 10.1145/2594291.2594299]<br>[^7]:Gordon MI, Kim D, Perkins JH, Gilham L, Nguyen N, Rinard MC. Information flow analysis of Android applications in DroidSafe. In: Proc. of the NDSS 2015. 2015. [doi: 10.14722/ndss.2015.23089]</p>
<blockquote>
<p><a href="https://ch3nye.top/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">原文链接</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序分析</category>
      </categories>
      <tags>
        <tag>数据流</tag>
        <tag>污点分析</tag>
        <tag>依赖关系</tag>
        <tag>Source/Sink</tag>
      </tags>
  </entry>
  <entry>
    <title>程序分析之中间表示（Intermediate Representation）</title>
    <url>/2021/12/10/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA%EF%BC%88Intermediate-Representation%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a><a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90">静态分析</a></h4><p>程序静态分析（Program Static Analysis）是指在不运行<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048">代码</a>的方式下，通过<a href="https://baike.baidu.com/item/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/8853461">词法分析</a>、<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/8853407">语法分析</a>、<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%B5%81/854473">控制流</a>、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/21496987">数据流分析</a>等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。静态分析技术向模拟执行的技术发展以能够发现更多传统意义上动态测试才能发现的缺陷，从而提高开发效率和软件质量。本文介绍部分在静态代码分析中使用的<a href="https://bbs.huaweicloud.com/blogs/detail/227535">中间表示</a>的概念，主要包括<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/6129952">抽象语法树</a>、<a href="https://baike.baidu.com/item/%E4%B8%89%E5%9C%B0%E5%9D%80%E7%A0%81">三地址码</a>、<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F">SSA形式</a>，及<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE?fromtitle=CFG&fromid=1070246">CFG</a>和<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E8%BE%93%E8%AF%AD%E8%A8%80/20870434">RTL</a>等概念</p>
<hr>
<span id="more"></span>

<h4 id="中间表示（Intermediate-Representation）"><a href="#中间表示（Intermediate-Representation）" class="headerlink" title="中间表示（Intermediate Representation）"></a>中间表示（Intermediate Representation）</h4><h5 id="抽象语法树（Abstract-Syntax-Tree，AST）"><a href="#抽象语法树（Abstract-Syntax-Tree，AST）" class="headerlink" title="抽象语法树（Abstract Syntax Tree，AST）"></a><a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/6129952">抽象语法树</a>（Abstract Syntax Tree，AST）</h5><p>在介绍AST时，我们用一个简单的例子：x = 3 + 4 * y 这个表达式作为例子来进行介绍：</p>
<ul>
<li>AST：<ul>
<li>是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，之所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节</li>
<li>抽象语法树，其实就是用树状结构表示语法结构，也没有说必须是什么形式，只要能忠实地反映出源码的格式即可</li>
</ul>
</li>
</ul>
<p>当然，一般资料中在进行介绍时，都是以操作符作为根节点，画个树状的结构来表示，这里咱们也简单画一个意思一下，如下图：</p>
<p><img src="https://bbs-img.huaweicloud.com/blogs/img/1608646488430032435.png" alt="AST示例"></p>
<h5 id="三地址码（Three-Address-Code，TAC-3AC）"><a href="#三地址码（Three-Address-Code，TAC-3AC）" class="headerlink" title="三地址码（Three Address Code，TAC/3AC）"></a><a href="https://baike.baidu.com/item/%E4%B8%89%E5%9C%B0%E5%9D%80%E7%A0%81">三地址码</a>（Three Address Code，TAC/3AC）</h5><p>三地址码是一种有意思的中间表示，当前也是编译原理中用得最火的。这里我给大家梳理一种我的理解上的概念，那就是，<strong>刨掉赋值操作，最多只有一个操作符</strong>，先看下面的几个例子</p>
<ul>
<li>x = y bop z</li>
<li>x = uop y</li>
<li>x = y</li>
<li>goto L</li>
</ul>
<p>如上，第一个，除了赋值之外，只有 bop 一个操作符，第二个，只有 uop 一个操作符，第三个没有操作符，同时，操作符的概念可以进一步扩展到函数调用等，例如 call fun(a, b, c, d)，虽然有四个操作数，但是我们认为 call fun只是一个操作符。</p>
<p>如上面 x = 3 + 4 * y 转换为三地址码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t1 = <span class="number">4</span></span><br><span class="line">t2 = y</span><br><span class="line">t3 = t1 * t2</span><br><span class="line">t4 = <span class="number">3</span></span><br><span class="line">t5 = t4 + t3</span><br><span class="line">x = t5</span><br></pre></td></tr></table></figure>

<p>当然，有些形式下会减少临时变量的使用，尽量复用原来的变量或者常量，形成的三地址码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t1 = <span class="number">4</span> * y</span><br><span class="line">x = <span class="number">3</span> + t1</span><br></pre></td></tr></table></figure>

<p>三地址码最初只是处理类似于 x = y bop z 这种形式的语句，而提出来的“三个操作数”的意思，随着语法的扩充，也并不是完全就是“三地址”。</p>
<h5 id="AST和三地址码对比"><a href="#AST和三地址码对比" class="headerlink" title="AST和三地址码对比"></a>AST和三地址码对比</h5><p>以下介绍几点AST和三地址码的对比特点：</p>
<ul>
<li><p>源码相关性</p>
<p>AST中的节点与输入源代码中的各个语法元素一一对应，忠实地体现了源码的内容和语法特性，因此AST与源码强相关；三地址码就是从AST进一步抽象的一种中间表示，更接近机器语言，可以认为和语言无关，是连接前后端的一种中间表示</p>
</li>
<li><p>变化频繁程度</p>
<p>因为AST需要忠实地体现出源代码的语法元素，因此在对应的编程语言升级时，对应的AST必然会跟着发生变化，比如Java，从Java7变成Java8，增加了大量的Lambda表达式、函数引用等特性，所以AST节点也需要增加这些语法节点，所以AST的版本需要随着语言发布而不断变化。</p>
<p>但是三地址码是一种经过处理的语言无关的中间表示，即使源代码结构变化，AST结构变化，但是转换后的三地址码是稳定的，不会经常发生变化，构造在三地址码上面的分析算法就相对比较稳定</p>
</li>
<li><p>结构</p>
<p>AST体现源码的结构，需要匹配源码的语法，因此一般结构比较复杂，而三地址经过处理，一般比较紧凑，简单。例如，Java中，对 for，while，do while 有多种不同的循环方式，但是，其实内容大同小异，但是在AST层面，就是不一样的，但是转换为三地址码后，所表达的控制语义是完全一样的</p>
</li>
<li><p>表达信息</p>
<p>AST表达了源码的信息，因此可以在AST上做程序结构的检查，但是三地址码中，可以更好地包含了程序控制流和数据流信息，能进行更深层次的流敏感分析，过程间分析，上下文敏感分析和对象敏感分析等等，从而实现各种更高难度的程序漏洞检查。</p>
<p>同时，三地址码因为是语言无关的， 所以在部分静态代码分析工具实现时，会对不同的三地址码，实现一个分析引擎，只是通过开发不同语言的规则，实现对不同语言的能力的覆盖，而AST是无法做到这一点的。因此，三地址码也被认为是静态代码分析的基础</p>
</li>
</ul>
<h5 id="静态单赋值形式-（Static-Single-Assignment-Form，SSA）"><a href="#静态单赋值形式-（Static-Single-Assignment-Form，SSA）" class="headerlink" title="**静态单赋值形式**（Static Single Assignment Form，SSA）"></a>**<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F">静态单赋值形式</a>**（Static Single Assignment Form，SSA）</h5><p><a href="https://github.com/lwy0518/blog_files/tree/master/%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA%E6%96%87%E4%BB%B6">文件地址</a></p>
<h6 id="SSA概念及分类"><a href="#SSA概念及分类" class="headerlink" title="SSA概念及分类"></a>SSA概念及分类</h6><ul>
<li><p>SSA概念</p>
<blockquote>
<p>在编译器的设计中，<strong>静态单赋值形式</strong>通常简写为<strong>SSA form</strong>或是<strong>SSA</strong>，是中介码的特性，每个变数仅被赋值一次。在原始的IR中，已存在的变数可被分割成许多不同的<strong>版本</strong>，在许多教科书当中通常会将旧的变数名称加上一个下标而成为新的变数名称，以至于标明每个变数及其不同版本。在SSA中，<strong>UD链</strong>（use-define chain，赋值代表define，使用变数代表use）是非常明确，而且每个仅包含单一元素</p>
</blockquote>
<p>以下面的代码为例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        y = x + <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> z = y + <span class="number">3</span>;</span><br><span class="line">    System.out.println(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下图为例，左图是原始代码，里面有分支， y 变量在不同路径中有不同赋值，最后打印 z的值。右图是等价的 SSA 形式，y 变量在两个分支中被改写为 y2, y3，在控制流交汇处插入φ函数，合并了来自不同边的 y2, y3值, 赋给 y4 最后z由y4生成</p>
<img src="/2021/12/10/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA%EF%BC%88Intermediate-Representation%EF%BC%89/1608646522321044418.png" class="" title="原始代码与SSA形式及相应CFG控制流图">

<p>其实要讲SSA形式，就不能离开对DU Chain（Define-Use Chain）和UD Chain（Use-Define Chain）的介绍，因为很多地方对SSA的概念的介绍，都是从DU Chain和UD Chain引起的。Use-Define Chain 是一个数据结构，包含一个Define变量，以及它的全部Use的集合。相对的，Define-Use Chain 包含一个Use变量，以及它的全部 Define的集合。</p>
<p>另外一种SSA的描述，就是在 Define-Use Chain中，每一个Use变量，只会有一个Define，例如，在前面例子中，z = y + 3 中，因为此时 y可能在两个分支中赋值，因此，对于变量 z = y + 3 中，y 的Use来说，有两个 Define，但是，通过更改为 SSA形式，z = y + 3 中，y只有一个 Define，那就是 y4。因此，通过将三地址码转为SSA形式，可以很大程度上，简化Use-Define Chain和Define-Use Chain。</p>
</li>
<li><p>SSA分类</p>
<blockquote>
<p>SSA 有几种不同分类（主要是最小SSA、剪枝SSA、半剪枝SSA，另外两种严格SSA和最大SSA，大部分资料上都没有看到，只是在少部分资料中有见到，所以简单提一下）</p>
</blockquote>
<ul>
<li><p>最小SSA</p>
<p>最小SSA有以下特点：同一原始名字的两个不同定义的路径汇合处都插入一个φ函数。这样得到符合两大特征的且拥有最少φ函数数量的 SSA 形式。但是这里的最小不包含优化效果，比如死代码消除。如上面图2.1节，就是一个最小SSA形式</p>
</li>
<li><p>剪枝SSA</p>
<p>如果变量在基本块的入口处不是活跃 (live) 的，就不必插入φ函数。一种方法是在插入 φ函数的时候计算活跃变量分析。另一种剪枝方式是在最小SSA上做死代码消除，删掉多余的φ函数。如下面的例子，y在分支执行完后，在最后的BB块中不再使用，y已经不再活跃，此时没必要在这个节点添加φ函数，如下面右图红色标出来的位置（说明：虽然不是剪枝SSA，但是仍然是最小SSA）</p>
<p><img src="https://bbs-img.huaweicloud.com/blogs/img/1608646556674025089.png" alt="剪枝SSA和最小SSA说明"></p>
</li>
<li><p>半剪枝SSA</p>
<p>鉴于剪枝 SSA 的成本，可以稍微折衷一点。插入φ函数前先去掉非跨越基本块的变量名。这样既减少了名字空间也没有计算活跃变量集的开销。如下图所示，y变量除了Define，并没有Use，所以，变量y其实可以去掉，如下右图</p>
<p><img src="https://bbs-img.huaweicloud.com/blogs/img/1608646587998085989.png" alt="半剪枝SSA形式"></p>
</li>
<li><p>严格SSA</p>
<p>如果一个 SSA中，每个Use被其Define支配（如果从程序入口到一个结点 A 的所有路径，都先经过结点B，则称A被B支配），那么称为严格 SSA（实际上，在强类型语言中，这种情况比较少，因为没有定义，就不允许使用，在少数动态类型语言中，允许没有定义就可以使用的才有这类问题）</p>
</li>
<li><p>最大SSA</p>
<p>最大SSA是相对最小SSA而言的，就是在每个汇合点处为每个变量放置一个φ函数。很显然，这种方法会导致SSA的使用效率最差，用户体验也很差，我估计谁生成的SSA是这样的形式，会被使用的人打死的</p>
</li>
</ul>
</li>
</ul>
<h6 id="SSA形式和普通三地址码对比"><a href="#SSA形式和普通三地址码对比" class="headerlink" title="SSA形式和普通三地址码对比"></a>SSA形式和普通三地址码对比</h6><p>其实对比SSA形式和普通的三地址码形式，只有一个区别，那就是，SSA形式，对于每个Use，只会有一个Define。两者在一定程度上，还是非常类似的。那么主要对比在于两种形式的各自的优缺点：</p>
<ul>
<li>SSA形式相对于三地址码，会引入大量的额外的临时变量，同时需要插入φ函数，还需要维护这些临时变量到原始变量的映射关系（当然，仁者见仁，智者见智，也有资料觉得这些额外的临时变量可以忽略，驳斥这个观点为谬论，不过的确还是有其不舒服的地方的）</li>
<li>SSA形式的优势在于，SSA形式简化了DU Chain和UD chain，构建了一种稀疏结构，可以简化数据流分析（一般基于三地址码，需要基于传统的数据流分析来进行分析，称为dense分析，基于SSA形式，可以构造值依赖关系，基于值流分析，也称为sparse分析，同时，SSA形式也隐含了一定的程序流信息）</li>
<li>SSA形式相比于普通三地址码，可以优化常量传播、值依赖分析、死代码、重复代码删除等</li>
</ul>
<h5 id="控制流图（Control-Flow-Graph，CFG）"><a href="#控制流图（Control-Flow-Graph，CFG）" class="headerlink" title="控制流图（Control Flow Graph，CFG）"></a><a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE?fromtitle=CFG&fromid=1070246">控制流图</a>（Control Flow Graph，CFG）</h5><blockquote>
<p>也叫控制<a href="https://baike.baidu.com/item/%E6%B5%81%E7%A8%8B%E5%9B%BE/206961">流程图</a>，是一个过程或程序的抽象表现，是用在<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067">编译器</a>中的一个<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/22093090">抽象数据结构</a>，由编译器在内部维护，代表了一个程序执行过程中会遍历到的所有路径。它用图的形式表示一个过程内所有基本块执行的可能流向, 也能反映一个过程的实时执行过程</p>
</blockquote>
<ol>
<li><p>基本块（Basic Block）</p>
<ul>
<li>特点：<ul>
<li>单入口、单出口、每个块内的语句都是按顺序执行的，不能有分支和跳转</li>
<li>只能从第一条语句进入该基本块，不能够以某种方式跳入该基本块的中间</li>
<li>基本块内的语句在执行时必须从最后一条语句离开，不能够执行到一半跳转到其它的基本块</li>
</ul>
</li>
</ul>
</li>
<li><p>CFG</p>
<p>CFG是一个由基本块组成的有向图，每个节点都是一个基本块。如果程序的执行路径可能从一个基本块$B_1$进入另一个基本块**$B_2$<strong>，</strong>$B_1$<strong>有一条指向</strong>$ B_2 $**的边</p>
<p>其中：</p>
<p>$N:$表示所有基本块节点的集合</p>
<p>$E:$表示所有边的集合</p>
<p>$n_0:$表示首节点</p>
<p>CFG具有如下的两条性质：</p>
<ul>
<li>CFG 必然有唯一的一个入口点</li>
<li>首节点必然支配CFG中其他的所有节点（即从首节点到CFG上其他任何一个节点都有一条路可以连通）</li>
</ul>
</li>
</ol>
<h5 id="寄存器传输语言（Register-Transfer-Language，RFL）"><a href="#寄存器传输语言（Register-Transfer-Language，RFL）" class="headerlink" title="寄存器传输语言（Register Transfer Language，RFL）"></a><a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E8%BE%93%E8%AF%AD%E8%A8%80/20870434">寄存器传输语言</a>（Register Transfer Language，RFL）</h5><blockquote>
<p>又译为<strong>暂存器转换语言</strong>、<strong>寄存器转换语言</strong>，一种中间语言，使用于<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>中。与<a href="https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80">汇编语言</a>很接近。寄存器传递语言被用于描述一个架构中<a href="https://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E8%BE%93%E7%BA%A7">寄存器传输级</a>上的数据流。 在学术论文和教科书中，寄存器传递语言被认为是一种与架构无关的汇编语言。<a href="https://zh.wikipedia.org/wiki/GCC">GCC</a>的中间语言，也被称为寄存器传递语言，风格类似于<a href="https://zh.wikipedia.org/wiki/LISP">LISP</a>。GCC的前端（front-end）会先将编程语言转译成RTL，之后再利用后端（back-end）转化成机器代码</p>
</blockquote>
<p>以下一些文章用到相关技术：</p>
<ul>
<li><a href="https://github.com/usyd-blockchain/vandal">Vandal</a></li>
<li><a href="https://github.com/eth-sri/securify2">Securify2</a></li>
<li><a href="https://github.com/nevillegrech/MadMax">MadMax</a></li>
<li><a href="https://github.com/nevillegrech/gigahorse-toolchain">Gigahorse</a></li>
<li><a href="https://yanniss.github.io/ethainter-pldi20.pdf">Ethainter</a></li>
</ul>
<blockquote>
<p><a href="https://bbs.huaweicloud.com/blogs/detail/227535">原文链接</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序分析</category>
      </categories>
      <tags>
        <tag>中间表示（IR）</tag>
        <tag>CFG</tag>
        <tag>AST</tag>
        <tag>TAC</tag>
        <tag>SSA</tag>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客迁移到另外一台电脑</title>
    <url>/2021/12/10/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="复制原电脑上的数据"><a href="#复制原电脑上的数据" class="headerlink" title="复制原电脑上的数据"></a>复制原电脑上的数据</h4><p> <strong>注：</strong>不需要全部复制</p>
<blockquote>
<ul>
<li>_config.yml：站点配置文件</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
<li>scaffolds/：layout模板文件目录，其中的md文件可以添加编辑</li>
<li>source/：</li>
<li>文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。<ul>
<li>drafts：草稿文章</li>
<li>posts：发布文章</li>
</ul>
</li>
<li>themes/：主题文件</li>
</ul>
</blockquote>
<hr>
<span id="more"></span>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h5><ol>
<li>安装node</li>
<li>安装git</li>
<li><a href="https://lwy0518.github.io/2021/12/07/%E6%9E%84%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/#more">再参考上一篇文章</a></li>
</ol>
<h5 id="下载相关插件"><a href="#下载相关插件" class="headerlink" title="下载相关插件"></a>下载相关插件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文章部署到github上的模块</span></span><br><span class="line">$ cnpm install hexo-deployer-git --save</span><br><span class="line"><span class="comment"># 安装RSS插件</span></span><br><span class="line">$ cnpm install hexo-generator-feed --save</span><br><span class="line"><span class="comment"># 添加Sitemap,加速网页收录速度</span></span><br><span class="line">$ cnpm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>EOSIO环境搭建及创建账户</title>
    <url>/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p><a href="https://developers.eos.io/manuals/eos/latest/install/install-prebuilt-binaries">官方文档</a></p>
<h4 id="钱包和账户"><a href="#钱包和账户" class="headerlink" title="钱包和账户"></a>钱包和账户</h4><img src="/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/eost02-01.png" class="" title="EOS架构图">

<hr>
<span id="more"></span>

<ul>
<li><strong><a href="https://developers.eos.io/manuals/eos/latest/nodeos/index">Nodeos</a>（node + eos = nodeos）</strong>：运行节点的核心服务守护进程，用于区块生产、API 端点或本地开发</li>
<li><strong><a href="https://developers.eos.io/manuals/eos/latest/cleos/index">Cleos</a> (cli + eos = cleos)</strong> ： 与区块链交互的命令行界面 (via <code>nodeos</code>) 和管理钱包 (via <code>keosd</code>)</li>
<li><strong><a href="https://developers.eos.io/manuals/eos/latest/keosd/index">Keosd</a> (key + eos = keosd)</strong> ： 管理钱包中的 EOSIO 密钥并为数字签名提供安全飞地的组件</li>
</ul>
<p>可以参考下列解读图：</p>
<img src="/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/eost02-02.png" class="" title="eos解读图">

<h5 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet create -n wallet_name --to-console</span><br></pre></td></tr></table></figure>

<p>其中：**-n<strong>是指定钱包名称（如果不指定则会默认生成一个default钱包）， <strong>wallet_name</strong>是你需要创建的钱包名（以下用lwy代替），</strong>–to-console**是将密钥输出到控制台（记得一定要保存这个密钥，因为要用于钱包的解锁）</p>
<h5 id="查看创建的钱包"><a href="#查看创建的钱包" class="headerlink" title="查看创建的钱包"></a>查看创建的钱包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet list</span><br></pre></td></tr></table></figure>

<img src="/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/image-20211210094122334.png" class="" title="image-20211210094122334">

<p>其中带**”*”**号指已解锁的钱包</p>
<h5 id="钱包的解锁与加锁"><a href="#钱包的解锁与加锁" class="headerlink" title="钱包的解锁与加锁"></a>钱包的解锁与加锁</h5><ul>
<li><p><strong>解锁</strong>（会提示你输入钱包密钥）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet unlock -n lwy --password</span><br></pre></td></tr></table></figure></li>
<li><p>加锁（不需要输入密钥）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet lock -n lwy</span><br></pre></td></tr></table></figure>

<img src="/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/image-20211210094458277.png" class="" title="image-20211210094458277"></li>
</ul>
<h4 id="生成和导入公钥-私钥对"><a href="#生成和导入公钥-私钥对" class="headerlink" title="生成和导入公钥-私钥对"></a>生成和导入公钥-私钥对</h4><h5 id="生成公钥-私钥对"><a href="#生成公钥-私钥对" class="headerlink" title="生成公钥-私钥对"></a>生成公钥-私钥对</h5><blockquote>
<p>为了简单可以直接用一个公钥-私钥对（记得保存私钥，一定！一定 ！）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create key --to-console</span><br></pre></td></tr></table></figure>

<img src="/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/image-20211210094807129.png" class="" title="image-20211210094807129">

<h5 id="导入公钥-私钥对"><a href="#导入公钥-私钥对" class="headerlink" title="导入公钥-私钥对"></a>导入公钥-私钥对</h5><blockquote>
<p>如果lwy钱包还没解锁，记得先解锁</p>
</blockquote>
<p>将生成的公钥-私钥对导入lwy钱包内</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet import -n lwy --private-key 5J9rzfgPNLuCL9j4AEc4RYcchvJQPaPNUtWuToRSeFAEayitM8v</span><br></pre></td></tr></table></figure>

<img src="/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/image-20211210095118841.png" class="" title="image-20211210095118841">

<h4 id="创建和管理账户"><a href="#创建和管理账户" class="headerlink" title="创建和管理账户"></a>创建和管理账户</h4><h5 id="命令行及参数说明"><a href="#命令行及参数说明" class="headerlink" title="命令行及参数说明"></a>命令行及参数说明</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create account authorizing_account NEW_ACCOUNT OWNER_KEY ACTIVE_KEY</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注：</strong>在这OWNER_KEY与ACTIVE_KEY是同一个，因为我为了简单只生成了一个公钥-私钥对</p>
<ul>
<li>authorizing_account 是为帐户创建提供资金的帐户的名称</li>
<li>new_account 是您要创建的帐户的名称</li>
<li>owner_key是分配给帐户owner权限的公钥</li>
<li>active_key是分配给您帐户的active权限的公钥</li>
</ul>
</blockquote>
<p>新帐户名称必须符合以下准则：</p>
<blockquote>
<ul>
<li>必须在12个字符以内，包括12字符。</li>
<li>只能包含以下符号：.12345abcdefghijklmnopqrstuvwxyz</li>
<li>请注意，账户名称不允许使用6,7,8,9,0。</li>
</ul>
</blockquote>
<h5 id="使用eosio初始账户创建新账户"><a href="#使用eosio初始账户创建新账户" class="headerlink" title="使用eosio初始账户创建新账户"></a>使用eosio初始账户创建新账户</h5><p>eosio帐户是用于引导EOSIO节点的特殊帐户。<br>由于我们没有其他账户，所以用初始eosio账户来创建新帐户</p>
<blockquote>
<p>eosio帐户的密钥可以在nodeos配置文件中找到，位于~/.local/share/eosio/nodeos/config/config.ini。 同时，记得解锁lwy钱包</p>
</blockquote>
<p>首先，需要将默认账号eosio的私钥导入lwy钱包内：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet import -n lwy --private-key 5J9rzfgPNLuCL9j4AEc4RYcchvJQPaPNUtWuToRSeFAEayitM8v</span><br></pre></td></tr></table></figure>

<p>然后，用初始eosio账户来创建新帐户<strong>testaccount</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create account eosio testaccount 5J9rzfgPNLuCL9j4AEc4RYcchvJQPaPNUtWuToRSeFAEayitM8v</span><br></pre></td></tr></table></figure>

<h5 id="查看账户信息"><a href="#查看账户信息" class="headerlink" title="查看账户信息"></a>查看账户信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos get account testaccount -j</span><br></pre></td></tr></table></figure>

<p><strong>-j</strong> 指信息以json格式输出</p>
<p><strong>至此，EOSIO环境搭建以及账户创建已完成！！</strong></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>EOSIO</category>
      </categories>
      <tags>
        <tag>EOSIO</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>EOSIO部署全过程</title>
    <url>/2021/12/10/EOSIO%E9%83%A8%E7%BD%B2%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />



<hr>
<span id="more"></span>

<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>EOSIO</category>
      </categories>
      <tags>
        <tag>EOSIO</tag>
        <tag>数据流</tag>
        <tag>编译器</tag>
        <tag>漏洞检测</tag>
        <tag>静态分析</tag>
        <tag>Datalog</tag>
        <tag>CFG</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流分析</title>
    <url>/2021/12/07/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>数据流分析是一种用来获取相关数据沿着程序执行路径流动的信息分析技术。分析对象是程序执行路径上的数据流动或可能的取值</p>
<ul>
<li>优点：具有更强的分析能力，适合需要考虑控制流信息且变量属性之操作十分简单的静态分析问题</li>
<li>缺点：分析效率低，过程间分析和优化算法复杂，编程工作量大，容易出错且效率低</li>
</ul>
<p>一个数据流分析框架(D, L, F)包含:</p>
<ol>
<li>D：数据流的方向，前向或者后向</li>
<li>L：包含数值作用域V和操作符meet ⊓ 或 join ⊔ 的lattice</li>
<li>F：一系列V to V的传递函数</li>
</ol>
<blockquote>
<p>Tips: 数据流分析可以看成在一个lattice的数值域上，迭代地使用传递函数和操作符</p>
</blockquote>
<hr>
<span id="more"></span>

<h5 id="数据流分析的分类"><a href="#数据流分析的分类" class="headerlink" title="数据流分析的分类"></a>数据流分析的分类</h5><ul>
<li>对程序路径的分析精度分类<ul>
<li>流不敏感分析（flow insensitive）：不考虑语句的先后顺序，按照程序语句的物理位置从上往下顺序分析每一语句，忽略程序中存在的分支</li>
<li>流敏感分析（flow sensitive）：考虑程序语句可能的执行顺序，通常需要利用程序的控制流图（CFG）</li>
<li>路径敏感分析（path sensitive）：不仅考虑语句的先后顺序，还对程序执行路径条件加以判断，以确定分析使用的语句序列是否对应着一条可实际运行的程序执行路径</li>
</ul>
</li>
<li>分析程序路径的深度分类<ul>
<li>过程内分析（intra-procedure analysis）：只针对程序中函数内的代码</li>
<li>过程间分析（inter-procedure analysis）：考虑函数之间的数据流，即需要跟踪分析目标数据在函数之间的传递过程<ul>
<li>上下文不敏感分析（context-insensitive）：将每个调用或返回看做一个 “goto” 操作，忽略调用位置和函数参数取值等函数调用的相关信息</li>
<li>上下文敏感分析（context-sensitive）：对不同调用位置调用的同一函数加以区分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="检测程序漏洞"><a href="#检测程序漏洞" class="headerlink" title="检测程序漏洞"></a>检测程序漏洞</h5><p>基于数据流的源代码漏洞分析的原理如下图所示：</p>
<p><img src="https://firmianay.gitbooks.io/ctf-all-in-one/content/pic/5.4_overview.png" alt="数据流分析原理"></p>
<ul>
<li>代码建模<ul>
<li>该过程通过一系列的程序分析技术获得程序代码模型。首先通过词法分析生成词素的序列，然后通过语法分析将词素组合成抽象语法树。如果需要三地址码，则利用中间代码生成过程解析抽象语法树生成三地址码。如果采用流敏感或路径敏感的方式，则可以通过分析抽象语法树得到程序的控制流图。构造控制流图的过程是过程内的控制流分析过程。控制流还包含分析各个过程之间的调用关系的部分。通过分析过程之间的调用关系，还可以构造程序的调用图。另外，该过程还需要一些辅助支持技术，例如变量的别名分析，Java 反射机制分析，C/C++ 的函数指针或虚函数调用分析等<ul>
<li>代码解析：指词法分析、语法分析、中间代码生成以及过程内的控制流分析等基础的分析过程</li>
<li>辅助分析：包括控制流分析等为数据流分析提供支持的分析过程</li>
</ul>
</li>
</ul>
</li>
<li>程序代码建模<ul>
<li>漏洞分析系统通常使用树型结构的抽象语法树或者线性的三地址码来描述程序代码的语义。控制流图描述了过程内程序的控制流路径，较为精确的数据流分析通常利用控制流图分析程序执行路径上的某些行为。调用图描述了过程之间的调用关系，是过程间分析需要用到的程序结构</li>
</ul>
</li>
<li>漏洞分析规则<ul>
<li>漏洞分析规则是检测程序漏洞的依据。对于分析变量状态的规则，可以使用状态自动机来描述。对于需要分析变量取值的情况，则需要指出应该怎样记录变量的取值，以及在怎样的情况下对变量的取值进行何种的检测<ul>
<li>程序漏洞通常和程序中变量的状态或者变量的取值相关。状态自动机可以描述和程序变量状态相关的漏洞分析规则，自动机的状态和变量相应的状态对应</li>
</ul>
</li>
</ul>
</li>
<li>静态漏洞分析<ul>
<li>数据流分析可以看做一个根据检测规则在程序的可执行路径上跟踪变量的状态或者变量取值的过程。在该过程中，如果待分析的程序语句是函数调用语句，则需要利用调用图进行过程间的分析，以分析被调用函数的内部代码。另外，数据流分析还可以作为辅助技术，用于完善程序调用图和分析变量别名等<ul>
<li><strong>赋值语句</strong>、<strong>控制转移语句</strong>和<strong>过程调用语句</strong>是数据流分析最关心的三类语句</li>
<li>过程内分析<ul>
<li>对于<strong>抽象语法树</strong>的分析，可以按照程序执行语句的过程从右向左、自底向上地进行分析</li>
<li>对于<strong>三地址码</strong>的分析，则可以直接识别其操作以及操作相关的变量</li>
<li>在<strong>流不敏感分析</strong>中，常常使用线性扫描的方式依次分析每一条中间表示形式的语句</li>
<li><strong>流敏感的分析</strong>或<strong>路径敏感的分析</strong>，则根据控制流图进行分析。对控制流图的遍历主要是<strong>深度优先</strong>和<strong>广度优先</strong>两种方式</li>
</ul>
</li>
<li><div align="center">
    <src img=https://github.com/lwy0518/blog_files/tree/master/images>
</div>

<ul>
<li>如果在分析某段程序中遇到过程调用语句，就分析其调用过程的内部的代码，完成分析之后再回到原来的程序段继续分析</li>
<li>借鉴基本块的分析，给过程设置上摘要，也包含前置条件和后置条件<ul>
<li>前置条件记录对基本块分析前已有的相关分析结果</li>
<li>后置条件是分析基本块后得到的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>处理分析结果<ul>
<li>对检测出的漏洞进行危害程度分类等</li>
</ul>
</li>
</ul>
<h4 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h4><p>数据流分析使用的程序代码模型主要包括程序代码的中间表示以及一些关键的数据结构，利用程序代码的中间表示可以对程序语句的指令语义进行分析</p>
<h5 id="抽象语法树（AST）"><a href="#抽象语法树（AST）" class="headerlink" title="抽象语法树（AST）"></a>抽象语法树（AST）</h5><p>是程序抽象语法结构的树状表现形式，其每个内部节点代表一个运算符，该节点的子节点代表这个运算符的运算分量。通过描述控制转移语句的语法结构，抽象语法树在一定程度上也描述了程序的过程内代码的控制流结构</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> b ≠ <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> a &gt; b</span><br><span class="line">		a := a − b</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		b := b − a</span><br><span class="line"><span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>对应的抽象语法树为：</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://firmianay.gitbooks.io/ctf-all-in-one/content/pic/5.4_ast.png" alt="TAC"></h5><p>由一组类似于汇编语言的指令组成，每个指令具有不多于三个的运算分量。每个运算分量都像是一个<strong>寄存器</strong></p>
<h5 id="静态单赋值形式（SSA）"><a href="#静态单赋值形式（SSA）" class="headerlink" title="静态单赋值形式（SSA）"></a>静态单赋值形式（SSA）</h5><p>是一种程序语句或者指令的表示形式，在这种表示形式中，所有的赋值都是针对具有不同名字的变量，也就是说，如果某个变量在不同的程序点被赋值，那么在这些程序点上，该变量在静态单赋值形式的表示中应该使用不同的名字。在使用下标的赋值表示中，变量的名字用于区分程序中的不同的变量，下标用于区分不同程序点上变量的赋值情况。另外，如果在一个程序中，同一个变量可能在两个不同的控制流路径中被赋值，并且在<strong>路径交汇</strong>后，该变量被使用，那么就需要一种被称为 <strong>Φ 函数</strong>的的表示规则将变量的赋值合并起来</p>
<div align="center">
    <img src="https://firmianay.gitbooks.io/ctf-all-in-one/content/pic/5.4_ssa1.png">
    <img src="https://firmianay.gitbooks.io/ctf-all-in-one/content/pic/5.4_ssa2.png">
</div>



<p><strong>作用：</strong>静态单赋值形式对于数据流分析的意义在于，可以简单而直接地<strong>发现变量的赋值和使用情况</strong>，以此分析数据的流向并发现程序不安全的行为</p>
<h5 id="控制流图（CFG）"><a href="#控制流图（CFG）" class="headerlink" title="控制流图（CFG）"></a>控制流图（CFG）</h5><p>是指用于描述程序过程内的控制流的有向图。控制流由节点和有向边组成。典型的节点是基本块（BB），即程序语句的线性序列。有向边表示节点之间存在潜在的控制流路径，通常都带有属性（如if语句的true分支和false分支）</p>
<h5 id="调用图（CG）"><a href="#调用图（CG）" class="headerlink" title="调用图（CG）"></a>调用图（CG）</h5><p>是描述程序中过程之间的调用和被调用关系的有向图。控制图是一个节点和边的集合，并满足如下原则</p>
<ul>
<li>对程序中的每个过程都有一个节点</li>
<li>对每个调用点都有一个节点</li>
<li>如果调用点 c 调用了过程 p，就存在一条从 c 的节点到 p 的节点的边</li>
</ul>
<h5 id="静态漏洞分析"><a href="#静态漏洞分析" class="headerlink" title="静态漏洞分析"></a>静态漏洞分析</h5><p>数据流分析检测漏洞是利用分析规则按照一定的顺序分析代码中间表示的过程</p>
<ul>
<li><strong>过程内分析：</strong>对于抽象语法树的分析，可以按照程序执行语句的过程从右向左、自底向上地进行分析。对于三地址码的分析，则可以直接识别其操作以及操作相关的变量</li>
<li><strong>过程间分析：</strong>如果在分析某段程序中遇到过程调用语句，就分析其调用过程的内部的代码，完成分析之后再回到原来的程序段继续分析。另一种思路是借鉴基本块的分析，给过程设置上摘要，也包含前置条件和后置条件</li>
</ul>
<blockquote>
<p><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.4_dataflow_analysis.html">原文链接</a></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序分析</category>
      </categories>
      <tags>
        <tag>程序分析</tag>
        <tag>数据流</tag>
        <tag>Def-Use</tag>
        <tag>中间表示（IR）</tag>
      </tags>
  </entry>
  <entry>
    <title>EOSIO-Vulneribilities</title>
    <url>/2021/12/07/EOSIO-Vulneribilities/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="EOSIO漏洞复现"><a href="#EOSIO漏洞复现" class="headerlink" title="EOSIO漏洞复现"></a><a href="https://github.com/lwy0518/blog_files">EOSIO漏洞复现</a></h4><h5 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h5><ul>
<li>nodeos ：2.0.12</li>
<li>EOSIO.CDT（编译器）：1.2.1</li>
<li><a href="https://github.com/gongbell/EOSFuzzer">实验数据</a></li>
</ul>
<hr>
<span id="more"></span>

<h5 id="准备（前一篇文章已经介绍如何创建账户等等操作）"><a href="#准备（前一篇文章已经介绍如何创建账户等等操作）" class="headerlink" title="准备（前一篇文章已经介绍如何创建账户等等操作）"></a>准备（<a href="https://lwy0518.github.io/2021/12/10/EOSIO%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7/#more">前一篇文章已经介绍如何创建账户等等操作</a>）</h5><ul>
<li><p>解锁账户（默认锁定时间较短，可以自己修改配置文件使得时间更长）</p>
<blockquote>
<p> yourcount：指你自己创建的钱包名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos wallet unlock -n yourcount --password</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="EOS-Fake-Transfer复现过程"><a href="#EOS-Fake-Transfer复现过程" class="headerlink" title="EOS Fake Transfer复现过程"></a>EOS Fake Transfer复现过程</h5><ul>
<li><p>存在漏洞的合约示例（<em>test.cpp</em>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( code == self || action == ::eosio::<span class="built_in">string_to_name</span>(<span class="string">&quot;onerror&quot;</span>) || code == <span class="built_in">N</span>(eosio.token)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receiver:&quot;</span>, name&#123;receiver&#125;, <span class="string">&quot;, code:&quot;</span>, name&#123;code&#125;, <span class="string">&quot;, action:&quot;</span>, name&#123;action&#125;, <span class="string">&quot;\n&quot;</span>); </span><br><span class="line">	<span class="function">notified <span class="title">thiscontract</span><span class="params">( self )</span></span>; </span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span>( action ) &#123; </span><br><span class="line">		<span class="keyword">case</span> ::eosio::<span class="built_in">string_to_name</span>( <span class="string">&quot;transfer&quot;</span> ): </span><br><span class="line">			eosio::<span class="built_in">execute_action</span>( &amp;thiscontract, &amp;notified::transfer ); </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// doSomething()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>漏洞产生的原因</p>
<blockquote>
<p>由于eosio.token源代码完全公开的，所以任何人都能复制其源代码，并发布一个token（相同的名字、符号和代码），虚假的EOS和官方的唯一不同就是具有不同的发布人（<strong>issuer</strong>）。或者直接调用漏洞合约的transfer函数进行转账</p>
</blockquote>
</li>
<li><p>过程</p>
<ul>
<li><p>创建受害者账户</p>
<blockquote>
<p>your key：是你自己创建的公钥，需要把公钥导入到你的钱包以及官方钱包eosio</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create account eosio victim4 <span class="string">&quot;your key&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>部署测试合约<em>test.cpp</em></p>
<blockquote>
<p>cleos set contract + 账户名 + 测试合约的wasm字节码所在目录 + -p + 账户@active（默认权限为active，故可加可不加）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos <span class="built_in">set</span> contract victim4 <span class="built_in">test</span>/ -p  victim4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开始模拟攻击</p>
<ul>
<li><p>直接调用<em>test.cpp</em>合约的<em>transfer</em>（主要目的看是否<em>trasnfer</em>中的<em>print</em>是否有输出）</p>
<blockquote>
<p>cleos push action + 账户名 + 需要调用的action + ‘调用action的参数’ + -p + 转账账户 （+ -j）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos push action victim4 transfer <span class="string">&#x27;[&quot;eosio&quot;,&quot;victim4&quot;,&quot;10.0000 EOS&quot;,&quot;inlined call&quot;]&#x27;</span> -p  eosio -j</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：加了一个 <strong>-j</strong> ，说明结果以json的格式进行输出的</p>
<p>结果显示：测试合约的<strong>transfer</strong>函数被调用了</p>
<img src="/2021/12/07/EOSIO-Vulneribilities/inlined_call.png" class="" title="inlined_call"></li>
</ul>
</li>
<li><p>查询账户余额</p>
<blockquote>
<p> cleos get currency balance eosio.token + 查询账户 + token名（EOS)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos get currency balance eosio.token victim4 EOS</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Forged-Transfer-Notification复现过程"><a href="#Forged-Transfer-Notification复现过程" class="headerlink" title="Forged Transfer Notification复现过程"></a>Forged Transfer Notification复现过程</h5><ul>
<li><p>存在漏洞的合约示例（<em>test.cpp</em>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(account_name from, account_name to, asset quantity, string memo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n Receiving transfer message: from &quot;</span>, name&#123;from&#125;, <span class="string">&quot; to &quot;</span>, name&#123;to&#125;, <span class="string">&quot;,&quot;</span>, quantity, <span class="string">&quot;,&quot;</span>, memo);</span><br><span class="line">    <span class="keyword">if</span> (from == _self) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;have a vulnerability!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;in eosbet transfer,&quot;</span>, name&#123; from &#125;, <span class="string">&quot;,&quot;</span>, name&#123; to &#125;);</span><br><span class="line">	<span class="comment">// doSomething()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>漏洞产生的原因</p>
<blockquote>
<p>攻击者在 EOS 网络中控制两个账户 A（发起攻击的账户） 和 B（将收到的通知立即转发给账户C）。通过账户 A 向账户 B 发送真正的 EOS，如图所示，eosio.token 合约在转账成功后会向 账户A、B 发送 notification。当账户 B 收到 notification后，通过调用require_recipient(C)随即将收到的通知转发给部署受害者智能合约的账户C。</p>
</blockquote>
</li>
<li><p>过程</p>
<ul>
<li><p>创建攻击者账户<strong>sender</strong>，用于向另一个由攻击者控制的账户<strong>notifier</strong></p>
<blockquote>
<p>your key：是你自己创建的公钥，需要把公钥导入到你的钱包以及官方钱包eosio</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create account eosio sender <span class="string">&quot;your key&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建账户<strong>notifier</strong>，用于将收到的转账通知转发给受害者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create account eosio notifier <span class="string">&quot;your key&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建受害者账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos create account eosio victim5 <span class="string">&quot;your key&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>账户<strong>notifier</strong>部署攻击合约<em>eosbethack.cpp</em></p>
<blockquote>
<p>cleos set contract + 账户名 + 测试合约的wasm字节码所在目录 + -p + 账户@active（默认权限为active，故可加可不加）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos <span class="built_in">set</span> contract notifier eosbethack/ -p notifier</span><br></pre></td></tr></table></figure></li>
<li><p>账户<strong>victim5</strong>部署攻击合约<em>eosbet.cpp</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos <span class="built_in">set</span> contract victim5 eosbet/ -p victim5</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开始模拟攻击</p>
<ul>
<li><p>账户<strong>sender</strong>（攻击者）向账户notifier（攻击者）发送<strong>EOS</strong>（主要目的看是否<em><strong>trasnfer</strong></em>中的<em>print</em>是否有输出）</p>
<blockquote>
<p>cleos push action + 账户名 + 需要调用的action + ‘调用action的参数’ + -p + 转账账户 （+ -j）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cleos push action eosio.token transfer <span class="string">&#x27;[&quot;sender&quot;,&quot;notifier&quot;,&quot;10.0000 EOS&quot;,&quot;transfer himself&quot;]&#x27;</span> -p sender -j</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：加了一个 <strong>-j</strong> ，说明结果以json的格式进行输出的</p>
<p>结果显示：测试合约的<strong>transfer</strong>函数被调用了</p>
<p>结果显示：</p>
<img src="/2021/12/07/EOSIO-Vulneribilities/export.png" class="" title="export"></li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>EOSIO</category>
      </categories>
      <tags>
        <tag>EOSIO</tag>
        <tag>漏洞</tag>
        <tag>智能合约</tag>
        <tag>防护</tag>
      </tags>
  </entry>
  <entry>
    <title>构建hexo博客过程</title>
    <url>/2021/12/07/%E6%9E%84%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h4 id="环境（Windows）"><a href="#环境（Windows）" class="headerlink" title="环境（Windows）"></a>环境（Windows）</h4><ul>
<li>git（git version 2.29.2.windows.3）</li>
<li>node（v14.17.0）</li>
</ul>
<hr>
<span id="more"></span>

<h4 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h4><ul>
<li><p>安装cnpm（国内镜像源很慢）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p> “-g”：表示全局安装</p>
<p> 验证是否安装成功：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm -v</span><br></pre></td></tr></table></figure>

<p> 设置源：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org </span><br></pre></td></tr></table></figure></li>
<li><p>安装hexo</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p> 验证是否安装成功：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个目录（出错直接删掉目录即可）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir myBlog</span><br><span class="line">$ <span class="built_in">cd</span> myBlog</span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></li>
<li><p>启动hexo</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p> 访问地址:localhost:4000</p>
</li>
</ul>
<h4 id="GitHub部署"><a href="#GitHub部署" class="headerlink" title="GitHub部署"></a>GitHub部署</h4><ul>
<li><p>创建一个仓库，仓库名必须为：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yourname.github.io</span><br></pre></td></tr></table></figure></li>
<li><p>安装插件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件（在文件最下面修改）</p>
<ul>
<li><p>Windows 下直接可以用文本打开</p>
</li>
<li><p>其他系统可以用vim</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 添加以下内容</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:                                                      </span><br><span class="line">	<span class="built_in">type</span>: git</span><br><span class="line">	repo: https://github.com:yourname/yourname.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>部署到远端（可以提前配置好git账号和密码）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li>
<li><p>访问远程博客</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://yourname.github.io.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="换主题"><a href="#换主题" class="headerlink" title="换主题"></a>换主题</h4><ul>
<li><p>下载主题（下载到themes目录下）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes.yilia</span><br></pre></td></tr></table></figure></li>
<li><p>修改</p>
<ul>
<li><p>Windows 下直接可以用文本打开</p>
</li>
<li><p>其他系统可以用vim</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 修改以下内容</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: yilia</span><br></pre></td></tr></table></figure></li>
<li><p>重新生成</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></table></figure></li>
<li><p>远程部署到github</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol>
<li>如遇到这个问题，先检查是否是网络的原因 ，多部署几次，如果还是不行，则采用以下方式：</li>
</ol>
<img src="/2021/12/07/%E6%9E%84%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/image-20211209184952522.png" class="" title="image-20211209184952522">

<ul>
<li><p>方法一：在当前目录下操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 删除git提交内容文件夹</span></span><br><span class="line">$ rm -rf .deploy_git/</span><br><span class="line"></span><br><span class="line"><span class="comment">##执行</span></span><br><span class="line">$ git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##最后</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：有可能是你的git repo配置地址不正确,可以将http方式变更为ssh方式，在当前目录下操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##删除git提交内容文件夹</span></span><br><span class="line">$ vim _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">##修改</span></span><br><span class="line">deploy:</span><br><span class="line">	<span class="built_in">type</span>: git</span><br><span class="line">	repo:https://github.com/yourname/yourname.github.io.git -&gt;</span><br><span class="line">			git@github.com:a956551943/weixiaohui.github.io.git</span><br><span class="line">	branch: master</span><br><span class="line"></span><br><span class="line"><span class="comment">##最后</span></span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li><p>方法三：备选，在当前目录下操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##进入depoly文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> .deploy_git/</span><br><span class="line"></span><br><span class="line"><span class="comment">##强制推送</span></span><br><span class="line">$ git push -f</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>遇到新建博客文章部署之后图片不显示的问题</p>
<blockquote>
<p>在Typora中的工具栏中的“格式” –&gt; “图像” –&gt; “全局图像设置”中设置如下，此后会在当前目录下生成包含图片同名的文件</p>
</blockquote>
<p>另外，在文章开始部分加上以上命令即可解决图片不显示的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span> </span><br></pre></td></tr></table></figure>

<img src="/2021/12/07/%E6%9E%84%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/image-20211209185640095.png" class="" title="image-20211209185640095"></li>
<li></li>
</ol>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
